{"meta":{"title":"陈恩得的个人技术专栏","subtitle":"成长 在于分享","description":"陈恩得的个人技术专栏","author":"陈恩得","url":"https://www.chenende.top"},"pages":[{"title":"tags","date":"2019-02-09T21:08:37.000Z","updated":"2019-02-24T19:18:39.832Z","comments":true,"path":"tags/index.html","permalink":"https://www.chenende.top/tags/index.html","excerpt":"","text":"#MySql#linux#ubuntu#sublimeText#git#vue"},{"title":"categories","date":"2019-02-09T21:08:57.000Z","updated":"2019-02-19T17:41:42.284Z","comments":true,"path":"categories/index.html","permalink":"https://www.chenende.top/categories/index.html","excerpt":"","text":"MySql sublimeText git vue"},{"title":"about-chenende","date":"2019-02-09T21:18:02.000Z","updated":"2019-06-06T06:59:27.650Z","comments":true,"path":"about-me/index.html","permalink":"https://www.chenende.top/about-me/index.html","excerpt":"","text":"public class AboutMe { private String name = “陈恩得”; private String gender = “男”; private String nativePlace = “河南郑州”; private String currentResidence = “浙江杭州”; private String diploma = “本科”; private String job = “java后端开发工程师”; private String technicalGrade = “★★”; public void getIntroduceOneself(){ System.out.println(“…”); } public void getMotto(){ System.out.println(“越努力，越幸运！”); } public void getAspirations(){ System.out.println(“成长 在于分享！希望自己能在不断积累的过程中持续成长， 也希望我的分享对每一个造访者都能够有所帮助,同时也希望各位能不吝赐教，及时指出我的不足之处， 在此先行谢过！”); } public void getNewYearWishes(){ System.out.println(“2019 持续学习，不断充实自己…”); }} o o === === 08880 08880 0888880 0888880 o8888888o o8888888o 88&quot; . &quot;88 88&quot; . &quot;88 (| -_- |) (| -_- |) O\\ = /O O\\ = /O ____/`---&apos;\\____ ____/`---&apos;\\____ .&apos; \\\\| |// `. .&apos; \\\\| |// `. / \\\\||| : |||// \\ / \\\\||| : |||// \\ / _||||| -:- |||||- \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | | \\\\\\ - /// | | | \\_| &apos;&apos;\\---/&apos;&apos; | | | \\_| &apos;&apos;\\---/&apos;&apos; | | \\ .-\\__ `-` ___/-./ \\ .-\\__ `-` ___/-./ ___`. .&apos; /--.--\\ `. . __ ___`. .&apos; /--.--\\ `. . __ .&quot;&quot; &apos;&lt; `.___\\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. .&quot;&quot; &apos;&lt; `.___\\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. | | : `- \\`.;`\\ _ /`;.`/ - ` : | | | | : `- \\`.;`\\ _ /`;.`/ - ` : | | chen \\ \\ `-. \\_ __\\ /__ _/ .-` / / de day\\ \\ `-. \\_ __\\ /__ _/ .-` / /day ======`-.____`-.___\\__en_/___.-`____.-&apos;====== ======`-.____`-.___\\__up_/___.-`____.-&apos;====== `=---=&apos; `=---=&apos;"}],"posts":[{"title":"springCloud之服务治理工具Eureka","slug":"Eureka","date":"2019-07-09T18:24:00.000Z","updated":"2019-07-09T18:24:54.417Z","comments":true,"path":"2019/07/10/Eureka/","link":"","permalink":"https://www.chenende.top/2019/07/10/Eureka/","excerpt":"","text":"前言","categories":[{"name":"springCloud","slug":"springCloud","permalink":"https://www.chenende.top/categories/springCloud/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"https://www.chenende.top/tags/springCloud/"}]},{"title":"java 注解","slug":"annotation","date":"2019-06-07T05:20:09.000Z","updated":"2019-06-07T15:33:56.687Z","comments":true,"path":"2019/06/07/annotation/","link":"","permalink":"https://www.chenende.top/2019/06/07/annotation/","excerpt":"前言注解就是符合一定格式的语法 @xxxx,按照用途不同可分为：1.在阅读程序时清楚—-给程序员看的;2.给jvm看的，给机器看的注解在目前而言最主流的应用：代替配置文件;关于配置文件与注解开发的优缺点：1.注解优点：开发效率高、成本低;2.注解缺点：耦合性大 并且不利于后期维护 jdk5提供的注解@Override：告知编译器此方法是覆盖父类的@Deprecated：标注过时@SuppressWarnings：压制警告 不同的注解只能在不同的位置使用(方法上、字段上、类上)","text":"前言注解就是符合一定格式的语法 @xxxx,按照用途不同可分为：1.在阅读程序时清楚—-给程序员看的;2.给jvm看的，给机器看的注解在目前而言最主流的应用：代替配置文件;关于配置文件与注解开发的优缺点：1.注解优点：开发效率高、成本低;2.注解缺点：耦合性大 并且不利于后期维护 jdk5提供的注解@Override：告知编译器此方法是覆盖父类的@Deprecated：标注过时@SuppressWarnings：压制警告 不同的注解只能在不同的位置使用(方法上、字段上、类上) 自定义注解1.使用@interface关键字定义注解 public @interface Annotation { String name(); int age() default 18; } 注解中的属性：类型 变量名+(); 使用default为属性添加默认值。 注解属性类型只能是以下几种： 1.基本类型 2.String 3.枚举类型 4.注解类型 5.Class类型 6.以上类型的一维数组类型 2.声明注解的类型和作用范围 介入一个概念：元注解：代表修饰注解的注解，作用：限制定义的注解的特性 使用@Retention声明注解作用范围，有以值： SOURCE: 注解在源码级别可见 CLASS：注解在字节码文件级别可见 RUNTIME：注解在整个运行阶段都可见 使用@Target声明注解类型，代表注解修饰的范围：类上使用，方法上使用，字段上使用 FIELD:字段上可用此注解 METHOD:方法上可以用此注解 TYPE:类/接口上可以使用此注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Annotation { String name(); int age() default 18; } 上面定义的注解表示只能在方法上使用，在整个运行阶段都会起作用。 自定义注解的使用public class Test { @Annotation(name=&quot;tom&quot;) public void get(){ } } 如果注解中只有一个属性，且名称为value,那在使用的时候就可以活力key即上例中的name直接写值即可。 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Annotation { //注解中只有一个属性，名称为value String value(); } public class Test { //在使用的时候直接写值 @Annotation(&quot;tom&quot;) public void get(){ } } 解析注解注解的解析是通过反射机制来完成的，利用反射获取注解属性值，然后在后续逻辑代码中使用。在使用框架的时候框架中定义的注解，解析注解的工作由框架来完成，自定义的需要手动使用反射来解析，若在AOP中使用的话则会被框架解析，无需手动解析。 定义注解： @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Annotation { String[] value(); } 使用注解： public class Test { @Annotation({&quot;tom&quot;,&quot;18&quot;,&quot;河南郑州&quot;}) public void get(){ } } 解析注解： public static void main(String[] args) { try { Class test = Class.forName(&quot;Test&quot;); //通过反射获取类中的方法 Method method = test.getMethod(&quot;get&quot;, null); //获取方法上使用的注解 Annotation annotation = method.getAnnotation(Annotation.class); //获取注解中的属性值 String[] value = annotation.value(); System.out.println(Arrays.toString(value)); } catch (Exception e) { e.printStackTrace(); } } 结果： [tom, 18, 河南郑州] 使用自定义注解结合面向切面编程思想可实现在指定方法执行前后输出日志的功能，省去手写日志的麻烦。具体可参考：springboot 自定义注解+AOP 实现日志记录Java获取当前运行的类名, 方法名,代码行数?使用Idea的Live Templates模板功能轻松敲出来AOP","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"springCloud 微服务治理工具","slug":"SpringCloud","date":"2019-06-06T06:42:33.000Z","updated":"2019-07-09T18:22:11.152Z","comments":true,"path":"2019/06/06/SpringCloud/","link":"","permalink":"https://www.chenende.top/2019/06/06/SpringCloud/","excerpt":"前言springCloud是spring提供的微服务治理工具的集合，在分布式项目中它和dubbo发挥着同等的作用，但还提供了比dubbo更为全面的分布式解决方案。下面是更官方的介绍： Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包 sprongCloud工具集 从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。","text":"前言springCloud是spring提供的微服务治理工具的集合，在分布式项目中它和dubbo发挥着同等的作用，但还提供了比dubbo更为全面的分布式解决方案。下面是更官方的介绍： Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包 sprongCloud工具集 从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。 * 其中Eureka负责服务的注册与发现，很好将各服务连接起来 * Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。 * Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示 * Spring Cloud Config 提供了统一的配置中心服务 * 当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息 * 所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用 * 最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析 Spring Cloud从设计之初就考虑了绝大多数互联网公司架构演化所需的功能，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。这些功能都是以插拔的形式提供出来，方便我们系统架构演进的过程中，可以合理的选择需要的组件进行集成，从而在架构演进的过程中会更加平滑、顺利 springCloud 特性以下为Spring Cloud的核心特性： 分布式/版本化配置 服务注册和发现 路由 服务和服务之间的调用 负载均衡 断路器 分布式消息传递 为什么考虑Spring Cloud Spring Cloud来源于Spring，质量、稳定性、持续性都可以得到保证 Spirng Cloud天然支持Spring Boot，更加便于业务落地。 Spring Cloud发展非常的快，从16年开始接触的时候相关组件版本为1.x，到现在将要发布2.x系列 Spring Cloud是Java领域最适合做微服务的框架。 相比于其它框架,Spring Cloud对微服务周边环境的支持力度最大。 对于中小企业来讲，使用门槛较低。 SOA和微服务的区别其实服务化架构已经可以解决大部分企业的需求了，那么我们为什么要研究微服务呢？先说说它们的区别； 微服务架构强调业务系统需要彻底的组件化和服务化，一个组件就是一个产品，可以独立对外提供服务 微服务不再强调传统SOA架构里面比较重的ESB企业服务总线 微服务强调每个微服务都有自己独立的运行空间，包括数据库资源。 微服务架构本身来源于互联网的思路，因此组件对外发布的服务强调了采用HTTP Rest API的方式来进行 微服务的切分粒度会更小 更多可参考：微服务领域,为什么选SpringCloud而不是Dubbo?听听八年阿里架构师怎样讲述Dubbo和Spring Cloud微服务架构吧","categories":[{"name":"springCloud","slug":"springCloud","permalink":"https://www.chenende.top/categories/springCloud/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"https://www.chenende.top/tags/springCloud/"}]},{"title":"dubbo集群容错与负载均衡策略","slug":"dubbo","date":"2019-06-05T13:38:26.000Z","updated":"2019-06-06T04:54:02.329Z","comments":true,"path":"2019/06/05/dubbo/","link":"","permalink":"https://www.chenende.top/2019/06/05/dubbo/","excerpt":"前言正常情况下，当我们进行系统设计时候，不仅要考虑正常逻辑下代码该如何走，还要考虑异常情况下代码逻辑应该怎么走。当服务消费方调用服务提供方的服务出现错误时候，Dubbo提供了多种容错方案，缺省模式为failover，也就是失败重试。 Dubbo的集群容错策略集群策略配置： &lt;dubbo:reference cluster=&quot;failfast&quot; /&gt; Failover Cluster：失败重试 当服务消费方调用服务提供者失败后自动切换到其他服务提供者服务器进行重试。这通常用于读操作或者具有幂等的写操作，需要注意的是重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数（不含第一次）。 接口级别配置重试次数方法 &lt;dubbo:reference retries=&quot;2&quot; /&gt; ，如上配置当服务消费方调用服务失败后，会再重试两次，也就是说最多会做三次调用，这里的配置对该接口的所有方法生效。当然你也可以针对某个方法配置重试次数如下： &lt;dubbo:reference&gt; &lt;dubbo:method name=&quot;sayHello&quot; retries=&quot;2&quot; /&gt; &lt;/dubbo:reference&gt;","text":"前言正常情况下，当我们进行系统设计时候，不仅要考虑正常逻辑下代码该如何走，还要考虑异常情况下代码逻辑应该怎么走。当服务消费方调用服务提供方的服务出现错误时候，Dubbo提供了多种容错方案，缺省模式为failover，也就是失败重试。 Dubbo的集群容错策略集群策略配置： &lt;dubbo:reference cluster=&quot;failfast&quot; /&gt; Failover Cluster：失败重试 当服务消费方调用服务提供者失败后自动切换到其他服务提供者服务器进行重试。这通常用于读操作或者具有幂等的写操作，需要注意的是重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数（不含第一次）。 接口级别配置重试次数方法 &lt;dubbo:reference retries=&quot;2&quot; /&gt; ，如上配置当服务消费方调用服务失败后，会再重试两次，也就是说最多会做三次调用，这里的配置对该接口的所有方法生效。当然你也可以针对某个方法配置重试次数如下： &lt;dubbo:reference&gt; &lt;dubbo:method name=&quot;sayHello&quot; retries=&quot;2&quot; /&gt; &lt;/dubbo:reference&gt; Failfast Cluster：快速失败 当服务消费方调用服务提供者失败后，立即报错，也就是只调用一次。通常这种模式用于非幂等性的写操作。 Failsafe Cluster：失败安全 当服务消费者调用服务出现异常时，直接忽略异常。这种模式通常用于写入审计日志等操作。 Failback Cluster：失败自动恢复 当服务消费端用服务出现异常后，在后台记录失败的请求，并按照一定的策略后期再进行重试。这种模式通常用于消息通知操作。 Forking Cluster：并行调用 当消费方调用一个接口方法后，Dubbo Client会并行调用多个服务提供者的服务，只要一个成功即返回。这种模式通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。 Broadcast Cluster：广播调用 当消费者调用一个接口方法后，Dubbo Client会逐个调用所有服务提供者，任意一台调用异常则这次调用就标志失败。这种模式通常用于通知所有提供者更新缓存或日志等本地资源信息。 如上，Dubbo本身提供了丰富的集群容错模式，但是如果您有定制化需求，可以根据Dubbo提供的扩展接口Cluster进行定制。在后面的消费方启动流程章节会讲解何时/如何使用的集群容错。 在实际项目中，生产环境中，我们用failover模式时可以这样设计服务接口，遵循接口隔离原则 ，查询服务与写操作服务隔离， 查询接口我们可以配置retries=”2” 在写操作接口我们配置retries=”0” ,如果不设置为0, 超时，会重新连接，会出现重复写的情况,所以使用failover模式时，我们要进行读写操作接口隔离，且写操作接口retries=0 Dubbo的负载均衡策略当服务提供方是集群的时候，为了避免大量请求一直落到一个或几个服务提供方机器上，从而使这些机器负载很高，甚至打死，需要做一定的负载均衡策略。Dubbo提供了多种均衡策略，缺省为random，也就是每次随机调用一台服务提供者的机器。 Dubbo提供的负载均衡策略: Random LoadBalance：随机策略。按照概率设置权重，比较均匀，并且可以动态调节提供者的权重。 RoundRobin LoadBalance：轮询策略。轮询，按公约后的权重设置轮询比率。会存在执行比较慢的服务提供者堆积请求的情况，比如一个机器执行的非常慢，但是机器没有挂调用（如果挂了，那么当前机器会从Zookeeper的服务列表删除），当很多新的请求到达该机器后，由于之前的请求还没有处理完毕，会导致新的请求被堆积，久而久之，所有消费者调用这台机器上的请求都被阻塞。 LeastActive LoadBalance：最少活跃调用数。如果每个提供者的活跃数相同，则随机选择一个。在每个服务提供者里面维护者一个活跃数计数器，用来记录当前同时处理请求的个数，也就是并发处理任务的个数。所以如果这个值越小说明当前服务提供者处理的速度很快或者当前机器的负载比较低，所以路由选择时候就选择该活跃度最小的机器。如果一个服务提供者处理速度很慢，由于堆积，那么同时处理的请求就比较多，也就是活跃调用数目越大，这也使得慢的提供者收到更少请求，因为越慢的提供者的活跃度越来越大。 ConsistentHash LoadBalance：一致性Hash策略。一致性Hash，可以保证相同参数的请求总是发到同一提供者，当某一台提供者挂了时，原本发往该提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动。 更多可参考：Dubbo的集群容错与负载均衡策略","categories":[{"name":"java web","slug":"java-web","permalink":"https://www.chenende.top/categories/java-web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://www.chenende.top/tags/java-web/"}]},{"title":"分布式事务","slug":"DistributedTransaction","date":"2019-06-05T13:32:07.000Z","updated":"2019-06-06T04:16:14.141Z","comments":true,"path":"2019/06/05/DistributedTransaction/","link":"","permalink":"https://www.chenende.top/2019/06/05/DistributedTransaction/","excerpt":"前言眼下貌似有点规模的公司面试的时候都会问公布式事务的问题，有的问得比较委婉先以分布式框架为引子，分布式框架？？？刚开始的时候我一脸蒙逼，能想到的只有dubbo、MQ这些分布式技术，并没有把它们当成框架来使用，一时间也就没能反映过来。事实上说的也就是它们。委婉的面试官会如何保证dubbo服务的幂等性？又是一脸蒙带，什么是幂等,我以为是自己耳背，反复问了好几遍都没听明白后，只能回答不知道。那位面试官可以意识到了自己的专业性，索性换了种通俗点的问法，问在一个方法中调用多个dubbo服务，如何保证事务操作的一致性？这次真的听懂了，也真的是蒙逼了。之前听别人说过分布式事务，通过MQ消息中间件可以实现分布式事务，但只是泛泛而谈并未深入思考过。在经历好几次面试都被提及后不得不认真思考总结一下。 分布式事务的典型案例场景描述：支付宝转账余额宝 分布式事务必须满足的条件： 1、远程RPC调用，支付宝和余额宝存在接口调用 2、支付宝和余额宝使用不同的数据库","text":"前言眼下貌似有点规模的公司面试的时候都会问公布式事务的问题，有的问得比较委婉先以分布式框架为引子，分布式框架？？？刚开始的时候我一脸蒙逼，能想到的只有dubbo、MQ这些分布式技术，并没有把它们当成框架来使用，一时间也就没能反映过来。事实上说的也就是它们。委婉的面试官会如何保证dubbo服务的幂等性？又是一脸蒙带，什么是幂等,我以为是自己耳背，反复问了好几遍都没听明白后，只能回答不知道。那位面试官可以意识到了自己的专业性，索性换了种通俗点的问法，问在一个方法中调用多个dubbo服务，如何保证事务操作的一致性？这次真的听懂了，也真的是蒙逼了。之前听别人说过分布式事务，通过MQ消息中间件可以实现分布式事务，但只是泛泛而谈并未深入思考过。在经历好几次面试都被提及后不得不认真思考总结一下。 分布式事务的典型案例场景描述：支付宝转账余额宝 分布式事务必须满足的条件： 1、远程RPC调用，支付宝和余额宝存在接口调用 2、支付宝和余额宝使用不同的数据库 在工程A中的转帐方法中使用dubbo远程分别调用支付宝和余额宝两个项目中的服务对各自的数据进行操作，这就产生一个问题：本地事务无法控制支付宝和余额宝中的事务操作，如果支付宝转帐成功，钱已经扣了，余额宝在执行数据库操作的时候失败，回滚事务，而本地事务是无法回滚支付宝中的事务的。这就导致数据不一致。 使用ActiveMQ解决分布式事务我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。 如图所示： 在支付宝和余额宝项目的数据库中分别添加message表，字段user_id、amount（转帐金额）、message_id(流水id，标识夸系统的一次转账操作),status（confirm，unconfirm） 1、支付宝扣款成功时往message表插入消息 2、使用JDK提供的timer定时器定时扫描message表的unconfirm状态记录往activemq插入消息却message对象，包括用户ID，金额和流水ID（消息插入成功说明支付宝扣款已成功，支付宝中的message表中状态是在余额宝增额完成后修改的，如果状态未完成说明余额宝那边数据修改未成功，所以需要执行幂等操作） 3、余额宝收到消息消费消息时先根据户ID查询message表如果有记录就不处理如果没记录就进行数据库增款操作 4、如果余额宝数据库操作成功往余额宝message表插入消息 5、如果4操作成功，回调支付宝接口（使用spring提供的RestTemplate url远程访问支付宝controller中的方法）修改支付宝中的message表状态，把unconfirm状态转换成confirm状态 因为message和转帐操作在同一事务中，两者要么同时成功要么同时失败，保证了在转帐成功的情况下message表中的数据必然会发生变化。通过message0表模拟多线程中的锁机制来保证了分布式事务中的幂等性。所谓幂等性就是在重复请求的情况下响应结果不会发生改变,更多可参考:什么是分布式系统中的幂等性 JAVA中使用Timer,TimerTask轮循数据库，执行定时任务RestTemplate 问题描述：1、支付宝设计message表的目的 如果支付宝往activemq插入消息而余额宝消费消息异常，有可能是消费消息成功而事务操作异常，有可能是网络异常等等不确定因素。如果出现异常而activemq收到了确认消息的信号，这时候activemq中的消息是删除了的，消息丢失了。设置message表就是有一个消息存根，activemq中消息丢失了message表中的消息还在。解决了activemq消息丢失问题 2、余额宝设计message表的目的 当余额宝消费成功并且数据库操作成功时，回调支付宝的消息确认接口，如果回调接口时出现异常导致支付宝状态修改失败还是unconfirm状态，这时候还会被timer扫描到，又会往activemq插入消息，又会被余额宝消费一边，但是这条消息已经消费成功了的只是回调失败而已，所以就需要有一个这样的message表，当余额宝消费时先插入message表，如果message根据message_id能查询到记录就说明之前这条消息被消费过就不再消费只需要回调成功即可，如果查询不到消息就消费这条消息继续数据库操作，数据库操作成功就往message表插入消息。 这样就解决了消息重复消费问题，这也是消费端的幂等操作。 更多可参考:基于activemq的分布式事务解决方案","categories":[{"name":"java web","slug":"java-web","permalink":"https://www.chenende.top/categories/java-web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://www.chenende.top/tags/java-web/"}]},{"title":"sql优化","slug":"sql","date":"2019-06-03T23:11:52.000Z","updated":"2019-06-05T13:45:37.673Z","comments":true,"path":"2019/06/04/sql/","link":"","permalink":"https://www.chenende.top/2019/06/04/sql/","excerpt":"前言sql优化总而言之就一句话，使用索引避免全表扫描。 注意事项1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0","text":"前言sql优化总而言之就一句话，使用索引避免全表扫描。 注意事项1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 5.in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 6.下面的查询也将导致全表扫描： select id from t where name like &apos;%abc%&apos; 7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=&apos;abc&apos;--name以abc开头的id 应改为: select id from t where name like &apos;abc%&apos; 9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 11.不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(...) 12.很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 13.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 14.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 15.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 16.尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 17.任何地方都不要使用 select from t ，用具体的字段列表代替“”，不要返回用不到的任何字段。 18.避免频繁创建和删除临时表，以减少系统表资源的消耗。 19.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 20.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 21.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 22.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 23.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 24.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。 在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 25.尽量避免大事务操作，提高系统并发能力。26.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。","categories":[{"name":"oracle","slug":"oracle","permalink":"https://www.chenende.top/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://www.chenende.top/tags/oracle/"}]},{"title":"oracle高级篇","slug":"oracle02","date":"2019-06-02T12:20:36.000Z","updated":"2019-06-02T13:42:41.010Z","comments":true,"path":"2019/06/02/oracle02/","link":"","permalink":"https://www.chenende.top/2019/06/02/oracle02/","excerpt":"前言本章节我们在前面基础篇的基础上过一步学习oracle的存储过程、存储函数、例外、游标、包等进阶内容。 一、plsqlplsql是面向过程语言。plsql是oracle对sql语言的过程化扩展，指在sql命令语言中增加了过程处理语句（如分支，循环等），使sql语言具有过程处理能力，把sql语言的数据操纵能力与过程语言的数据处理能力结合起来，使得plsql面向过程但比过程语言简单、高效、灵活和实用。plsql基本格式： declare --说明部分（变量说明，光标申明，例外说明） begin --程序（DML语句） dbms_output.put_line(&apos;hello world&apos;); exception 例外处理语句 end; /","text":"前言本章节我们在前面基础篇的基础上过一步学习oracle的存储过程、存储函数、例外、游标、包等进阶内容。 一、plsqlplsql是面向过程语言。plsql是oracle对sql语言的过程化扩展，指在sql命令语言中增加了过程处理语句（如分支，循环等），使sql语言具有过程处理能力，把sql语言的数据操纵能力与过程语言的数据处理能力结合起来，使得plsql面向过程但比过程语言简单、高效、灵活和实用。plsql基本格式： declare --说明部分（变量说明，光标申明，例外说明） begin --程序（DML语句） dbms_output.put_line(&apos;hello world&apos;); exception 例外处理语句 end; / 二、常量和变量的定义说明变量： char, varchar2, date, number, boolean, long 名字在前面 值在后面引用型变量： 例：name emp.ename%type 引用emp表的enmame列的类型作为变量name的类型 记录型变量 可以理解为一个数组 emp_rec emp%rowtype 将结果封装到emp表的一列中 三、if 语句语法： 1.if 条件 then 语句1 语句2 END IF; 2.IF 条件 THEN 语句序列1; ELSE 语句序列2; END IF; 3.IF 条件 THEN语句; ELSEIF 语句 THEN语句; ELSE 语句; END IF; 示例：ifif-else if-elseif-else 四、循环语句：方式一： while total&lt;=2500 loop ... total := total + salary; end loop; 当while后面的条件成立的时候执行loop和end loop之间的语句； 方式二： loop exit[when 条件]; 退出条件 ... end loop; 当exit后面的条件不成立的时候执行后面的语句 方式三： for i in 1...3 loop 语句序列; end loop; set serveroutput on：打开屏幕输出开关 五、游标oracle中使用游标来表示集合 CURSOR 游标名 [(参数名 数据类型，参数名，数据类型...)] is select 语句; 使用步骤： 打开游标 open c1; 取一行游标的值 fecth c1 into pjob; 取一行到变量中 关闭游标 close c1; 游标的结束方式 exit when c1%nofoud 光标的属性： %isopen(是否已打开) %rowcount(影响的行数) %found(是否找到) %nofound(是否未找到) 六、例外异常是程序设计语言提供的一种功能，用来增强程序的健壮性和容错性 系统自定义异常 no_data_found 没有找到数据 too_many_rows select...into 语句匹配多个行 zero_divide 被零除 value_error 算术或转换错误 timeout_on_resource 在等待资源时发生超时 语法格式： exception when 异常类型 then 执行语句; when others then 执行语句; 兜底 自定义例外 DECLARE 自定义变量 类型：exception; 如果遇到异常我们要抛出 raise 异常变量名; 程序发生异常后oracle PM进程会自动清理缓存释放资源，相当于java中的finaly 七、存储过程 和 存储函数指存储在数据库中供所有用户程序调用的子程序叫存储过程、存储函数，两者的区别在于存储函数可以return结果，存储过程没有返回值。但过程和函数都可以通过out指定一个或多个输出参数。我们可以利用out参数，在过程和函数中实现返回多个值。如果只有一个返回值，用存储函数，否则就用存储过程。存储过程 语法： create [or replace](创建或者替换) PROCEDURE 过程名（参数列表[变量名 in/out 类型]） AS或is PLSQL子程序体; 调用存储过程 1.execute可以缩写exec 存储过程名字();存储函数 语法： create [or replace] function 函数名（参数列表[变量名 in/out 类型]） function 函数值类型 as 或 is plsql子程序体; 八、包使用包可以将结果集封装到游标中，实现返回结果集的目的。例如：查询某个部门所有员工的信息 声明包结构 create or replace package mypackage as type empcursor is ref cursor; procedure queryEmpList(dno in number,empList out empcursor); end mypackage; 创建包体 create or replace package body mypackage as procedure queryEmpList(dno in number,empList out empcursor) AS begin open empList for select * from emp where deptno=dno; end queryEmpList; end mypackage; 九、触发器 trigger数据库触发器是一个与表相关联的、存储的PL/SQL程序，每当一个特定的数据操作语句（insert,update,delete）在指定表上发出时，ORACLE将自动执行触发器中定义的语句序列。触发器的作用： 触发器的类型： 示例： 在触发器中触发语句与伪变量记录的值： 示例： 更多可参考触发器以及应用场景 十sql优化原则1.尽量使用列名取代*,避免全表扫描2.where解析顺序：从右往左3.尽量使用where语句，少用having，where先过滤再分组，having先分组再过滤","categories":[{"name":"oracle","slug":"oracle","permalink":"https://www.chenende.top/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://www.chenende.top/tags/oracle/"}]},{"title":"oracle基础篇","slug":"oracle","date":"2019-06-02T10:50:17.000Z","updated":"2019-06-02T13:42:41.086Z","comments":true,"path":"2019/06/02/oracle/","link":"","permalink":"https://www.chenende.top/2019/06/02/oracle/","excerpt":"前言在本章节中我们一起来学习oracle数据库的基础知识。 基础篇1.基本查询 查看当前用户下的表：select * from tab;查看表结构： desc 表名； show linesize:查看行宽 set linesize 120:设置行宽 设置列宽： col 列名 for a8(a表示字符串长度8个字符) col sal for 999(9表示数据，999三位数字) /：表示执行上一条sql","text":"前言在本章节中我们一起来学习oracle数据库的基础知识。 基础篇1.基本查询 查看当前用户下的表：select * from tab;查看表结构： desc 表名； show linesize:查看行宽 set linesize 120:设置行宽 设置列宽： col 列名 for a8(a表示字符串长度8个字符) col sal for 999(9表示数据，999三位数字) /：表示执行上一条sql2.修改命令行中的sql语句 1.输入行号 2.c /要修改的内容/目标内容; 其中c是change的缩写 3. / 重新执行 3.sql中的null空值是无效的，未指定的，未知的或不可预知的值,空值不是空格或者0； 1.包含null的表达式都为null 2.null永远！=null 3.如果集合中含有空值不能使用not in,但可以使用in 4.空值最大。 5.滤空函数：nvl(a,b) 如果a为null就返回b,否则返回a 4.定义别名的三种方式 ename as &quot;name&quot; ename &quot;name&quot; ename name (不能有特殊字符) 5.concat连接符 select concat(id,&quot; &quot;,name) from 表名;将id+” “+name拼接显示在一列6.dual伪表oracle和mysql中特殊的表，伪表。7.伪列：level8.字符串 * 1.字符串可以是select列表中的一个字符，数字，日期 * 2.日期和字符串只能在单引号中出现，列的别名使用双引号。 * 3.每当返回一列时，字符串被输出一次。 * 4.字符串大小写敏感，日期格式敏感。 * 5.默认日期格式：DD-MON-RR （日月年） 9.sql和sql*plussql*plus:oracle提供的命令行工具。可以缩写 常用命令： desc(describe) ed(edit) c(change) for(format) col(column) sql:操作数据库的语句。关键字不能缩写 常用命令： select insert update delete isql*plus:sql*plus的网页版plsql：oracle独有的面向过程的语言10.spoolspool+路径:oracle提供的录屏工具，能够把命令行中输入的内容自动保存到指定路径的txt文本文件中。spppl off：表示结束录制，执行保存11.条件查询和排序 11.1.声明转义字符：oracle中使用转义字符需要使用escape声明 例：where ename like &#39;%\\_%&#39; escape &#39;\\&#39;:声明使用`作为转义字符。`oracle自动开启事务，使用rollback可以回滚事务。 11.2.order by 多列排序： 升序 order by 列1,列2;先按照列1进行排序，如果列1值相同则按照列2进行排序。 降序 order by 列1,列2 desc;先按照列1进行升序排序，如果列1相同则按照列2降序排序 order by 列1 desc,列2 desc;先按照列1降序排序，如果列1相同则按照列2降序排序。 11.3.排序后的表否是原来的表？如果要排序的列中包含空值，因为oracle中空值最大，在降序排序的时候会被放在最前面，可以使用nulls last将空值放在最后： select * from emp order by comm desc nulls last; 多行函数会自动滤空，可以嵌套nvl滤空函数来保留空行 12.oracle中的函数分为单选函数和多行函数 12.1.单行函数：学习函数的目的是为了简化操作 12.1.1字符： 大小写控制函数： LOWER：转小写 UPPER：转大写 INITCAP：首字母大写 字符控制函数： CONCAT：mysql中的字符串连接查询 ||：oracle中的字符串连接查询 例： SUBSTR： substr(a,b) 从a中，第b位开始取。 substr(a,b,c) 从a中，第b位开始取，取c个 LENGTE/LENGTHB： length 字符数；lengthb 字节数 INSTR： instr(a,b) 在a中查找b,返回索引值 LPAD | RPAD： lpad（a,b,c） 左填充 字符串a一共有b位，不満b位的使用c填充 rpad(a,b,c) 右填充 字符串a一共有b位，不満b位的使用c填充 TRIM： trim(a from b) 去掉字符串b前后指定的字符a REPLACE： replace(a,b,c)替换字符串a中的b为c 12.1.2数值： ROUND:四舍五入 ROUND（45.926,2） 45.93 TRUNC：截断 TRUNC（45.926,2） 45.92 MOD：求余 MOD（1600,300） 100 12.1.3日期： DATE=日期+时间 sysdate 当前时间 将日期转为字符串：to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;) 昨天sysdate-1 今天sysdate 明天sysdate+1 日期的数学运算：日期只能进行加减运算 两个日期不能相加 在日期上加上或减去一个数字结果仍为日期 两个日期相减返回日期之间相差的天数 可以用数字除24 日期函数： MONTHS_RETWEEN:两个日期相差的月数 ADD_MONTHS:向指定日期中加上若干月数 NEXT_DAY:指定日期的下一个日期 例: next_day(sysdate,&apos;星期五‘)：下个星期五 LAST_DAY:本月的最后一天 ROUND：日期四舍五入 round(sysdate,&apos;month&apos;) 以月份进行四舍五入，过了该月的一半月份加1 round(sysdate,&apos;year&apos;) 以年进行四舍五入，过了该年的一半年份加1 TRUNC：日期截断 trunc(sysdate,&apos;month&apos;) 以月份进行截断 trunc(sysdate,&apos;year&apos;) 以年份进行截断 日期格式： 12.1.4.转换： 隐式字符串日期-&gt;date 显式 SUBSTR： substr(a,b) 从a中，第b位开始取。 substr(a,b,c) 从a中，第b位开始取，取c个 LENGTE/LENGTHB： length 字符数；lengthb 字节数 INSTR： instr(a,b) 在a中查找b,返回索引值 LPAD | RPAD： lpad（a,b,c） 左填充 字符串a一共有b位，不満b位的使用c填充 rpad(a,b,c) 右填充 字符串a一共有b位，不満b位的使用c填充 TRIM： trim(a from b) 去掉字符串b前后指定的字符a REPLACE： replace(a,b,c)替换字符串a中的b为c varchar2 or char to number 字符转数字 varchar2 or char to date 字符转日期 number to varchar2 to varchar2 数字转字符 date varchar2 to varchar2 日期转字符 TO_CHAR(date,&apos;format_model&apos;):将数据按照指定格式转换成字符串 数字转换的格式： 9 一位数字 0 零 $ 美元符 L 本地货币符号 . 小数点 ， 千位符 TO_NUMBER(char[,&apos;format_model&apos;]):将字符串转数字 TO_DATE(char[,&apos;format_mode&apos;]):将字符串转换成日期 12.1.5.通用： nvl(expr1,expr2) nvl2(expr1,expr2,expr3)：当expr1为null返回expr3,否则返回expr2 nullif(expr1,expr2):判断expr1,expr2是否相等，相等返回null，否则返回expr1 coalesce(expr1,expr2,...exprn)：从左向往找到第一个不为空的值 12.1.6.条件表达式： 使用where语句对结果进行过滤 常用的运算符：其他比较运算符：逻辑运算符： 12.1.7.在sql中实现if-else case sql99规范： case job when &apos;president&apos; then sal+1000 when &apos;mamager&apos; then sal+800 else sal+400 end 涨后 decode oracle中独有语句： decode(job,&apos;president&apos;,sal+1000), &apos;manager&apos;,sal+800, sal+100) 涨后 12.2.多行函数： AVG COUNT MAX MIN SUM 12.3.GROUP BY： 包含在GROUP BY子句中的列不必包含在SELECT列表中 包含在select列表中的列必须包含在GROUP BY子句中13.多表查询 SQL&gt; 左外连接: 当where e.deptno=d.deptno不成立的时候，等号左边的表任然被包含在最后的结果中 SQL&gt; 写法:where e.deptno=d.deptno(+) SQL&gt; 右外连接: 当where e.deptno=d.deptno不成立的时候，等号右边的表任然被包含在最后的结果中 SQL&gt; 写法:where e.deptno(+)=d.deptno 自连接不适合操作大表，产生笛卡尔积,优点结果直观14.层次查询 只能有一张表，本质上是单表查询，性能好，结果不够直观 select from emp connect by 上一层的员工=老板 start with 起始条件","categories":[{"name":"oracle","slug":"oracle","permalink":"https://www.chenende.top/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://www.chenende.top/tags/oracle/"}]},{"title":"Hibernate之批量查询","slug":"hibernate-02","date":"2019-05-28T03:46:02.000Z","updated":"2019-06-02T10:55:36.144Z","comments":true,"path":"2019/05/28/hibernate-02/","link":"","permalink":"https://www.chenende.top/2019/05/28/hibernate-02/","excerpt":"前言本章我们一起来学习一下hibernate对操作数据库的三种方式：hql查询，Criteria查询和原生sql查询。 HQL查询Hibernate独家查询语言,属于面向对象的查询语言 1.基本查询 基本语法","text":"前言本章我们一起来学习一下hibernate对操作数据库的三种方式：hql查询，Criteria查询和原生sql查询。 HQL查询Hibernate独家查询语言,属于面向对象的查询语言 1.基本查询 基本语法 排序 聚合查询 投影查询（仅查询一部分） 2.条件查询 ?点位符 命名占位符 分页查询 3.多表查询 内连接 左外连接 右外连接 Criteria查询(单表条件查询)Hibernate自创的无语句面向对象查询 1.基本查询 2.条件查询 3.分页查询 4.设置查询总记录数 5.排序 离线查询 原生SQL查询(复杂的业务查询) 1.基本查询 返回数组List *返回对象List 2.条件查询 3.分页查询 查询优化类级别查询 get方法:没有任何策略.调用即立即查询数据库加载数据. load方法: 应用类级别的加载策略 lazy(默认值):true, 查询类时,会返回代理对象.会在使用属性时,根据关联的session查询数据库.加载数据. lazy:false. load方法会与get方法没有任何区别.调用时即加载数据. 结论:为了提高效率.建议使用延迟加载(懒加载) 注意:使用懒加载时要确保,调用属性加载数据时,session还是打开的.不然会抛出异常 关联级别查询 集合策略 关联属性策略 结论:为了提高效率.fetch的选择上应选择select. lazy的取值应选择 true. 全部使用默认值. no-session问题解决: 扩大session的作用范围. 批量抓取","categories":[{"name":"hibernate","slug":"hibernate","permalink":"https://www.chenende.top/categories/hibernate/"}],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"https://www.chenende.top/tags/hibernate/"}]},{"title":"Hibernate之理论篇","slug":"hibernate","date":"2019-05-28T02:54:32.000Z","updated":"2019-05-28T03:49:40.791Z","comments":true,"path":"2019/05/28/hibernate/","link":"","permalink":"https://www.chenende.top/2019/05/28/hibernate/","excerpt":"前言Hibernate是ORM（对象关系映射）持久层框架，在传统项目中运用比较广泛，除此之外还有spring-data-jpa，它们都是ORM思想的技术实现。Hibernate的好处：操作数据库的时候,可以以面向对象的方式来完成.不需要书写SQL语句，能够根据实体对象和配置信息自动生成数据表。 基本配置 1.创建实体对象 实体类 ORM元数据 2.书写配置文件","text":"前言Hibernate是ORM（对象关系映射）持久层框架，在传统项目中运用比较广泛，除此之外还有spring-data-jpa，它们都是ORM思想的技术实现。Hibernate的好处：操作数据库的时候,可以以面向对象的方式来完成.不需要书写SQL语句，能够根据实体对象和配置信息自动生成数据表。 基本配置 1.创建实体对象 实体类 ORM元数据 2.书写配置文件 数据库连接 是否打印sql语句和表生成策略 导入orm元数据 3.书写测试代码 第一步通过Configuration对象加载配置文件，获取session开启事务，获取持久化对象，提交事务关闭连接 4.实体创建规则 1.持久化类提供无参数构造 2.成员变量私有,提供共有get/set方法访问.需提供属性 3.持久化类中的属性,应尽量使用包装类型 4.持久化类需要提供oid.与数据库中的主键列对应 5.不要用final修饰class（hibernate使用cglib代理生成代理对象.代理对象是继承被代理对象.如果被final修饰.将无法生成代理.） 5.主键生成策略 1.sequence: Oracle中的主键生成策略. 2.increment(了解): 主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值. 3.hilo(了解): 高低位算法.主键自增.由hibernate来维护.开发时不使用. 4.native:hilo+sequence+identity 自动三选一策略. 5.uuid: 产生随机字符串作为主键. 主键类型必须为string 类型. hibernate中的对象状态瞬时状态: 没有id,没有在session缓存中 持久化状态: 有id,在session缓存中 游离|托管状态: 有id,没有在session缓存中 如上图所示，通过session调用get方法后，实体类即与session发生关系，由瞬时或/游离态变成持久态，此时对实体中的属性进行增删改的操作在事务提交后都会自动同步到数据库，无需再调用update/delete或save方法 一级缓存缓存:提高效率.hibernate中的一级缓存也是为了提高操作数据库的效率. 1.提高查询效率 2.减少不必要的修改语句发送 事务管理业务开始之前打开事务,业务执行之后提交事务. 执行过程中出现异常.回滚事务. 在dao层操作数据库需要用到session对象.在service控制事务也是使用session对象完成. 我们要确保dao层和service层使用的使用同一个session对象 在hibernate中,确保使用同一个session的问题,hibernate已经帮我们解决了. 我们开发人员只需要调用sf.getCurrentSession()方法即可获得与当前线程绑定的session对象 注意1: 调用getCurrentSession方法必须配合主配置中的一段配置 注意2:通过getCurrentSession方法获得的session对象.当事务提交时,session会自动关闭.不要手动调用close关闭.","categories":[{"name":"hibernate","slug":"hibernate","permalink":"https://www.chenende.top/categories/hibernate/"}],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"https://www.chenende.top/tags/hibernate/"}]},{"title":"ubuntu安装hexo","slug":"hexo","date":"2019-05-27T18:02:37.000Z","updated":"2019-05-27T18:45:27.470Z","comments":true,"path":"2019/05/28/hexo/","link":"","permalink":"https://www.chenende.top/2019/05/28/hexo/","excerpt":"前言使用hexo可以搭建属于自己的博客，眼前你所看到的就是我用hexo结合github搭建的个人博客，那么本章我们就来学习一下hexo在ubuntu系统上的安装。 准备工作hexo是基于nodejs的，所以在安装hexo之前应该先把nodejs安装好。 安装nodejs对于nodejs的安装，网上有很多教程，首先不建议直接使用atp-get命令进行安装，在后面使用npm install安装模块的时候会出问题。所以建议直接从官网下载安装包，然后本地解压即可。 从官网下载 https://nodejs.org/en/download/ 将安装包解压后配置以下环境变量，nodejs就算安装好了","text":"前言使用hexo可以搭建属于自己的博客，眼前你所看到的就是我用hexo结合github搭建的个人博客，那么本章我们就来学习一下hexo在ubuntu系统上的安装。 准备工作hexo是基于nodejs的，所以在安装hexo之前应该先把nodejs安装好。 安装nodejs对于nodejs的安装，网上有很多教程，首先不建议直接使用atp-get命令进行安装，在后面使用npm install安装模块的时候会出问题。所以建议直接从官网下载安装包，然后本地解压即可。 从官网下载 https://nodejs.org/en/download/ 将安装包解压后配置以下环境变量，nodejs就算安装好了 打开环境变量配置文件 sudo gedit /etc/profile 添加内容： export NODE_HOME=/home/chenende/application/dev/node-v10.15.3-linux-x64/bin //改成你的安装路径 export PATH=$NODE_HOME:$PATH 使配置立即生效： source /etc/profile //该操作在终端关闭后将失效，尽量重启系统完成配置更新 完成上述操作后，使用node -v和npm -v命令查看node和npm的安装版本，有结果现实说明安装成功。 安装git首先使用git --version查看git是否已安装，如果没有的话使用sudo apt-get install git安装即可。git的初始化配置请参考我的另一篇博文：https://www.chenende.top/2019/02/19/git3/ 设置npm安装源nodejs中使用npm来安装模块，默认日安装源在国外，为提高下载速度我们修改为国内淘宝 1.查看镜像地址 $ npm get registry &gt; https://registry.npmjs.org/ 设成淘宝的 $ npm config set registry http://registry.npm.taobao.org/ 2.换成原来的 $ npm config set registry https://registry.npmjs.org/ 安装hexo完成上述准备工作后我们就可以开始安装hexo了，只要使用下面两条命令即可完成安装： npm install hexo-cli -g npm install hexo -g 安装git插件 npm install hexo-deployer-git --save 有了git插件，我们就可以直接部署项目到github仓库 hexo基本操作初始化hexo： hexo init hexo 该命令表示：在当前目录下初始化一个名叫hexo的项目 生成文件： hexo g 进入到项目根目录执行此命令后将生成taget文件，用于项目部署 在本地服务器登录： hexo s 本地部署 发布项目到github: hexo d 当然在安装成功之后还需要做一些配置，例如需要在hexo项目根目录中的_config.yml核心配置文件中添加github地址： deploy: type: git repo: github: git@github.com:chenende2019/chenende2019.github.io.git coding: git@git.dev.tencent.com:chenende/chenende.git branch: master 还可以下载hexo其他的一些主题等等","categories":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://www.chenende.top/categories/javaWeb/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://www.chenende.top/tags/javaWeb/"}]},{"title":"mysql","slug":"mysql","date":"2019-05-25T08:39:37.000Z","updated":"2019-05-25T15:30:56.606Z","comments":true,"path":"2019/05/25/mysql/","link":"","permalink":"https://www.chenende.top/2019/05/25/mysql/","excerpt":"前言今天来回顾一下MySql数据库的使用。 SQL分类 数据定义语言（DDL）：用来定义数据库对象，数据库、表、列等，关键字：create、alter、drop等 数据操作语言（DML）：用来对数据库中表的记录进行更新，关键字：insert、delete、update等 数据控制语言（DCL）：用来定义数据库的访问权限和安全级别及创建用户。 数据查询语言（DQL）：用来查询数据库中表的记录，关键字：select、from、where等。 SQL通用语法 SQL语句可以单行或多行书写，以分号结束 可使用空格和缩进来增强语句的可读性 MySql数据库的SQL语句不区分大小写，关键字建议使用大写。例如：SELECT * FROM user 同样可以使用/**/的方式完成注释 MySql中常用的数据类型如下： int 整形 double 浮点型 varchar 可变字符 date 日期类型，只有年月日没有时分秒","text":"前言今天来回顾一下MySql数据库的使用。 SQL分类 数据定义语言（DDL）：用来定义数据库对象，数据库、表、列等，关键字：create、alter、drop等 数据操作语言（DML）：用来对数据库中表的记录进行更新，关键字：insert、delete、update等 数据控制语言（DCL）：用来定义数据库的访问权限和安全级别及创建用户。 数据查询语言（DQL）：用来查询数据库中表的记录，关键字：select、from、where等。 SQL通用语法 SQL语句可以单行或多行书写，以分号结束 可使用空格和缩进来增强语句的可读性 MySql数据库的SQL语句不区分大小写，关键字建议使用大写。例如：SELECT * FROM user 同样可以使用/**/的方式完成注释 MySql中常用的数据类型如下： int 整形 double 浮点型 varchar 可变字符 date 日期类型，只有年月日没有时分秒 一、DDL数据定义语言1数据库操作相关 1.1.创建数据库create database 数据库名； create database 数据库名 character set 字符集; 1.2.查询所有数据库show databases; 1.3.查看某个数据库的定义信息show create database 数据库名称; 1.4.删除数据库表drop database 数据库名称; 1.5.使用数据库use 数据库名 2表操作相关 2.1.创建数据库表create table 表名( 列名1 数据类型 约束， 列名2 数据类型 约束， 列名3 数据类型 约束， ... ) 主键约束：primary key;用于标识当前记录的字段，它的特点是非空且唯一。结合`AUTO_INCREMENT`可实现自增长。 非空约束: not null;添加该约束的列内容不能为空 唯一约束:unique;添加该约束的列内容不能重复 外键约束：constraint fk_sno foreign key (子表中的外键字段) references &lt;databasename&gt;.父表名 (父表中的字段)，其中fk_sno是自定义的索引名称。 1.MySQL外键必须使用存储引擎为 innDB 其中MySAM 和MEMORYH这两种引擎不支持 2.由数据库自身保证数据一致性，完整性，更可靠，因为程序很难100％保证数据的完整性，而用外键即使在数据库服务器当机或者出现其他问题的时候，也能够最大限度的保证数据的一致性和完整性。 3.设置外键约束的两个表之间会具有父子关系，即子表中外键的字段的取值范围由父表所决定 4.设置外键一定程度上降低数据库的速度 5.子表的外键字段的数据类型和父表中要一致 更多内容可以参考浅谈 MySQL的外键的作用 2.2.查看所有表show tables; 2.3.查看指定数据库表的结果desc 表名; 2.4.删除表drop table 名表; 2.5.修改表结构2.5.1.添加列： alter table 表名 add 列名 类型（长度） 约束; 2.5.2.修改列的类型长度及约束： alter table 表名 modify 列名 类型(长度) 约束; 2.5.3.修改列名： alter table 表名 change 旧列名 新列名 类型（长度） 约束; 2.5.4.删除列： alter table 表名 drop 列名; 2.5.5.修改表名： rename talbe 表名 to 新表名; 2.5.6.修改表的字符集: alter table 表名 character set 字符集; 二、DML数据操作语言1.向表中添加数据insert into 表名（列名1,列名2,列名3...） values(值1,值2,值3...); 2.更新数据update 表名 set 列1=值1,列2=值2... where 条件; 3.删除数据delete from 表名 where 条件; 4.清空表中所有数据truncate table 表名; delete：一条一条删除，不清空AUTO_INCREMENT记录数;truncate 直接将表删除，重新建表，AUTO_INCREMENT将置为零，从新开始。 三、DQL数据查询语言1.表查询语句1.1.查询指定列： select 列名 from 表名 where 条件; 1.2.查询所有： select * from 表名; 1.3.去掉重复记录(distinct关键字)： select distinct 列名 from 表名 where 条件; 1.4.将查询的列重新命名(as 关键字)： select 列名 as &apos;新名称&apos; from 表名; 1.5.在查询中进行数学运算： select monery+1000 as &apos;求和&apos; from 表名; 2.条件查询：where条件的种类如下：比较运算符： 大于：&gt; 小于：&lt; 小于等于：&lt;= 大于等于：&gt;= 等于：= 不等于：&lt;&gt; 显示在某一区间的值（含头不含尾）：BETWEEN...AND... 显示在in列表中的值：IN（set） 模糊查询：LIKE 通配符； %用来匹配多个字符：例 name like &apos;a%&apos;; _用来匹配一个字符：例 name like &apos;a_&apos;; 判断是否为空：IS NULL、IS NOT NULL； 逻辑运算符： 多个条件同时成立：and 多个条件任一成立：or 不成立：NOT 3.对查询结果进行排序，关键字order by升序： select * from 表名 order by 列名; 降序： select * from 表名 order by 列名 desc; 4.聚合函数：count:统计指定列不为NULL的记录行数; sum:计算指定列的数值和; max:获取统计列的最大值； min：获取统计列的最小值； avg:计算指定列的平均值 5.分组查询 group by 被分组的列名：需要满足两个条件： 1.必须跟随聚合函数 2.select 查询的时候，被分组的列要出现在select选择列的后面 例： select sum(money),name from 表名 group by name; 需要注意的是如果有where条件的话，group by应该放在where条件后面 6.分组后过滤使用HAING关键字例：select sum(money) as &apos;sum&apos;,name from 表名 group by name having sum&gt;5000; 分组操作中的having子名用于分组后对数据进行过滤，作用类似于where子句。 having和where的区别：having是在分组后对数据进行过滤;having后面可以使用聚合函数；where是在分组前对数据进行过滤;where后面不可以使用聚合函数；","categories":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://www.chenende.top/categories/javaWeb/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://www.chenende.top/tags/javaWeb/"}]},{"title":"java String","slug":"java-String","date":"2019-05-24T12:03:57.000Z","updated":"2019-05-24T12:26:09.943Z","comments":true,"path":"2019/05/24/java-String/","link":"","permalink":"https://www.chenende.top/2019/05/24/java-String/","excerpt":"前言今天我们来回顾一下String常用的API及StringBuffer常用的方法。首先String的底层实现是数组，创建的实例对象是不可变的，如果要对String实例进行频繁操作的情况下应该使用StringBuffer,如果是在多线程中使用的话则应该使用StringBuilder,两者的API相同，区别在于StringBuilder是线程安全的，但执行效率要比StringBuffe低，因为多了获取锁和释放锁的操作。","text":"前言今天我们来回顾一下String常用的API及StringBuffer常用的方法。首先String的底层实现是数组，创建的实例对象是不可变的，如果要对String实例进行频繁操作的情况下应该使用StringBuffer,如果是在多线程中使用的话则应该使用StringBuilder,两者的API相同，区别在于StringBuilder是线程安全的，但执行效率要比StringBuffe低，因为多了获取锁和释放锁的操作。 String常用方法1 char charAt(int index) 返回指定索引处的 char 值。 2 int compareTo(Object o) 把这个字符串和另一个对象比较。 3 int compareTo(String anotherString) 按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str) 将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb) 当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject) 将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 15 int hashCode() 返回此字符串的哈希码。 16 int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length() 返回此字符串的长度。 26 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement ) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray() 将此字符串转换为一个新的字符数组。 40 String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x) 返回给定data type类型x参数的字符串表示形式。 字符串格式化1.对整数进行格式化：%[index$][标识][最小宽度]转换方式 格式化字符串由4部分组成，特殊的格式常以%index$开头，index从1开始取值，表示将第index个参数拿进来进行格式化，[最小宽度]的含义也很好理解，就是最终该整数转化的字符串最少包含多少位数字。剩下2个部分的含义： 标识： &apos;-&apos; 在最小宽度内左对齐，不可以与&quot;用0填充&quot;同时使用 &apos;#&apos; 只适用于8进制和16进制，8进制时在结果前面增加一个0，16进制时在结果前面增加0x &apos;+&apos; 结果总是包括一个符号(一般情况下只适用于10进制，若对象为BigInteger才可以用于8进制和16进制) &apos; &apos; 正值前加空格，负值前加负号(一般情况下只适用于10进制，若对象为BigInteger才可以用于8进制和16进制) &apos;0&apos; 结果将用零来填充 &apos;,&apos; 只适用于10进制，每3位数字之间用&quot;，&quot;分隔 &apos;(&apos; 若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(同&apos;+&apos;具有同样的限制) 转换方式： d-十进制 o-八进制 x或X-十六进制 上面的说明过于枯燥，我们来看几个具体的例子。需要特别注意的一点是：大部分标识字符可以同时使用。 System.out.println(String.format(&quot;%1$,09d&quot;, -3123)); System.out.println(String.format(&quot;%1$9d&quot;, -31)); System.out.println(String.format(&quot;%1$-9d&quot;, -31)); System.out.println(String.format(&quot;%1$(9d&quot;, -31)); System.out.println(String.format(&quot;%1$#9x&quot;, 5689)); //结果为： //-0003,123 // -31 //-31 // (31) // 0x1639 2.对浮点数进行格式化：%[index$][标识][最少宽度][.精度]转换方式 我们可以看到，浮点数的转换多了一个”精度”选项，可以控制小数点后面的位数。 标识： &apos;-&apos; 在最小宽度内左对齐，不可以与&quot;用0填充&quot;同时使用 &apos;+&apos; 结果总是包括一个符号 &apos; &apos; 正值前加空格，负值前加负号 &apos;0&apos; 结果将用零来填充 &apos;,&apos; 每3位数字之间用&quot;，&quot;分隔(只适用于fgG的转换) &apos;(&apos; 若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(只适用于eEfgG的转换) 转换方式： &apos;e&apos;, &apos;E&apos; -- 结果被格式化为用计算机科学记数法表示的十进制数 &apos;f&apos; -- 结果被格式化为十进制普通表示方式 &apos;g&apos;, &apos;G&apos; -- 根据具体情况，自动选择用普通表示方式还是科学计数法方式 &apos;a&apos;, &apos;A&apos; -- 结果被格式化为带有效位数和指数的十六进制浮点数 3.对字符进行格式化： 对字符进行格式化是非常简单的，c表示字符，标识中’-‘表示左对齐，其他就没什么了。 StringBuffer常用方法/** * 添加 * @param source * @param content * @return */ public static String addString(String source,String content){ StringBuffer stringBuffer = new StringBuffer(source); stringBuffer.append(content); return stringBuffer.toString(); } /** * 替换 * @param source * @return */ public static String replaceString(String source,int index,char replaceContent){ StringBuffer stringBuffer = new StringBuffer(source); new StringBuilder() stringBuffer.setCharAt(index,replaceContent); return stringBuffer.toString(); } /** * 插入 * @param source * @param index * @param insertContent * @return */ public static String insertString(String source,int index,char[] insertContent){ StringBuffer stringBuffer = new StringBuffer(source); return stringBuffer.insert(index, insertContent).toString(); } /** * 删除 * @param source * @param startIndex * @param endIndex * @return */ public static String delString(String source,int startIndex,int endIndex){ StringBuffer stringBuffer = new StringBuffer(source); return stringBuffer.delete(startIndex,endIndex).toString(); } append(boolean b)：将 boolean 参数的字符串表示形式追加到序列。 append(char c)：将 char 参数的字符串表示形式追加到此序列。 append(char[] str)：将 char 数组参数的字符串表示形式追加到此序列。 append(char[] str，int offset，int len)：将 char 数组参数的子数组的字符串表示形式追加到此序列。 append(CharSequence s)：向此 Appendable 追加到指定的字符序列。 append(CharSequence s，int start，int end)：将指定 CharSequence 的子序列追加到此序列。 append(double d)：将 double 参数的字符串表示形式追加到此序列。 append(float f)：将 float 参数的字符串表示形式追加到此序列。 append(int i)：将 int 参数的字符串表示形式追加到此序列。 append(long lng)：将 long 参数的字符串表示形式追加到此序列。 append(Object obj)：追加 Object 参数的字符串表示形式。 append(String str)：将指定的字符串追加到此字符序列。 append(StringBuffer sb)：将指定的 StringBuffer 追加到此序列。 appendCodePoint(int codePoint)：将 codePoint 参数的字符串表示形式追加到此序列。 capacity()：返回当前容量。 charAt(int index)：返回此序列中指定索引处的 char 值。 codePointAt(int index)：返回指定索引处的字符（统一代码点）。 codePointBefore(int index)：返回指定索引前的字符（统一代码点）。 codePointCount(int beginIndex，int endIndex)：返回此序列指定文本范围内的统一代码点。 delete(int start，int end)：移除此序列的子字符串中的字符。 deleteCharAt(int index)：移除此序列指定位置上的 char。 ensureCapacity(int minimumCapacity)：确保容量至少等于指定的最小值。 getChars(int srcBegin，int srcEnd，char[] dst，int dstBegin)：将字符从此序列复制到目标字符数组 dst。 indexOf(String str)：返回第一次出现的指定子字符串在该字符串中的索引。 indexOf(String str，int fromIndex)：从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 insert(int offset，boolean b)：将 boolean 参数的字符串表示形式插入此序列中。 insert(int offset，char c)：将 char 参数的字符串表示形式插入此序列中。 insert(int offset，char[] str)：将 char 数组参数的字符串表示形式插入此序列中。 insert(int index，char[] str，int offset，int len)：将数组参数 str 子数组的字符串表示形式插入此序列中。 insert(int dstOffset，CharSequence s)：将指定 CharSequence 插入此序列中。 insert(int dstOffset，CharSequence s，int start，int end)：将指定 CharSequence 的子序列插入此序列中。 insert(int offset，double d)：将 double 参数的字符串表示形式插入此序列中。 insert(int offset，float f)：将 float 参数的字符串表示形式插入此序列中。 insert(int offset，int i)：将 int 参数的字符串表示形式插入此序列中。 insert(int offset，long l)：将 long 参数的字符串表示形式插入此序列中。 insert(int offset，Object obj)：将 Object 参数的字符串表示形式插入此字符序列中。 insert(int offset，String str)：将字符串插入此字符序列中。 lastIndexOf(String str)：返回最右边出现的指定子字符串在此字符串中的索引。 lastIndexOf(String str，int fromIndex)：返回最后一次出现的指定子字符串在此字符串中的索引。 length()：返回长度（字符数）。 offsetByCodePoints(int index，int codePointOffset)：返回此序列中的一个索引，该索引是从给定 index 偏移 codePointOffset 个代码点后得到的。 replace(int start，int end，String str)：使用给定 String 中的字符替换此序列的子字符串中的字符。 reverse()：将此字符序列用其反转形式取代。 setCharAt(int index，char ch)：将给定索引处的字符设置为 ch。 setLength(int newLength)：设置字符序列的长度。 subSequence(int start，int end)：返回一个新字符序列，该字符序列是此序列的子序列。 substring(int start)：返回一个新的 String，它包含此字符序列当前所包含字符的子序列。 substring(int start，int end)：返回一个新的 String，它包含此序列当前所包含字符的子序列。 toString()：返回此序列中数据的字符串表示形式。 trimToSize()：尝试减少用于字符序列的存储空间。 StringBuilder同StringBuffer中的方法相同此处不再赘述。需要注意的是方法中凡有开头索引和结束索引的，都不包括结束索引处的值。","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"java 持久化配置工具类","slug":"java-properties","date":"2019-05-23T15:00:40.000Z","updated":"2019-05-23T18:09:41.850Z","comments":true,"path":"2019/05/23/java-properties/","link":"","permalink":"https://www.chenende.top/2019/05/23/java-properties/","excerpt":"前言在日常开发中，对于前端页面经常变动的内容（例如下拉框选项内容），我们可以在后台将其剥离出来，单独存储在一个文本文件中，这样的好处在于不用频繁改动代码，尤其中在发布部署比较麻烦的情况下，这样做的好处是显而易见的，不用担心改错代码，也直接省去了代码开发工作。","text":"前言在日常开发中，对于前端页面经常变动的内容（例如下拉框选项内容），我们可以在后台将其剥离出来，单独存储在一个文本文件中，这样的好处在于不用频繁改动代码，尤其中在发布部署比较麻烦的情况下，这样做的好处是显而易见的，不用担心改错代码，也直接省去了代码开发工作。 持久化配置工具类import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.util.ResourceUtils; import org.springframework.util.StringUtils; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.util.Iterator; import java.util.Map; import java.util.Properties; /** * 持久化配置工具类，可用于配置前端页面下拉选项的设置，将选项内容以key-vlue的形式单独存储在指定路径的文本文件中 * author: chenende * date: 2019.2.23 */ public class PersistConfigUtil { private final static Logger logger = LoggerFactory.getLogger(PersistConfigUtil.class); //指定文件的保存位置 private final static String filePath = &quot;demo-web/src/main/resources/&quot;; /** * 添加选项 * @param json 数据格式 * @param fileName 指定文件名称 * @param desc 操作描述 * @param isAppend 是否在原文件中追加内容 */ public static void addOption(String json, String fileName, String desc, boolean isAppend) { checkPath(fileName); if (StringUtils.isEmpty(json)) { return; } Map&lt;String, String&gt; option = (Map) JSON.parse(json); Properties properties = new Properties(); Iterator iterator = option.keySet().iterator(); while (iterator.hasNext()) { String key = (String) iterator.next(); if (isAppend) { Properties options = (Properties) getOptions(false, fileName); if (!StringUtils.isEmpty(options.get(key))) { logger.error(&quot;选项已存在不能添加&quot;); throw new RuntimeException(&quot;选项已存在不能添加&quot;); } } String o = option.get(key); properties.setProperty(key, o); } try { BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(getPath(fileName), isAppend)); properties.store(bufferedWriter, desc); } catch (Exception e) { e.printStackTrace(); } } /** * 添加选项 * @param properties 数据格式为map * @param fileName 指定文件名称 * @param desc 操作描述 * @param isAppend 是否在原文件中追加内容 */ public static void addOption(Properties properties, String fileName, String desc, boolean isAppend) { String json = JSONObject.toJSON(properties).toString(); addOption(json, fileName, desc, isAppend); } /** * 获取全部选项 * @param isToJson 是否转换结果为json格式 * @param fileName 指定文件名称 * @return */ public static Object getOptions(boolean isToJson, String fileName) { checkPath(fileName); Properties properties = new Properties(); try { BufferedReader bufferedReader = new BufferedReader(new FileReader(getPath(fileName))); properties.load(bufferedReader); bufferedReader.close(); if (isToJson) { Object json = JSONObject.toJSON(properties); return json; } return properties; } catch (Exception e) { e.printStackTrace(); } return null; } /** * 删除选项 * @param key 根据key删除option * @param fileName 指定文件名称 * @param desc 操作描述 */ public static void removeOption(String key, String fileName, String desc) { if (StringUtils.isEmpty(key)) { return; } Properties options = (Properties) getOptions(false, fileName); if (!StringUtils.isEmpty(options.getProperty(key))) { options.remove(key); addOption(options, fileName, desc, false); } } /** * 修改选项内容 * @param json 数据格式 * @param fileName 指定文件名称 * @param desc 操作描述 */ public static void editOption(String json, String fileName, String desc) { Properties options = (Properties) getOptions(false, fileName); Map&lt;String, String&gt; maps = (Map) JSON.parse(json); Iterator&lt;String&gt; iterator = maps.keySet().iterator(); while (iterator.hasNext()) { String key = iterator.next(); String value = maps.get(key); if (StringUtils.isEmpty(options.get(key))) { logger.error(&quot;修改的内容不存在&quot;); throw new RuntimeException(&quot;修改的内容不存在&quot;); } options.setProperty(key, value); } addOption(options, fileName, desc, false); } /** * 获取文件路径 * @param existFileName 已存在的文件名称 * @return */ public static String getPath(String existFileName) { try { if (StringUtils.isEmpty(existFileName)) { return ResourceUtils.getURL(filePath).getPath(); } return ResourceUtils.getURL(filePath).getPath() + existFileName; } catch (Exception e) { e.printStackTrace(); } return null; } public static void checkPath(String filename) { if (StringUtils.isEmpty(filename)) { logger.error(&quot;文件路径不能为空&quot;); throw new RuntimeException(&quot;文件路径不能为空&quot;); } } } Properties是HashTable的子类，是Map的实现类，且是线程安全的。它是一个特殊的map,提供了两个特殊的方法，load(Reader reader)/load(InputStream inStream)可以从字符、字节流中读取数据;store(Writer writer, String comments)/store(OutputStream out, String comments)将map中数据以字符、字节流的形式写入到文件中。","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"java 字节流和字符流的读写","slug":"java-IO","date":"2019-05-23T08:54:24.000Z","updated":"2019-05-24T08:11:48.105Z","comments":true,"path":"2019/05/23/java-IO/","link":"","permalink":"https://www.chenende.top/2019/05/23/java-IO/","excerpt":"前言java里的IO操作分为字符流和字节流，字符流主要针对文本操作;字节流是万能的可对所有类型的文件进行读写操作;如果仅是读写文本使用字符流就可以了，如果是图片、音乐及其它二进制的读写则要使用字节流； 一、字符流字符流的读写分为输入流（Reader）和输出流(Writer)，按性能区分分为：基本字符流和字符缓冲流，其中以字符缓冲流性能最佳。 1.字符输出流代码中使用的是抽象类Writer的子类FileWriter FileWriter fileWriter = new FileWriter(&quot;/home/chenende/a.txt&quot;); fileWriter.write(&quot;今天是2019年05月23日&quot;); //刷新流 fileWriter.flush(); //关闭流 fileWriter.close();","text":"前言java里的IO操作分为字符流和字节流，字符流主要针对文本操作;字节流是万能的可对所有类型的文件进行读写操作;如果仅是读写文本使用字符流就可以了，如果是图片、音乐及其它二进制的读写则要使用字节流； 一、字符流字符流的读写分为输入流（Reader）和输出流(Writer)，按性能区分分为：基本字符流和字符缓冲流，其中以字符缓冲流性能最佳。 1.字符输出流代码中使用的是抽象类Writer的子类FileWriter FileWriter fileWriter = new FileWriter(&quot;/home/chenende/a.txt&quot;); fileWriter.write(&quot;今天是2019年05月23日&quot;); //刷新流 fileWriter.flush(); //关闭流 fileWriter.close(); 需要注意的是字符输出流中有个刷新流的操作，这个是必不可少的，否则数据无法写入到目标文件，另外最后必须要有关闭流的操作。只有字符输出流需要刷新，其它不需要。 1.1.字符输出缓冲流缓冲流BufferedWriter也是Writer的子类 BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(&quot;/home/chenende/a.txt&quot;)); bufferedWriter.write(&quot;浙江省杭州市西湖区&quot;); bufferedWriter.flush(); bufferedWriter.close(); 2.字符输入流代码中使用的是抽象类Reader的子类FileReader FileReader fileReader = new FileReader(&quot;/home/chenende/a.txt&quot;); char[] c = new char[1024]; int len; while((len = fileReader.read(c)) != -1){ System.out.println(new String(c,0,len)); } fileReader.close(); 2.1.字符输入缓冲流缓冲流BufferedReader也是Reader的子类 BufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;/home/chenende/a.txt&quot;)); String line; while((line=bufferedReader.readLine())!=null){ System.out.println(line); } bufferedReader.close(); bufferedReader.readLine()是缓冲流中独有的方法，一次读取一行数据 3.复制文件内容使用字符缓冲流来复制文件内容，即边读边写，将字符输入流和输出流结合起来运用： public class IoDemo { public static void main(String[] args) { BufferedWriter bufferedWriter = null; BufferedReader bufferedReader = null; try { bufferedWriter = new BufferedWriter(new FileWriter(&quot;/home/chenende/copy.txt&quot;,true)); bufferedReader = new BufferedReader(new FileReader(&quot;/home/chenende/a.txt&quot;)); String line; while((line = bufferedReader.readLine()) != null){ bufferedWriter.write(line); bufferedWriter.newLine(); bufferedWriter.flush(); } } catch (IOException e) { e.printStackTrace(); }finally { try { bufferedWriter.close(); bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } } 需要注意的是在按行写入的时候必须使用bufferedWriter.newLine();进行换行，否则所有内容将写在同一行上。 二、字节流同字符流一样，使用上分为输入流（InputStream）和输出流(OutputStream);按性能区分分为：基本字节流和字节缓冲流(); 1.字节输出流FileOutputStream fileOutputStream = new FileOutputStream(&quot;/home/chenende/a.txt&quot;); fileOutputStream.write(&quot;今天的天气看起来不错！&quot;.getBytes()); fileOutputStream.close(); 1.1.字节输出缓冲流BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(&quot;/home/chenende/a.txt&quot;, true)); outputStream.write(&quot;天黑黑&quot;.getBytes()); outputStream.close(); 2.字节输入流FileInputStream fileInputStream = new FileInputStream(&quot;/home/chenende/a.txt&quot;); byte[] b = new byte[1024]; int len; while((len = fileInputStream.read(b))!= -1){ System.out.println(new String(b,0,len)); } fileInputStream.close(); 2.1.字节输入缓冲流try { BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(&quot;a.properties&quot;)); byte[] b = new byte[1024]; int len; while ((len = inputStream.read(b)) != -1) { System.out.println(new String(b, 0, len)); } inputStream.close(); } catch (Exception e) { e.printStackTrace(); } 3.复制文本内容public class IoDemo { public static void main(String[] args) { BufferedInputStream inputStream = null; BufferedOutputStream outputStream = null; try { inputStream = new BufferedInputStream(new FileInputStream(&quot;/home/chenende/copy.txt&quot;)); outputStream = new BufferedOutputStream(new FileOutputStream(&quot;/home/chenende/a.txt&quot;, true)); byte[] b = new byte[1024]; int len; while((len=inputStream.read(b))!=-1){ outputStream.write(b,0,len); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { outputStream.close(); inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } 三、转换流转换流和要应用在需要对编码进行操作的场景下，例如当前系统默认编码是GBK要读取utf8的文件，就需要指定编码，而基本字符流和字符缓冲流是没有提供编码操作功能的，它默认以系统编码为主，在这种情况下就要使用转换流，将字符转换成字节读取或写入。 1.字符转字节在写入文本的时候会将字符转换成字节写入到目标文件 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(&quot;/home/chenende/a.txt&quot;),&quot;UTF-8&quot;); outputStreamWriter.write(&quot;今天是5月23日星期四，天气晴&quot;); outputStreamWriter.close(); 2.字节转字符在读取文本的时候会将字节流转换成字符流写入到内存 InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;/home/chenende/a.txt&quot;),&quot;UTF-8&quot;); char[] c = new char[1024]; int len; while((len = inputStreamReader.read(c))!=-1){ System.out.println(new String(c,0,len)); } inputStreamReader.close(); 在不设置编码的情况下使用的是当前系统默认编码，如果无需设置编码也就没有必要使用转换流了。 四、打印流打印流用来向文件输出内容，简化了字符/字节输出流的操作，分为字符打印流（PrintWriter）和字节打印流（PrintStream）,它们除了构造方法不同，类中的方法中一样的。 1.字符打印流PrintWriter的构造方法入参可以是字符串（文件名+所在路径），也可以是File对象，OutputStream字节输出流，Writer字符输出流 File file = new File(&quot;/home/chenende/a.txt&quot;); PrintWriter printWriter = new PrintWriter(file); printWriter.println(1000); printWriter.close(); 2.字节打印流PrintStream的构造方法入参可以是字符串（文件名+所在路径），也可以是File对象，OutputStream字节输出流 PrintStream printStream = new PrintStream(&quot;a.txt&quot;); printStream.println(&quot;123456&quot;); printStream.close(); 打印流的底层实际上还是用了缓冲流，以下是字符打印流的源码：public PrintWriter(String fileName) throws FileNotFoundException { this(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName))), false); } 3.println和writer的区别 println将内容原样输出的文件中，writer会将内容按编码表进行转换后输出的文件中： PrintStream printStream = new PrintStream(&quot;a.txt&quot;); printStream.println(&quot;100&quot;); printStream.write(100); printStream.close(); 打印结果： 100 d PrintWriter printWriter = new PrintWriter(&quot;a.txt&quot;); printWriter.println(100); printWriter.write(100); printWriter.close(); 打印结果： 100 d println会自动换行，writer不能换行 使用这两个方法在写入文件时都无需手动调用flush进行刷新操作，但必须关闭流 在不关闭流的情况下开启和启用自刷新功能，需要使用特定的构造方法，入参必须是流对象： public PrintWriter(Writer out,boolean autoFlush) public PrintWriter(OutputStream out, boolean autoFlush) 且需要调用println、printf、format方法启用自刷新功能： public void println() { newLine(); } private void newLine() { try { synchronized (lock) { ensureOpen(); out.write(lineSeparator); if (autoFlush) out.flush(); } } catch (InterruptedIOException x) { Thread.currentThread().interrupt(); } catch (IOException x) { trouble = true; } } 总结： 在读写文件的时候使用「缓冲流」提高性能，其中输出流应使用打印流来提高开发效率（其底层也用了「缓冲流」， 如果需要转换编码则需要使用「转换流」","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"java 反射","slug":"java-reflex","date":"2019-05-22T02:01:52.000Z","updated":"2019-05-22T09:55:41.166Z","comments":true,"path":"2019/05/22/java-reflex/","link":"","permalink":"https://www.chenende.top/2019/05/22/java-reflex/","excerpt":"前言java 反射是在不使用new关键字创建对象的情况下通过class文件对象获取类中的成员变量或方法。 获取class对象的三种方式 1.getClass 首先需要创建对象： Student stu =new Student(); 然后通过getClass方法获取class对象 Class class = stu.getClass(); 2.通过类名.class Class cla = Student.class;","text":"前言java 反射是在不使用new关键字创建对象的情况下通过class文件对象获取类中的成员变量或方法。 获取class对象的三种方式 1.getClass 首先需要创建对象： Student stu =new Student(); 然后通过getClass方法获取class对象 Class class = stu.getClass(); 2.通过类名.class Class cla = Student.class; 3.通过Class类的静态方法forName Class cla = Class.forName(String str); 入参是类的全路径名，注意是字符串类型，且需要抛ClassNotFoundException的异常 以上三种方式中第一种不建议使用，因为使用反射就是为了避免创建实例对象，有了对象实例也就没必要再使用反射了。相比之下第三种更为灵活，可结合配置文件隐藏具体的类名，可扩展性更好一些。 利用反射获取构造方法，实例化对象类中可能有多个构造方法，总体分为有参构造和无参构造 1.获取无参构造 Class obj = Class.forName(&quot;User&quot;); Constructor constructor = obj.getConstructor(); Object o = constructor.newInstance(); 2.获取有参构造 Class obj = Class.forName(&quot;User&quot;); Constructor constructor = obj.getConstructor(String.class); Object o = constructor.newInstance(&quot;abc&quot;); getConstructor(Class&lt;?&gt;… parameterTypes) 入参是可变参，对应构造方法中的参数类型的class对象，顺序必须保持一致newInstance(Object … initargs) 入参也是可变参，有参构造中入参的具休值 3.获取所有public构造方法 Class obj = Class.forName(&quot;User&quot;); Constructor[] constructors = obj.getConstructors(); for(Constructor c: constructors){ System.out.println(c); } 打印结果： public User(java.lang.String) public User() 4.暴力反射私有构造方法 Class obj = Class.forName(&quot;User&quot;); Constructor declaredConstructor = obj.getDeclaredConstructor(String.class); declaredConstructor.setAccessible(true); Object o = declaredConstructor.newInstance(&quot;test&quot;); System.out.println(o); 打印结果： User{name=&apos;test&apos;, age=&apos;null&apos;, address=&apos;null&apos;} 反射获取类中的方法 1.首先是不带参数的方法 Class obj = Class.forName(&quot;User&quot;); Object o = obj.newInstance(); Method eat = obj.getMethod(&quot;get&quot;); Object abc = eat.invoke(o); 2.带参数的方法 Class obj = Class.forName(&quot;User&quot;); Object o = obj.newInstance(); Method eat = obj.getMethod(&quot;eat&quot;, String.class); Object abc = eat.invoke(o,&quot;abc&quot;); getMethod(String name, Class&lt;?&gt;… parameterTypes) 其中第一个参数name是要方法名，第二个参数是可变参指的是入参类型的class对象。invoke(Object obj, Object… args) 第一个参数是实例化的对象，第二个参数是可变参，对应getMethod中定义的入参，类型必须一致 反射获取类中的成员变量 1.获取公有成员变量 Class obj = Class.forName(&quot;User&quot;); Object o = obj.newInstance(); Field name = obj.getField(&quot;address&quot;); name.set(o,&quot;浙江省杭州市&quot;); System.out.println(o); 打印结果： User{name=&apos;null&apos;, age=&apos;null&apos;, address=&apos;浙江省杭州市&apos;} 2.获取私有成员变量并赋值 Class obj = Class.forName(&quot;User&quot;); Object o = obj.newInstance(); Field name = obj.getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(o,&quot;tom&quot;); System.out.println(o); 打印结果： User{name=&apos;tom&apos;, age=&apos;null&apos;} 仔细观察可以发现两者的区别在于，使用的方法不同，获取私有成员变量的方法getDeclaredField,通称暴力反射另外需要使用setAccessible方法进行授权，使用成员变量变得可用。","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"springboot中CXF的使用","slug":"javaWeb-cxf","date":"2019-05-09T19:31:03.000Z","updated":"2019-05-09T20:47:53.271Z","comments":true,"path":"2019/05/10/javaWeb-cxf/","link":"","permalink":"https://www.chenende.top/2019/05/10/javaWeb-cxf/","excerpt":"前言CXF是apache提供的用于发布和构建webService服务的开源框架，在学习CXF之前我们先来了解一下webService。 webService 什么是webService?webService就是两个系统之间的远程调用技术，基于SOAP协议（使用http协议，传输和接收的数据格式为xMl）实现跨语言调用。其内部实际上是使用的scoket实现。 ——socket：一种传输层的协议，常用tcp,udp。Socket是操作系统提供的一套网络接口，不同的编程语言都可以实现，Socket是跨平台的，传输数据时需要程序员自己解析数据流。优点：传输速度很快，所以适用于考虑传输速度的场景。 ——soap(简单对象访问协议)：基于http的应用层协议，基于socket传输数据。所以soap也是跨平台的。soap是在http的基础上，一个基于xml的协议。soap=http+xml。因为webservice在传输数据的时候，先依据XSD(WebService数据类型标准)将java对象序列化成soap协议，在服务端，再把soap协议反序列化成java对象，正因为如此，他的传输速度不快。优点：实现面向对象开发，soap是一个标准协议，方便跨平台，跨公司接口开发，适用于不用考虑传输速度的传输。 更多可参考webservice和socket服务的区别 发布服务第一步：创建一个Java项目第二步：创建一个类，加入Webservice注解第三步：提供一个方法sayHello第四步：在main方法中调用jdk提供的发布服务的方法Endpoint.publish第五步：访问服务的wsdl文档（服务的发布地址+?wsdl）http://192.168.115.87:8080/hello?wsdl","text":"前言CXF是apache提供的用于发布和构建webService服务的开源框架，在学习CXF之前我们先来了解一下webService。 webService 什么是webService?webService就是两个系统之间的远程调用技术，基于SOAP协议（使用http协议，传输和接收的数据格式为xMl）实现跨语言调用。其内部实际上是使用的scoket实现。 ——socket：一种传输层的协议，常用tcp,udp。Socket是操作系统提供的一套网络接口，不同的编程语言都可以实现，Socket是跨平台的，传输数据时需要程序员自己解析数据流。优点：传输速度很快，所以适用于考虑传输速度的场景。 ——soap(简单对象访问协议)：基于http的应用层协议，基于socket传输数据。所以soap也是跨平台的。soap是在http的基础上，一个基于xml的协议。soap=http+xml。因为webservice在传输数据的时候，先依据XSD(WebService数据类型标准)将java对象序列化成soap协议，在服务端，再把soap协议反序列化成java对象，正因为如此，他的传输速度不快。优点：实现面向对象开发，soap是一个标准协议，方便跨平台，跨公司接口开发，适用于不用考虑传输速度的传输。 更多可参考webservice和socket服务的区别 发布服务第一步：创建一个Java项目第二步：创建一个类，加入Webservice注解第三步：提供一个方法sayHello第四步：在main方法中调用jdk提供的发布服务的方法Endpoint.publish第五步：访问服务的wsdl文档（服务的发布地址+?wsdl）http://192.168.115.87:8080/hello?wsdl @WebService public class HelloService { public String sayHello(String name,int i){ System.out.println(&quot;服务端的sayHello方法被调用了。。。。&quot;); return &quot;helle&quot; + name; } public static void main(String[] args) { String address = &quot;http://192.168.115.87:8080/hello&quot;; Object implementor = new HelloService(); Endpoint.publish(address, implementor); } } 获取webService服务第一步：通过WSDL地址获取服务描述信息，WSDL（服务描述诺言）就是一个xml文档，用于描述当前服务的一些信息（服务名称、服务的发布地址、服务提供的方法、方法的参数类型、方法的返回值类型等）。WSDL地址为服务发布地址+？wsdl第二步：使用命令wsimport -s . wsdl地址解析wsdl文件生成本地代码。第三步：使用生成的本地代码创建代理对象，通过代码对象就可以实现对服务端的远程调用。 /** * 1、使用wsimport命令解析wsdl文件生成本地代码 * 2、通过本地代码创建一个代理对象 * 3、通过代理对象实现远程调用 * @author zhaoqx * */ public class App { public static void main(String[] args) { HelloServiceService ss = new HelloServiceService(); //创建客户端代理对象，用于远程调用 HelloService proxy = ss.getHelloServicePort(); String ret = proxy.sayHello(&quot;小明&quot;, 10); System.out.println(ret); } } Web service的特点 Web service 通过HTTP POST方式接受客户的请求. Web service 与客户端之间一般使用SOAP协议传输XML数据. 它本身就是为了跨平台或跨语言而设计的. CXFCXF是整合了webService的开源框架。上述webService的使用是jdk提供的无需导包，CXF用于WEB工程，maven工程需要在pom文件中添加依赖： &lt;properties&gt; &lt;cxf.version&gt;3.1.12&lt;/cxf.version&gt; &lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;${cxf.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;${cxf.version}&lt;/version&gt; &lt;/dependency&gt; 在springboot中使用CXF发布服务第一步：构建服务接口 package com.dbgo.webservicedemo.service; import com.dbgo.webservicedemo.Model.User; import javax.jws.WebMethod; import javax.jws.WebParam; import javax.jws.WebService; import java.util.ArrayList; @WebService public interface UserService { @WebMethod String getName(@WebParam(name = &quot;userId&quot;) String userId); @WebMethod User getUser(String userI); @WebMethod ArrayList&lt;User&gt; getAlLUser(); } 在springboot中所有的配置都采用注解的方式，@WebService表示这是一个对外提供服务的接口;@WebService表示对外提供的方法。 第二步：构建接口实现类 package com.dbgo.webservicedemo.service; @WebService(targetNamespace=&quot;http://service.webservicedemo.dbgo.com/&quot;,endpointInterface = &quot;com.dbgo.webservicedemo.service.UserService&quot;) public class UserServiceImpl implements UserService { private Map&lt;String, User&gt; userMap = new HashMap&lt;String, User&gt;(); public UserServiceImpl() { System.out.println(&quot;向实体类插入数据&quot;); User user = new User(); user.setUserId(&quot;411001&quot;); user.setUsername(&quot;zhansan&quot;); user.setAge(&quot;20&quot;); user.setUpdateTime(new Date()); userMap.put(user.getUserId(), user); user = new User(); user.setUserId(&quot;411002&quot;); user.setUsername(&quot;lisi&quot;); user.setAge(&quot;30&quot;); user.setUpdateTime(new Date()); userMap.put(user.getUserId(), user); user = new User(); user.setUserId(&quot;411003&quot;); user.setUsername(&quot;wangwu&quot;); user.setAge(&quot;40&quot;); user.setUpdateTime(new Date()); userMap.put(user.getUserId(), user); } @Override public String getName(String userId) { return &quot;liyd-&quot; + userId; } @Override public User getUser(String userId) { User user= userMap.get(userId); return user; } @Override public ArrayList&lt;User&gt; getAlLUser() { ArrayList&lt;User&gt; users=new ArrayList&lt;&gt;(); userMap.forEach((key,value)-&gt;{users.add(value);}); return users; } } 接口实现类名称前的注解targetNamespace是当前类实现接口所在包名称的反序（PS：加上反斜线）， endpointInterface是当发布的接口的全类名； 第三步：服务发布类编写 package com.dbgo.webservicedemo; import com.dbgo.webservicedemo.service.UserService; import com.dbgo.webservicedemo.service.UserServiceImpl; import org.apache.cxf.Bus; import org.apache.cxf.bus.spring.SpringBus; import org.apache.cxf.jaxws.EndpointImpl; import org.apache.cxf.transport.servlet.CXFServlet; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.xml.ws.Endpoint; @Configuration public class WebServiceConfig { @Bean public ServletRegistrationBean dispatcherServlet(){ return new ServletRegistrationBean(new CXFServlet(),&quot;/service/*&quot;);//发布服务名称 } @Bean(name = Bus.DEFAULT_BUS_ID) public SpringBus springBus() { return new SpringBus(); } @Bean public UserService userService() { return new UserServiceImpl(); } @Bean public Endpoint endpoint() { EndpointImpl endpoint=new EndpointImpl(springBus(), userService());//绑定要发布的服务 endpoint.publish(&quot;/user&quot;); //显示要发布的名称 return endpoint; } } 运行程序，输入 http://localhost:8080/service/user?wsdl 即可查询发布出去的接口文件； 如果需要发布多个webservice，需要配置多个Config实现类文件； 客户端调用服务 package com.dbgo.webservicedemo; import com.dbgo.webservicedemo.Model.User; import com.dbgo.webservicedemo.service.UserService; import org.apache.cxf.endpoint.Client; import org.apache.cxf.frontend.ClientProxy; import org.apache.cxf.jaxws.JaxWsProxyFactoryBean; import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory; import org.apache.cxf.transport.http.HTTPConduit; import org.apache.cxf.transports.http.configuration.HTTPClientPolicy; import java.util.ArrayList; public class webserviceclient { //动态调用 public static void main(String[] args) throws Exception { JaxWsDynamicClientFactory dcflient=JaxWsDynamicClientFactory.newInstance(); Client client=dcflient.createClient(&quot;http://localhost:8080/service/user?wsdl&quot;); Object[] objects=client.invoke(&quot;getUser&quot;,&quot;411001&quot;); System.out.println(&quot;*******&quot;+objects[0].toString()); Object[] objectall=client.invoke(&quot;getAlLUser&quot;); System.out.println(&quot;*******&quot;+objectall[0].toString()); main3(args); } //调用方式二，通过接口协议获取数据类型 public static void main2(String[] args) throws Exception { JaxWsProxyFactoryBean jaxWsProxyFactoryBean=new JaxWsProxyFactoryBean(); jaxWsProxyFactoryBean.setAddress(&quot;http://localhost:8080/service/user?wsdl&quot;); jaxWsProxyFactoryBean.setServiceClass(UserService.class); UserService userService=(UserService)jaxWsProxyFactoryBean.create(); User userResult= userService.getUser(&quot;411001&quot;); System.out.println(&quot;UserName:&quot;+userResult.getUsername()); ArrayList&lt;User&gt; users=userService.getAlLUser(); } //调用方式三，通过接口协议获取数据类型,设置链接超时和响应时间 public static void main3(String[] args) throws Exception { JaxWsProxyFactoryBean jaxWsProxyFactoryBean=new JaxWsProxyFactoryBean(); jaxWsProxyFactoryBean.setAddress(&quot;http://localhost:8080/service/user?wsdl&quot;); jaxWsProxyFactoryBean.setServiceClass(UserService.class); UserService userService = (UserService) jaxWsProxyFactoryBean.create(); // 创建客户端对象 Client proxy= ClientProxy.getClient(userService); HTTPConduit conduit=(HTTPConduit)proxy.getConduit(); HTTPClientPolicy policy=new HTTPClientPolicy(); policy.setConnectionTimeout(1000); policy.setReceiveTimeout(1000); conduit.setClient(policy); User userResult= userService.getUser(&quot;411001&quot;); System.out.println(&quot;UserName:&quot;+userResult.getUsername()); ArrayList&lt;User&gt; users=userService.getAlLUser(); } } 更多可参考Spring Boot+CXF搭建WebService 远程通信：Webservice、restful、dubbo的区别1、Webservice：效率不高基于soap协议，其主要的特点是跨语言、跨平台的。项目中不推荐使用，可用于不同公司间接口的调用。 2、使用restful形式的服务：http+json。很多项目中应用。如果服务太多，服务之间调用关系混乱，需要治疗服务。 3、使用dubbo。使用rpc协议进行远程调用，直接使用socket通信。传输效率高，并且可以统计出系统之间的调用关系、调用次数。使用Java语言开发，只能用于Java语言开发的项目间的通信，不具备跨语言，跨平台的特点！ 随着交互系统的增多，这种方式对系统的侵入性越来越大，关系更为错综复杂，很容易出错。较适用与外围系统通信，若是内部系统间则会出现以上较为混乱的局面。 内部系统间或遵守dubbo规范的系统间适用性较强。通过服务治理工具使得服务间的调用一目了然。 更多可参考dubbo和webservice 区别","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/tags/springboot/"}]},{"title":"Google Guava Collections工具类","slug":"Google-Guava-Collections","date":"2019-05-08T22:23:02.000Z","updated":"2019-05-09T20:58:56.364Z","comments":true,"path":"2019/05/09/Google-Guava-Collections/","link":"","permalink":"https://www.chenende.top/2019/05/09/Google-Guava-Collections/","excerpt":"前言Google Guava Collections是 Java Collections Framework 的增强和扩展。每个 Java 开发者都会在工作中使用各种数据结构，很多情况下 Java Collections Framework 可以帮助你完成这类工作。但是在有些场合你使用了 Java Collections Framework 的 API，但还是需要写很多代码来实现一些复杂逻辑，这个时候就可以尝试使用 Guava Collections 来帮助你完成这些工作。这些高质量的 API 使你的代码更短，更易于阅读和修改，工作更加轻松。简而言之，该工具类封装了常用的对集合的一些复杂操作，减少了开发人员的工作量，让我们更专注于功能的实现避免在繁琐且容易出错的细节上花费过多精力。 下载与使用这个开源项目发布的 jar 包可以在它的官方网站内（http://code.google.com/p/guava-libraries/downloads/list）找到。其下载的 zip 包中含有 Guava Collections 的 jar 包 guava-r09.jar 及其依赖包 guava-r09-gwt.jar，javadoc，源代码，readme 等文件。使用时只需将 guava-r09.jar 和依赖包 guava-r09-gwt.jar 放入 CLASSPATH 中即可。 如果您使用 Maven 作为构建工具的话可以在 pom.xml 内加入： &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;r09&lt;/version&gt; &lt;/dependency&gt;","text":"前言Google Guava Collections是 Java Collections Framework 的增强和扩展。每个 Java 开发者都会在工作中使用各种数据结构，很多情况下 Java Collections Framework 可以帮助你完成这类工作。但是在有些场合你使用了 Java Collections Framework 的 API，但还是需要写很多代码来实现一些复杂逻辑，这个时候就可以尝试使用 Guava Collections 来帮助你完成这些工作。这些高质量的 API 使你的代码更短，更易于阅读和修改，工作更加轻松。简而言之，该工具类封装了常用的对集合的一些复杂操作，减少了开发人员的工作量，让我们更专注于功能的实现避免在繁琐且容易出错的细节上花费过多精力。 下载与使用这个开源项目发布的 jar 包可以在它的官方网站内（http://code.google.com/p/guava-libraries/downloads/list）找到。其下载的 zip 包中含有 Guava Collections 的 jar 包 guava-r09.jar 及其依赖包 guava-r09-gwt.jar，javadoc，源代码，readme 等文件。使用时只需将 guava-r09.jar 和依赖包 guava-r09-gwt.jar 放入 CLASSPATH 中即可。 如果您使用 Maven 作为构建工具的话可以在 pom.xml 内加入： &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;r09&lt;/version&gt; &lt;/dependency&gt; 需要注意的是本文介绍的 Guava r09 需要 1.5 或者更高版本的 JDK,由于国内无法访问goole，要想下载jar包的话只能翻墙，可通过Maven工程下载jar包到本地仓库。 功能列举 ImmutableCollection:抽象类，实现了Collection, Serializable，用于创建不可修改的集合。 ——实现类有：ImmutableSet，ImmutableList，ImmutableMap，ImmutableSortedSet，ImmutableSortedMap。 Multiset接口:可存储重复数据的集合，Multiset 并没有实现 java.util.Set 接口，它更像是一个 Bag。 ——实现类有：HashMultiset，LinkedHashMultiset，TreeMultiset，EnumMultiset，ImmutableMultiset，Multimaps Muitimap接口:在 Map 的 value 里面放多个元素。Muitimap 不是 Map，没有实现 Map 的接口。 ——实现类有：HashMultimap，ArrayListMultimap，LinkedHashMultimap，TreeMultimap，ImmutableMultimap BiMap接口: 双向 Map，java.util.Map 只能保证 key 的不重复，BiMap 保证 value 也不重复。换句话说它的 key 和 value 是等价的。如果你往 BiMap 的 value 里面放了重复的元素，就会得到 IllegalArgumentException。 ——实现类有：HashBiMap，EnumBiMap，ImmutableBiMap MapMaker工具类: 超级强大的 Map 构造类。用来构造 ConcurrentMap 的工具类。 Ordering抽象工具类: 实现了Comparator接口，作为比较器来对集合排序，对于多关键字排序Ordering可以简化很多的代码。 CacheBuilder:全内存的本地缓存实现，它提供了线程安全的实现机制。 Joiner 可以快速地把多个字符串或字符串数组连接成为用特殊符号连接的字符串。 Splitter用来分割字符串。 CharMatcher常用来从字符串里面提取特定字符串。比如想从字符串中得到所有的数字: String value = CharMatcher.DIGIT.retainFrom(&quot;some text 2046 and more&quot;); 结果：value=2046; 各种以S结尾的工厂类简化了集合的创建。在创建泛型实例的时候，它们使代码更加简洁 List&lt;String&gt; list =Lists.newArrayList(); List&lt;String&gt; list2 = Lists.newArrayList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); Set&lt;Integer&gt; set = Sets.newHashSet(); Collections2.filter过滤集合中所有符合特定条件的元素。 List&lt;String&gt; listWithH = Lists.newArrayList(Collections2.filter(listStr, new Predicate&lt;String&gt;() { @Override public boolean apply(@Nullable String s) { return s.startsWith(&quot;h&quot;); } })) 具体可参考Google Guava Collections 使用介绍 | Guava用法总结","categories":[{"name":"Google_Guava","slug":"Google-Guava","permalink":"https://www.chenende.top/categories/Google-Guava/"}],"tags":[{"name":"Google_Guava","slug":"Google-Guava","permalink":"https://www.chenende.top/tags/Google-Guava/"}]},{"title":"使用BigDecimal进行浮点运算","slug":"java-BigDecimal","date":"2019-05-08T13:24:29.000Z","updated":"2019-05-08T13:26:35.303Z","comments":true,"path":"2019/05/08/java-BigDecimal/","link":"","permalink":"https://www.chenende.top/2019/05/08/java-BigDecimal/","excerpt":"前言Java中提供了大数字(超过16位有效位)的操作类,即 java.math.BinInteger 类和 java.math.BigDecimal 类,用于高精度计算.其中 BigInteger 类是针对大整数的处理类,而 BigDecimal 类则是针对大小数的处理类.BigDecimal 类的实现用到了 BigInteger类,不同的是 BigDecimal 加入了小数的概念.float和Double只能用来做科学计算或者是工程计算;在商业计算中,对数字精度要求较高,必须使用 BigInteger 类和 BigDecimal 类,它支持任何精度的定点数,可以用它来精确计算货币值。由于在运算的时候，float类型和double很容易丢失精度，所以一般不用来做计算货币。 BigDecimal构造方法一、有三种类型的构造方法:1、方法一BigDecimal BigDecimal(double d); //不允许使用 2、方法二BigDecimal BigDecimal(String s); //常用,推荐使用 3、方法三static BigDecimal valueOf(double d); //常用,推荐使用","text":"前言Java中提供了大数字(超过16位有效位)的操作类,即 java.math.BinInteger 类和 java.math.BigDecimal 类,用于高精度计算.其中 BigInteger 类是针对大整数的处理类,而 BigDecimal 类则是针对大小数的处理类.BigDecimal 类的实现用到了 BigInteger类,不同的是 BigDecimal 加入了小数的概念.float和Double只能用来做科学计算或者是工程计算;在商业计算中,对数字精度要求较高,必须使用 BigInteger 类和 BigDecimal 类,它支持任何精度的定点数,可以用它来精确计算货币值。由于在运算的时候，float类型和double很容易丢失精度，所以一般不用来做计算货币。 BigDecimal构造方法一、有三种类型的构造方法:1、方法一BigDecimal BigDecimal(double d); //不允许使用 2、方法二BigDecimal BigDecimal(String s); //常用,推荐使用 3、方法三static BigDecimal valueOf(double d); //常用,推荐使用 1.不推荐使用BigDecimal(double val)构造器，因为使用该构造器时有一定的不可预知性，当程序使用new BigDecimal(0.1)创建一个BigDecimal对象时，它的值并不是0.1，实际上是一个近似0.1的数。 2.建议优先使用基于String的构造器，使用BigDecimal(String val)构造器时可以预知的，写入new BigDecimal(“0.1”)将创建一个恰好等于0.1的BigDecimal。 3.如果必须使用double浮点数作为BigDecimal构造器的参数时，不要使用double作为参数，而应该通过BigDecimal.valueOf(double value)静态方法来创建对象。 二、BigDecimal类成员方法public BigDecimal add(BigDecimal augend)：加 public BigDecimal subtract(BigDecimal subtrahend)：减 public BigDecimal multiply(BigDecimal multiplicand)：乘 public BigDecimal divide(BigDecimal divisor)：除 public BigDecimal divide(BigDecimal divisor,int scale, int roundingMode)：商，几位小数，舍取模式 三、BigDecimal示列import java.math.BigDecimal; /** * @version: V1.0 * @author: fendo * @className: BigDecimalTest * @packageName: com.xxx * @description: BigDecimal测试类 * @data: 2018-04-17 14:23 **/ public class ArithTest { // 除法运算默认精度 private static final int DEF_DIV_SCALE = 10; private ArithTest() { } /** * 精确加法 */ public static double add(double value1, double value2) { BigDecimal b1 = BigDecimal.valueOf(value1); BigDecimal b2 = BigDecimal.valueOf(value2); return b1.add(b2).doubleValue(); } /** * 精确减法 */ public static double sub(double value1, double value2) { BigDecimal b1 = BigDecimal.valueOf(value1); BigDecimal b2 = BigDecimal.valueOf(value2); return b1.subtract(b2).doubleValue(); } /** * 精确乘法 */ public static double mul(double value1, double value2) { BigDecimal b1 = BigDecimal.valueOf(value1); BigDecimal b2 = BigDecimal.valueOf(value2); return b1.multiply(b2).doubleValue(); } /** * 精确除法 使用默认精度 */ public static double div(double value1, double value2) throws IllegalAccessException { return div(value1, value2, DEF_DIV_SCALE); } /** * 精确除法 * @param scale 精度 */ public static double div(double value1, double value2, int scale) throws IllegalAccessException { if(scale &lt; 0) { throw new IllegalAccessException(&quot;精确度不能小于0&quot;); } BigDecimal b1 = BigDecimal.valueOf(value1); BigDecimal b2 = BigDecimal.valueOf(value2); // return b1.divide(b2, scale).doubleValue(); return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); } /** * 四舍五入 * @param scale 小数点后保留几位 */ public static double round(double v, int scale) throws IllegalAccessException { return div(v, 1, scale); } /** * 比较大小 */ public static boolean equalTo(BigDecimal b1, BigDecimal b2) { if(b1 == null || b2 == null) { return false; } return 0 == b1.compareTo(b2); } public static void main(String[] args) throws IllegalAccessException { double value1=1.2345678912311; double value2=9.1234567890123; BigDecimal value3=new BigDecimal(Double.toString(value1)); BigDecimal value4=new BigDecimal(Double.toString(value2)); System.out.println(&quot;精确加法=================&quot;+ArithTest.add(value1, value2)); System.out.println(&quot;精确减法=================&quot;+ArithTest.sub(value1, value2)); System.out.println(&quot;精确乘法=================&quot;+ArithTest.mul(value1, value2)); System.out.println(&quot;精确除法 使用默认精度 =================&quot;+ArithTest.div(value1, value2)); System.out.println(&quot;精确除法 设置精度=================&quot;+ArithTest.div(value1, value2,20)); System.out.println(&quot;四舍五入 小数点后保留几位 =================&quot;+ArithTest.round(value1, 10)); System.out.println(&quot;比较大小 =================&quot;+ArithTest.equalTo(value3, value4)); } } 来源：CSDN | 原文：https://blog.csdn.net/u011781521/article/details/80052195","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"一道经典的java并发编程题-统计访问量及访问状态","slug":"java-Concurrent","date":"2019-05-08T11:45:17.000Z","updated":"2019-05-08T12:57:00.602Z","comments":true,"path":"2019/05/08/java-Concurrent/","link":"","permalink":"https://www.chenende.top/2019/05/08/java-Concurrent/","excerpt":"前言前不久去面试，需要上机编程，遇到了一道非常经典的java并发编程题,由于此前对这块内容涉猎不多，结果也就很自然的凉凉了。虽然没有通过面试，但好奇心让我并没有对那道并发编程题失去兴趣，后来在百度知道中发起求助，终于遇到了高人指点，豁然开朗，今天我们就一起看一下这道题。 题目统计访问量，要求实现Count接口，hr接口多线程访问，要保证线程安全 要求： 1.实现功能 2.线程安全 3.注意性能 interface Count { //每访问一次hr方法+1 void hr(); //访问状态 DateState state(); } class DateState { //最近10秒钟平均访问量 public int last10Second; //最近60秒钟平均访问量 public int last60Second; //最近10分钟平均访问量 public int last10Minute; //最近60分钟平均访问量 public int last60Minute; //每60秒平均访问量集合 public List&lt;Integer&gt; last60SecondList; }","text":"前言前不久去面试，需要上机编程，遇到了一道非常经典的java并发编程题,由于此前对这块内容涉猎不多，结果也就很自然的凉凉了。虽然没有通过面试，但好奇心让我并没有对那道并发编程题失去兴趣，后来在百度知道中发起求助，终于遇到了高人指点，豁然开朗，今天我们就一起看一下这道题。 题目统计访问量，要求实现Count接口，hr接口多线程访问，要保证线程安全 要求： 1.实现功能 2.线程安全 3.注意性能 interface Count { //每访问一次hr方法+1 void hr(); //访问状态 DateState state(); } class DateState { //最近10秒钟平均访问量 public int last10Second; //最近60秒钟平均访问量 public int last60Second; //最近10分钟平均访问量 public int last10Minute; //最近60分钟平均访问量 public int last60Minute; //每60秒平均访问量集合 public List&lt;Integer&gt; last60SecondList; } 说简单点就是实现Count接口中的两个方法，其中hr用来计数，state用来统计访问信息，为DataState中的成员变量赋值，需要注意的是成员变量的被public修饰的。 解题思路在动手之前首先应该捋清思路： 1.hr方法会被多线程访问要在方法中计数的话肯定要在接口中定义一个全局变量，而这个全局变量要求是线程安全的，java提供了具有原子性的基本类型，在java.util.concurrent.atomic中。 这些数据类型内部被volatile和lock修饰，保证了线程安全，开箱即用，不用再考虑加锁的问题。 2.state方法中的数据统计要获取指定时间段内的平均访问量，需要思考如何获取指定时间段内的访问量，开始时间和结束时间以什么为准，该如何绑定时间和数据的关系？ 面对一系列的问题我们很容易将问题复杂化，而我们要达到的目的是将问题简单化，这需要我们从一系统问题中找到一个突破口。 首先从数据和时间的关系入手，在hr方法中计数的时候，我们显示是能够获取到访问时间的，每增加一个访问数我们都可以获取到它的访问时间，这个时间就是访问时当前时间，使用System.currentTimeMillis()即得到。把所有访问时间放在一个集合里，即可得到访问总数的每个访问时间点。 如何获取指定时间段内的访问量，有了每个元素的访问时间，我们即可以当前时间为开始时间，减去访问时间，如果在指定时间段就进行计数，便可得到指定时间段内的访问总数。 性能问题，当访问数量比较大的情况下如果从头遍历肯定浪费性能，而题目中要求的是统计最近某个时间段的访问量，即从集合末尾往前遍历，超出范围退出遍历显然能大大节约性能。 最后一个难题在于如何每隔60s统计一下平均访问量，并将结果放进集合中。如果还在state方法中实现的话肯定是要遍历整个集合的，性能开销很大，且实现起来也较为复杂，也打乱了我们上面的思路。那能不能在hr方法中计数的时候就进行识别呢？即然我们能获得访问时间，大可以以第一个访问时间为开始时间，然后每获取一次访问时间就跟开始时间比较一下是否超过了60s，没有话就计数，超过的话就计算平均值放过集合里。这样一来实现起来是不是简单多了，state方法中直接赋值即可。 在思路明朗之后写起代码来才能得心应手，编码只是经过思考后结果的最终呈现，在动手之前应该有一个明确的思路。切忌一上来就乱写一通。 3.具体实现import java.util.concurrent.CopyOnWriteArrayList; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicLong; public class CountImpl implements Count { private static final long TIME_SLOT_TEN = 10; private static final long TIME_SLOT_SIXTY = 60; private static final int INIT_VALUE = 0; private static final int INCR_VALUE = 1; private static final long TIME_10S = TimeUnit.SECONDS.toMillis(TIME_SLOT_TEN); private static final long TIME_60S = TimeUnit.SECONDS.toMillis(TIME_SLOT_SIXTY); private static final long TIME_10M = TimeUnit.MINUTES.toMillis(TIME_SLOT_TEN); private static final long TIME_60M = TimeUnit.MINUTES.toMillis(TIME_SLOT_SIXTY); private AtomicLong count = new AtomicLong(); private AtomicLong start = new AtomicLong(); private CopyOnWriteArrayList&lt;Long&gt; list = new CopyOnWriteArrayList(); private AtomicInteger last60Second = new AtomicInteger(); private CopyOnWriteArrayList&lt;Integer&gt; last60SecondList = new CopyOnWriteArrayList(); @Override public void hr() { count.getAndIncrement(); list.add(System.currentTimeMillis()); setCount(System.currentTimeMillis()); } @Override public DateState state() { DateState dateState = new DateState(); long now = System.currentTimeMillis(); int num = INIT_VALUE; int last10Second = INIT_VALUE; int last60Second = INIT_VALUE; int last10Minute = INIT_VALUE; int last60Minute = INIT_VALUE; for (int i = list.size() - 1; i &gt;= 0; i--) { num++; long time = now - list.get(i); if (time &lt;= TIME_60M) { last60Minute = num; if (time &lt;= TIME_10S) { last10Second = num; } if (time &lt;= TIME_60S) { last60Second = num; } if (time &lt;= TIME_10M) { last10Minute = num; } } else { break; } } System.out.println(&quot;10s内访问总量：&quot; + last10Second); System.out.println(&quot;60s内访问总量&quot; + last60Second); System.out.println(&quot;10m内访问总量&quot; + last10Minute); System.out.println(&quot;60m内访问总量&quot; + last60Minute); dateState.last10Second = last10Second / (int) TIME_SLOT_TEN; dateState.last60Second = last60Second / (int) TIME_SLOT_SIXTY; dateState.last10Minute = last10Minute / (int) TIME_SLOT_TEN; dateState.last60Minute = last60Minute / (int) TIME_SLOT_SIXTY; dateState.last60SecondList = last60SecondList; return dateState; } public void setCount(long time) { if (start.get() == INIT_VALUE) { start.set(time); } if (time - start.get() &lt;= TIME_60S) { last60Second.set(last60Second.get() + INCR_VALUE); } else { last60SecondList.add(last60Second.get() / (int) TIME_SLOT_SIXTY); System.out.println(&quot;最近60秒平均访问量为：&quot; + last60Second.get() + &quot;,平均访问量为：&quot; + last60Second.get() / (int) TIME_SLOT_SIXTY + &quot;,已添加进last60SecondList集合。&quot;); last60Second.set(INIT_VALUE); start.set(INIT_VALUE); } } } CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。通过此机制实现了线程安全。更多请点击聊聊并发-Java中的Copy-On-Write容器 4.测试代码class test { public static void main(String[] args) { CountImpl count = new CountImpl(); ExecutorService pool = Executors.newFixedThreadPool(100); for (int i = 0; i &lt; 1000; i++) { try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } pool.execute(new Runnable() { @Override public void run() { count.hr(); System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot;正在运行&quot;); } }); } pool.shutdown(); DateState state = count.state(); System.out.println(&quot;最近10s平均访问量&quot; + state.last10Second); System.out.println(&quot;最近60s平均访问量&quot; + state.last60Second); System.out.println(&quot;最近10m平均访问量&quot; + state.last10Minute); System.out.println(&quot;最近60m平均访问量&quot; + state.last60Minute); System.out.println(&quot;最近60s平均访问量集合&quot; + state.last60SecondList); } } 5.测试结果10s内访问总量：5060s内访问总量30010m内访问总量100060m内访问总量1000最近10s平均访问量5最近60s平均访问量5最近10m平均访问量100最近60m平均访问量16最近60s平均访问量集合[5, 5, 5] 若有需要改进的地方或更好的实现方法，请各位在留言区留言，在此不胜感激。","categories":[{"name":"Concurrent","slug":"Concurrent","permalink":"https://www.chenende.top/categories/Concurrent/"}],"tags":[{"name":"Concurrent","slug":"Concurrent","permalink":"https://www.chenende.top/tags/Concurrent/"}]},{"title":"一道常见的java面试题：截取字符串函数","slug":"javaSE","date":"2019-04-29T15:10:05.000Z","updated":"2019-05-09T20:58:56.560Z","comments":true,"path":"2019/04/29/javaSE/","link":"","permalink":"https://www.chenende.top/2019/04/29/javaSE/","excerpt":"前言要求编写一个截取字符串的方法，入参是字符串和要截取的字符长度，其中字符串中包含中文和英文字母，要求截取的内容是完整的，例如我a们b，截取四个字符，结果应该返回我a。其中一个考察点就是一个中文点几个字节的问题。根据编码不同答案也就不同，其中UTF-8中一个中文点三个字节，GBK中点两个字节。 案例实现首先要编码之前我们应该理清思路，先着手思考如何实现基本功能，先不考虑异常情况。先随便来个字符串找一个规律我aadf是ssd中we国人,假设我们现在的编码是UTF-8,那么一个中文点三个字节。 假设我们要截取的字节长度是4,那么结果就应该是`我a`， 对应的字节数组是：[-26, -120, -111, 97, 97, 100, 102, -26, -104, -81, 115, 115, 100, -28, -72, -83, 119, 101, -27, -101, -67, -28, -70, -70] 假设我们要截取的字节长度是8,那么结果就应该是`我aadf`，截取到了三分之一的中文，因为不完整就得舍弃。 实际截取到的内容：[-26, -120, -111, 97, 97, 100, 102, -26]","text":"前言要求编写一个截取字符串的方法，入参是字符串和要截取的字符长度，其中字符串中包含中文和英文字母，要求截取的内容是完整的，例如我a们b，截取四个字符，结果应该返回我a。其中一个考察点就是一个中文点几个字节的问题。根据编码不同答案也就不同，其中UTF-8中一个中文点三个字节，GBK中点两个字节。 案例实现首先要编码之前我们应该理清思路，先着手思考如何实现基本功能，先不考虑异常情况。先随便来个字符串找一个规律我aadf是ssd中we国人,假设我们现在的编码是UTF-8,那么一个中文点三个字节。 假设我们要截取的字节长度是4,那么结果就应该是`我a`， 对应的字节数组是：[-26, -120, -111, 97, 97, 100, 102, -26, -104, -81, 115, 115, 100, -28, -72, -83, 119, 101, -27, -101, -67, -28, -70, -70] 假设我们要截取的字节长度是8,那么结果就应该是`我aadf`，截取到了三分之一的中文，因为不完整就得舍弃。 实际截取到的内容：[-26, -120, -111, 97, 97, 100, 102, -26] 仔细观察的话可以发现截取到不完整内容的情况下数组中的最后一位是小于0的数字，处在它后面的数字也是小于0的。遇到这种情况需要循环判断让截取长度递减，舍弃最后一位，可以先按照这个规律完成初步的代码。 for(int i =0;i&lt;num;i--){ //如果截取的最后一个字节小于0且后面的一个也小于0，说明有可能截取到半个汉字，为区分已截取的内容是否完整 // 定义count变量，统计截取的小于0的字节个数 if(bytes[num-1]&lt;0 &amp;&amp; bytes[num]&lt;0){ num --; //如果字符串以汉字开头，截取内容未超过一个汉字所占字节，就退出循环，避免数据越界 if(num == 0){ break; } }else{ break; } } 还有一种情况是两个中文在一块我aadf是ssd中we国人，其中国人的字节码是[-27, -101, -67, -28, -70, -70],遇到这种情况下上面的规律就会不起作用，为排除这种情况的干扰，需要添加条件统计舍弃的个数，如果舍弃的个数超过一个汉字的字节数，说明是有一个完整汉字的，只把多出来的那部分去掉即可。可以用求余的方式来得到多出来的部分。 int count =0; for(int i =0;i&lt;num;i--){ //如果截取的最后一个字节小于0且后面的一个也小于0，说明有可能截取到半个汉字，为区分已截取的内容是否完整 // 定义count变量，统计截取的小于0的字节个数 if(bytes[num-1]&lt;0 &amp;&amp; bytes[num]&lt;0){ count++ ; num --; }else{ break; } } //还原要截取的字节长度 num+=count; //如果截取次数除以一个汉字所占的字节长度有余数，说明不是一个完整的汉字，就减去多余的字节，否则说明截取的内容是完整的。 if(count%code &gt; 0){ num -= count%code; } 多测试几次你或许会发现，当截取长度大于字节长度的话程序会出错，这就需要我们做一下处理，直接全部字节即可。 if(num&gt;=bytes.length){ return str; } 当字符串以中文开头，而要截取的长度不足一个中文的时候应该什么也不返回。 for(int i =0;i&lt;num;i--){ //如果截取的最后一个字节小于0且后面的一个也小于0，说明有可能截取到半个汉字，为区分已截取的内容是否完整 // 定义count变量，统计截取的小于0的字节个数 if(bytes[num-1]&lt;0 &amp;&amp; bytes[num]&lt;0){ count++ ; num --; //如果字符串以汉字开头，截取内容未超过一个汉字所占字节，就退出循环，避免数据越界 if(num == 0){ break; } }else{ break; } } 经过反复测试，就形成下面最终的代码。我们在面试的时候往往很讨厌做那些看似无聊的面试题，但你若认真对待的话会发现这些题目往往很考验一个人的逻辑思维能力，那些面试官的目的也不过如此，实现功能是一方面，代码逻辑是否清晰又是一方面。遇到问题解决问题的能力才是一个开发人员的价值所在。还有一点很重要，没有谁能一步到位的把代码写好，需要反复测试不断完善，不要觉得功能实现了就没问题了。 public class StringUtil { //不同编码中的汉字字节个数不同，UTF-8编码一个汉字由三个字节组成，GBK由两个 public static final int UTF_8=3; public static final int GBK=2; public static String subString(String str,int num,int code){ byte[] bytes = str.getBytes(); //如果要截取的字节长度大于字符串的字节长度，就将内容全部输出 if(num&gt;=bytes.length){ return str; } int count =0; for(int i =0;i&lt;num;i--){ //如果截取的最后一个字节小于0且后面的一个也小于0，说明有可能截取到半个汉字，为区分已截取的内容是否完整 // 定义count变量，统计截取的小于0的字节个数 if(bytes[num-1]&lt;0 &amp;&amp; bytes[num]&lt;0){ count++ ; num --; //如果字符串以汉字开头，截取内容未超过一个汉字所占字节，就退出循环，避免数据越界 if(num == 0){ break; } }else{ break; } } //还原要截取的字节长度 num+=count; System.out.println(num); //如果截取次数除以一个汉字所占的字节长度有余数，说明不是一个完整的汉字，就减去多余的字节，否则说明截取的内容是完整的。 if(count%code &gt; 0){ num -= count%code; } String s = new String(bytes, 0, num); return s; } public static void main(String[] args) { String str = subString(&quot;我abc是b中ddds国dds人&quot;, 9, UTF_8); System.out.println(str); } }","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"springboot 全局异常处理","slug":"SpringMVC-GlobalExceptionHandler","date":"2019-04-27T02:37:06.000Z","updated":"2019-05-09T20:58:56.052Z","comments":true,"path":"2019/04/27/SpringMVC-GlobalExceptionHandler/","link":"","permalink":"https://www.chenende.top/2019/04/27/SpringMVC-GlobalExceptionHandler/","excerpt":"前言实际开发中会有各种各样的异常需要处理，写起来非常繁琐，springMVC框架提供了全局异常处理服务，通过配置全局异常处理器，项目中所有异常都不再需要手动捕获处理，springMVC会统一交给异常处理器进行处理。本意我们就来学习一下全局异常处理器的开发。 案例实现 在springboot中是通过注解的方式配置异常处理器的。 @ControllerAdvice：注册异常处理类 @ExceptionHandler：统一处理某一类异常，该注解作用对象为方法，通过value=来指定异常类。 例如：`@ExceptionHandler(value = Exception.class)` 首先我们将项目中的异常大致分为两类，一类是已知异常，业务参数方面引起的异常。第二类是未知异常，空指针等等代码设计方面的。","text":"前言实际开发中会有各种各样的异常需要处理，写起来非常繁琐，springMVC框架提供了全局异常处理服务，通过配置全局异常处理器，项目中所有异常都不再需要手动捕获处理，springMVC会统一交给异常处理器进行处理。本意我们就来学习一下全局异常处理器的开发。 案例实现 在springboot中是通过注解的方式配置异常处理器的。 @ControllerAdvice：注册异常处理类 @ExceptionHandler：统一处理某一类异常，该注解作用对象为方法，通过value=来指定异常类。 例如：`@ExceptionHandler(value = Exception.class)` 首先我们将项目中的异常大致分为两类，一类是已知异常，业务参数方面引起的异常。第二类是未知异常，空指针等等代码设计方面的。 /** * @description 全局异常处理: 使用 @RestControllerAdvice + @ExceptionHandler 注解方式实现全 * 局异常处理 */ @RestControllerAdvice public class GlobalExceptionHandler { private final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * @description 处理所有不可知的异常 */ @ExceptionHandler(Exception.class) //申明捕获那个异常类 public Result globalExceptionHandler(Exception e) { this.logger.error(e.getMessage(), e); return Result.isError(ErrorEnum.USER_NOT_EXIST.name(),ErrorEnum.SYSTEM_EXCEPTION.getErrorMsg()); } /** * @description 处理所有业务异常 */ @ExceptionHandler(BaseBusinessException.class) public Result BusinessExceptionHandler(BaseBusinessException e) { this.logger.error(e.getMessage(),e); return Result.isError(e.getCode(),e.getMessage()); } } 其中使用到了Result工具类及ErrorEnum枚举类，使代码开发更简洁更规则,还需要自定义异常类来处理已知的业务异常 Result工具类 public class Result&lt;T&gt;{ private boolean success = true; private T data; private String errorCode; private String errorMes; public boolean isSuccess() { return success; } public void setSuccess(boolean success) { this.success = success; } public T getData() { return data; } public void setData(T data) { this.data = data; } public String getErrorCode() { return errorCode; } public void setErrorCode(String errorCode) { this.errorCode = errorCode; } public String getErrorMes() { return errorMes; } public void setErrorMes(String errorMes) { this.errorMes = errorMes; } public static &lt;T&gt; Result isError(String errorCode,String errorMes){ Result&lt;T&gt; objectResult = new Result&lt;&gt;(); objectResult.success=false; objectResult.errorCode=errorCode; objectResult.errorMes=errorMes; return objectResult; } public static &lt;T&gt;Result isSuccess (T data){ Result&lt;T&gt; objectResult = new Result&lt;&gt;(); objectResult.data=data; return objectResult; } } ErrorEnum枚举类 public enum ErrorEnum { ID_IS_NULL(&quot;ID_IS_NULL&quot;,&quot;ID是不能为空的哟&quot;), INSERT_USER_ERROR(&quot;INSERT_USER_ERROR&quot;,&quot;添加用户失败&quot;), USER_EXIST(&quot;USER_EXIST&quot;,&quot;用户已存在&quot;), PARAM_ERROR(&quot;PARAM_ERROR&quot;,&quot;参数有误，请重新输入&quot;), USER_NOT_EXIST(&quot;USER_NOT_EXIST&quot;,&quot;用户不存在&quot;), SYSTEM_EXCEPTION(&quot;SYSTEM_EXCEPTION&quot;,&quot;系统异常&quot;), USER_NOT_LOGIN(&quot;USER_NOT_LOGIN&quot;,&quot;请登录后重新访问&quot;); private String errorCode; private String errorMsg; ErrorEnum(String errorCode, String errorMsg) { this.errorCode = errorCode; this.errorMsg = errorMsg; } public String getErrorCode() { return errorCode; } public String getErrorMsg() { return errorMsg; } } 自定义基础业务异常类BusinessExceptionHandler，供不同的业务异常继承使用 public class BaseBusinessException extends RuntimeException{ private String message; private String code; public BaseBusinessException(ErrorEnum errorEnum){ this(errorEnum.getErrorCode(),errorEnum.getErrorMsg()); } public BaseBusinessException(String code,String message) { super(message); } public String getCode() { return code; } public void setCode(String code) { this.code = code; } } 使用基础异常类创建一个业务异常类UserException public class UserException extends BaseBusinessException{ public UserException(ErrorEnum errorEnum) { super(errorEnum); } } 测试代码完成上面代码的编写，我们就可以用全局异常处理器来处理所有异常了 @RequestMapping(&quot;/updateUser&quot;) @ResponseBody public Result updateUser(@Valid User user,BindingResult result) { if(user.getId()==null){ throw new UserException(ErrorEnum.ID_IS_NULL); } if(result.hasErrors()){ return Result.isError(ErrorEnum.PARAM_ERROR.name(),result.getFieldError().getDefaultMessage()); } return userService.updateUser(user); } 不管是在controller层还是service层，代码里直接使用[throw new UserException(ErrorEnum.ID_IS_NULL);]抛出异常就可以被全局异常处理器统一捕获处理。参考资料：springBoot 全局异常方式处理自定义异常","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/tags/springboot/"}]},{"title":"简明Filter and Interceptor区别","slug":"java-filter-interceptor","date":"2019-04-26T22:16:11.000Z","updated":"2019-04-29T16:34:12.095Z","comments":true,"path":"2019/04/27/java-filter-interceptor/","link":"","permalink":"https://www.chenende.top/2019/04/27/java-filter-interceptor/","excerpt":"前言在web应用中filter和interceptor无论是概念还是应用都让人傻傻分不清，今天我们就从二者的本质上来认识区分一下它们的不同之处。 Filter过滤器filter是servlet技术，实现了servlet.filter接口，是随着servlet容器启动而实例化的，除服务器关掉，否则将一直存在。它主是用来处理用户请求，在请求到达容器后就会被filter处理，具体要处理什么就看你代码里怎么写了。处理完后会被放行到请求的servlet，即负责接收用户请求的Action。在Action处理完后服务器响应结果给用户之前，filter又出现了，它会对处理结果进行拦截，然后再次进行处理，具体要处理什么还是由写代码的人决定的，当然可以什么都不写，filter也就什么也不会做。 所有综上所述，filer就是用来处理用户请和服务器响应的，对于中间的执行过程毫不关心，也不会更没办法进行干涉。","text":"前言在web应用中filter和interceptor无论是概念还是应用都让人傻傻分不清，今天我们就从二者的本质上来认识区分一下它们的不同之处。 Filter过滤器filter是servlet技术，实现了servlet.filter接口，是随着servlet容器启动而实例化的，除服务器关掉，否则将一直存在。它主是用来处理用户请求，在请求到达容器后就会被filter处理，具体要处理什么就看你代码里怎么写了。处理完后会被放行到请求的servlet，即负责接收用户请求的Action。在Action处理完后服务器响应结果给用户之前，filter又出现了，它会对处理结果进行拦截，然后再次进行处理，具体要处理什么还是由写代码的人决定的，当然可以什么都不写，filter也就什么也不会做。 所有综上所述，filer就是用来处理用户请和服务器响应的，对于中间的执行过程毫不关心，也不会更没办法进行干涉。 Interceptor拦截器Interceptor是spring框架提供的，它实现了AOP面向切面编程的思想，主要是用来在目标对象的方法前后织入通知代码实现功能增强。它所服务的对象即关注点在于方法，它可以获取spring容器中的实例对象，也可以调用实例中的方法。这些是Filter做不到的。而filter能做的Interceptor也能做。 总结 如上图所示，filter要范围比interceptor大，先执行filter后才会执行interceptor,然后执行请求对应的方法，然后再执行interceptor，再到filter.日常开发使用的时候应该看处理的重点是用户请求还是增强处理请求的方法，然后对应的选择使用filter还是interceptor. 参考资料：过滤器（Filter）与拦截器（Interceptor )区别","categories":[{"name":"java web","slug":"java-web","permalink":"https://www.chenende.top/categories/java-web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://www.chenende.top/tags/java-web/"}]},{"title":"springBoot缓存的使用","slug":"springboot-cache","date":"2019-04-26T20:47:54.000Z","updated":"2019-05-09T21:19:18.684Z","comments":true,"path":"2019/04/27/springboot-cache/","link":"","permalink":"https://www.chenende.top/2019/04/27/springboot-cache/","excerpt":"前言在需要频繁读取数据库的场景下引入缓存将大大提升系统性能，Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如EHCache 或者 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。 本章我们就来学习一下springboot中通过注解如何使用EhCache。 案例实现首先来了解一下EhCache,这是纯java开发的，支持分布式缓存的技术，且是开源项目中广受欢迎使用最多的缓存技术。Spring定义了org.springframework.cache.CacheManager和org.springframework.cache.Cache接口用来统一不同的缓存的技术。其中，CacheManager是Spring提供的各种缓存技术抽象接口，Cache接口包含缓存的各种操作（增加、删除、获得缓存，我们一般不会直接和此接口打交道）。","text":"前言在需要频繁读取数据库的场景下引入缓存将大大提升系统性能，Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如EHCache 或者 OSCache），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。 本章我们就来学习一下springboot中通过注解如何使用EhCache。 案例实现首先来了解一下EhCache,这是纯java开发的，支持分布式缓存的技术，且是开源项目中广受欢迎使用最多的缓存技术。Spring定义了org.springframework.cache.CacheManager和org.springframework.cache.Cache接口用来统一不同的缓存的技术。其中，CacheManager是Spring提供的各种缓存技术抽象接口，Cache接口包含缓存的各种操作（增加、删除、获得缓存，我们一般不会直接和此接口打交道）。 使用方式Spring提供了4个注解来声明缓存规则（又是使用注解式的AOP的一个生动例子）： 以上注解在使用的时候都需要指定key和value,具体可以参考下文的使用案例 开启声名式缓存支持开启声名式缓存支持十分简单，只需在配置类上使用@EnableCaching注解即可，例如： @Configuration @EnableCaching public class AppConfig { } 在springboot中，已经为cache做了自动配置,使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在配置类使用@EnableCaching开启缓存支持即可。 配置Ehcache 首先在pom.xml文件中添加依赖 &lt;!--开启 cache 缓存--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- ehcache 缓存 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;/dependency&gt; 在resource文件夹下创建文件ehcache.xml，并进行配置： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;1000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;0&quot; timeToLiveSeconds=&quot;600&quot; memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt; &lt;!-- 这里的 users 缓存空间是为了下面的 demo 做准备 --&gt; &lt;cache name=&quot;users&quot; eternal=&quot;false&quot; maxElementsInMemory=&quot;100&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;0&quot; timeToLiveSeconds=&quot;300&quot; memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt; &lt;/ehcache&gt; springboot会根据文件名称自动加载配置文件，无需在application.yml文件中指定。 ehcache.xml 文件配置详解： diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。name:缓存名称。maxElementsInMemory:缓存最大数目maxElementsOnDisk：硬盘最大缓存个数。eternal:对象是否永久有效，一但设置了，timeout将不起作用。overflowToDisk:是否保存到磁盘，当系统当机时timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. Thedefault value is false.diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。clearOnFlush：内存数量最大时是否清除。memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。FIFO，first in first out，先进先出。LFU， Less Frequently Used，一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 配置完成后项目启动后会自动加载eacache.xml文件，需要注意的在别忘记在启动类上添加开启缓存的注解@EnableCaching 使用示例 @EnableCaching @Service public class UserService { //自定义KEY，这里的单引号不能少，否则会报错，被识别是一个对象 private static final String CACHE_KEY = &quot;&apos;user&apos;&quot;; //缓存空间名称需要跟xml文件中配置的保持一致 private static final String DEMO_CACHE_NAME = &quot;users&quot;; @Autowired private UserDao userDao; //删除用户数据 @CacheEvict(value = DEMO_CACHE_NAME,key = &quot;&apos;user_&apos;+#uuid&quot;)//这是清除缓存 public void delete(String uuid){ userDao.delete(uuid); } //更新用户数据 @CachePut(value = DEMO_CACHE_NAME,key = &quot;&apos;user_&apos;+#user.getUuid()&quot;) public User update(User user) throws CacheException{ User user1 = userDao.findByUuid(user.getUuid()); if (null == user1){ throw new CacheException(&quot;Not Find&quot;); } user1.setAge(user.getAge()); user1.setName(user.getName()); return user1; } //查找用户数据 @Cacheable(value=DEMO_CACHE_NAME,key=&quot;&apos;user_&apos;+#uuid&quot;) public User findByUuid(String uuid){ //若找不到缓存将打印出提示语句 System.err.println(&quot;没有走缓存！&quot;+uuid); return userDao.findByUuid(uuid); } //保存用户数据 @CacheEvict(value=DEMO_CACHE_NAME,key=CACHE_KEY) public int save(User user){ return userDao.save(user); 更多内容请参考：SpringBoot 缓存(EhCache 2.x 篇)SpringBoot之数据缓存Cache操作","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/tags/springboot/"}]},{"title":"java多线程的使用场景","slug":"java-thread","date":"2019-04-25T23:28:40.000Z","updated":"2019-04-26T00:27:24.351Z","comments":true,"path":"2019/04/26/java-thread/","link":"","permalink":"https://www.chenende.top/2019/04/26/java-thread/","excerpt":"前言要掌握多线程的使用需要有足够丰富的计算机原理知识做支撑，本章节我们对此做以简单的论述，介绍一下进程和线程的区别，及多线程的使用场景，并不是所有情况下使用多线程都能够提高执行效率。 进程和线程的区别 什么是进程 进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。 什么是多线程 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成， 线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。","text":"前言要掌握多线程的使用需要有足够丰富的计算机原理知识做支撑，本章节我们对此做以简单的论述，介绍一下进程和线程的区别，及多线程的使用场景，并不是所有情况下使用多线程都能够提高执行效率。 进程和线程的区别 什么是进程 进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。 什么是多线程 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成， 线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。 线程和进程各自有什么区别和优劣呢？ 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 小结：进程是负责资源管理的最小单位，线程是其组成部分，是负责CPU调度的，所有线程都共享所在进程的资源。假设进程执行时分配了5%的CPU资源，不管创建多少个线程它们所能使用的资源也就只有5%，且是抢占式的执行，而多线程的应用则是为了充分利用这5%的CPU资源，不让它有空闲的时候。 并发与并行举个栗子 比如挖10个隧道，10个人一起挖1、只有一把大锤子，10个人要轮流使用，一段时间内总体看来进度一致的，这叫并发 2、每个人都有一把大锤子，同一时间点10个在同时进行，这叫并行。 并发是就时间段而言的，并不是真正意义上的同时干多件事;并行是就时间点而言的，是真正意义上的同时。 在单CPU的服务器上，多线程不过是CPU在不同的时间片之间切换，而表现出齐头并进的样子。多CPU的服务器则可以实行并行。 多线程是不是能加快处理速度？在使用多线程时，一定要知道一个道理：处理速度的最终决定因素是CPU、内存等，在单CPU（无论多少核）上，分配CPU资源的单位是“进程”而不是“线程”。 进程只有一个，所以分配的CPU资源是一定的，多线程只不过是轮流抢占CPU而已，并不会真正提高处理速度。这意味着，多线程的作用主要在于提高了并发数量，比如http请求，如果是单线程，一次只能接收一个请求，多线程则可以同时接收多个请求。 但是多线程由于轮换使用CPU，会造成单个线程的执行速度变慢（以前CPU供一个线程使用，现在要供多个线程轮流使用了）。但是在多CPU的服务器上，多线程就很有优势了，它不但能提高并发数量，而且能提高处理速度。因为在多CPU的服务器上，CPU调度很灵活，当一个线程占用着一个CPU的时候，其他线程可以被分配给其他CPU去处理，从而实现了“真正意义上地并行”。 再举个栗子 比如挖一个隧道，有2种开工方法 1、只在山的一头挖，直至挖到山的另一头，从而打通隧道，这可以看成是单线程 2、在山的两头挖，同时开工，最后在山的中间接通，从而打通隧道，这感觉肯定比1快了很多，好比多线程 但是2成立的前提是必须有两个工人。而我们的计算机中一般来说只有一个CPU，也就是说只有一个工人。多线程不过是CPU在不同的时间片之间切换，而表现出齐头并进的样子。 既然挖隧道的人只有一个，虽然我的施工方案是在山的两头开挖，但是由于工作的人只有一个，所以只有让这个人在山的两头跑，挖一会这头再去挖另一头，来回跑是要花费额外时间的（好比线程的切换和调度）。 那么，我们是不是可以说，在单CPU的机器中，多线程反而降低了效率呢？ 1.不能一概而论，你的看多线程在你的程序中为啥而生。在单cpu系统，比如有io的等待，多线程的确能提高效率 2.如果cpu确实是一个挖山工人，且它工作挖2个小时，然后必须休息1小时；这1小时休息期间如果让它跑到山那头继续挖，效率还是很高的。 现在的程序时间大多花在读取数据上，真正的计算工作花时间还是相对少的，因此cpu很大时间表现都很闲，就像挖土效率高，运土效率低。 多线程就是要充分利用它的挖土效率。 3.pc机不光只一个cpu，cpu和其它硬件设备一起才能完成计算，分工协作，但可能出现其中某个家伙偷懒或效率低，导致大家都等它， 闲着的其它设备这个时候可以腾出手来干其它活。单cpu在同一时刻只能干一件事情，这没有问题，问题是它并不是7*24*3600都在干活， 其它设备也是同样的道理，多线程的目的可以最大限度的提高硬件设备的利用率。 4.同一个设备可以同时(并行，互不影响)干几件事情，但同一个设备在同一时刻肯定只能干一件事情，一般我们说并行或串行，都以时间段来 看的而不是以时间点来看的，比如你一边上je消遣还一边写代码干活，在一定的时间范围内，你是并行的，但如果这个时间范围你划分得非 常非常短，那么你是串行的。 5.一个cpu可以多线程。但是一个单核的cpu任何时间点，都只能在做一个任务。 如果只是像楼主说的挖隧道这么简单的挖，那么的确多线程没用。 只不过很可惜，计算机不像拿铁锹挖隧道这么简单。 假设每挖5分钟，就需要清理一下挖出来的石土。有一个小车在清理它们。工人只有一个。单线程的做法是： 挖5分钟。然后工人停止挖，小车清理石土的5分钟里，工人在等待。2个线程的做法是： 挖5分钟，小车来清理石土。这5分钟里，工人在另一头挖。 也不是很恰当的比喻。不过至少能说明点问题。小车清理石土，就相当于磁盘io等相对于cpu计算来说比较慢的操作。 cpu不会等着io的完成，而去执行另一个进程的计算任务。 如果一个机器人代表CUP，哪么这个机器人一天所做的事情，并不都是只挖山。它还有许多事情要做，比如砍柴，烧水，钓鱼，挖山等等等。如果按以上划分是 4条进程， 每一个进程大概占用1/4CUP时间。 如果你的设定 在挖山这一快 多设几次同一个任务。 比如设定到 挖山共有3条线程。 哪么 挖山的CUP占用率将达到 1/2 这就是所谓的提高了效率。 现实中的CPU 在大部分时候的 闲置状态的。因此 开多条线程能提高效率 不如说成是 充分利用了CPU执行时间。 因此在使用多纯种的时候要充分考虑应用场景是否合适，是否存在CPU资源闲置的情况存在，如果在单线程的情况下CPU一直在运转，换成多线程是完全没有意义的，且反而会增加程序运行时间。参考资料：JAVA多线程，真的能提高效率吗 多线程是否能加快处理速度 springMVC和Strues2的线程安全问题 springMV框架是基于servlet技术的，Servlet容器默认是采用单实例多线程的方式处理多个请求的： 1.当web服务器启动的时候（或客户端发送请求到服务器时），Servlet就被加载并实例化(只存在一个Servlet实例)； 2.容器初始化化Servlet主要就是读取配置文件（例如tomcat,可以通过servlet.xml的设置线程池中线程数目，初始化线程池通过web.xml,初始化每个参数值等等。 3.当请求到达时，Servlet容器通过调度线程(Dispatchaer Thread) 调度它管理下线程池中等待执行的线程（Worker Thread）给请求者； 4.线程执行Servlet的service方法； 5.请求结束，放回线程池，等待被调用；（注意：避免使用实例变量（成员变量），因为如果存在成员变量，可能发生多线程同时访问该资源时，都来操作它，照成数据的不一致，因此产生线程安全问题）从上面可以看出（好处）： 第一：Servlet单实例，减少了产生servlet的开销； 第二：通过线程池来响应多个请求，提高了请求的响应时间； 第三：Servlet容器并不关心到达的Servlet请求访问的是否是同一个Servlet还是另一个Servlet，直接分配给它一个新的线程； 如果是同一个Servlet的多个请求，那么Servlet的service方法将在多线程中并发的执行； 第四：每一个请求由ServletRequest对象来接受请求，由ServletResponse对象来响应该请求； struts2是多例的，会为每一个请求创建一个Active实例，所以它也是线程安全的。struts1是单例的，线程不安全。 更多请参考 servlet 如何处理多请求访问以及线程讲解","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"spring AOP思想","slug":"spring-aop","date":"2019-04-24T16:48:16.000Z","updated":"2019-05-09T20:58:56.176Z","comments":true,"path":"2019/04/25/spring-aop/","link":"","permalink":"https://www.chenende.top/2019/04/25/spring-aop/","excerpt":"前言AOP是一种面向切面编程的思想，具体的表现形式有拦截器，过滤器，动态代理…spring AOP体现了面向切面编程的思想，是基于动态代理完成的，对指定类中的方法进行功能增强生成代理对象，然后执行代理对象输出结果。spring封装了动态代理代码，还封装了cglib代理。可以对任何类进行代理增强，在学习spring AOP之前先让我们一起了解一下动态代理的使用吧。 动态代理 通过动态代理可以体现AOP思想 对目标对象中的方法进行增强JDK提供的代理模式，通过Proxy对象实现：","text":"前言AOP是一种面向切面编程的思想，具体的表现形式有拦截器，过滤器，动态代理…spring AOP体现了面向切面编程的思想，是基于动态代理完成的，对指定类中的方法进行功能增强生成代理对象，然后执行代理对象输出结果。spring封装了动态代理代码，还封装了cglib代理。可以对任何类进行代理增强，在学习spring AOP之前先让我们一起了解一下动态代理的使用吧。 动态代理 通过动态代理可以体现AOP思想 对目标对象中的方法进行增强JDK提供的代理模式，通过Proxy对象实现： 代码编写public class GetProxyUtil implements InvocationHandler { public GetProxyUtil(UserInterface userInterface) { this.user = userInterface; } private UserInterface user; public UserInterface getProxy(){ UserInterface userProxy = (UserInterface)Proxy.newProxyInstance(GetProxyUtil.class.getClassLoader(), user.getClass().getInterfaces(), this); return userProxy; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;开始事务&quot;); Object invoke = method.invoke(user,args); System.out.println(&quot;关闭事务&quot;); return invoke; } } 执行结果： 开启事务 麻辣小龙虾 关闭事务 需要注意的是返回的代理对象类型一定是接口，即被代理对象实现的接口，否则会发生转换错误Exception in thread “main” java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to User Proxy.newProxyInstance方法有三个入参： GetProxyUtil.class.getClassLoader()：类加载器，通过哪个类获取都行 user.getClass().getInterfaces()：实现的所有类，即获取所实现的接口集合 this：指的是`InvocationHandler`中的`invoke`方法，当前类实现了`InvocationHandler`接口，否则需要以匿名内部类的方式添加 在InvocationHandler的invoke方法中有三个入参： Object proxy： 当前被代理类 Method method： 被代理类中的方法 Object[] args：方法中的入参 需要增强的代码就写在这个方法里，method.invoke执行的是被代理类中的方法，在使用的时候指定要增强哪个方法，在方法前后可以添加功能，这就是动态代理的核心所在。 method.invoke中的两个入参： 第一个需要手动添加的是被代理类; 第二个手动添加的是所有方法的入参集合 代码使用public class Test { public static void main(String[] args) { //被代理类 UserInterface user = new User(); GetProxyUtil userProxy = new GetProxyUtil(user); //获取代理类 UserInterface proxy = userProxy.getProxy(); //指定被代理的方法 proxy.eat(&quot; 麻辣小龙虾&quot;); } } cglib代理需要注意的是：被代理的类不能被final修饰 代码编写public class GetProxyUtil implements MethodInterceptor { private User user; public GetProxyUtil(User user) { this.user = user; } public UserInterface getProxy (){ //帮我们创建代理对象 Enhancer en = new Enhancer(); //设置为谁代理 en.setSuperclass(user.getClass()); //代理要做什么，因为实现了MethodInterceptor方法，所以这里可以this指代，否则需要手动创建匿名内部类 en.setCallback(this); //创建代理对象 UserInterface userProxy =(UserInterface)en.create(); return userProxy; } @Override public Object intercept(Object proxyobj, Method method, Object[] arg, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;开启事务&quot;); Object res = methodProxy.invokeSuper(proxyobj, arg); System.out.println(&quot;关闭事务&quot;); return res; } } MethodInterceptor中的intercept方法入参说明： Object proxyobj：被代理对象 Method method：被代理对象的方法 Object[] arg：被代理对象中方法的所有入参 MethodProxy methodProxy：代理对象中的所有方法 代码测试package demo.demoweb; public class Demo { public static void main(String[] args) { User user = new User(); GetProxyUtil getProxyUtil = new GetProxyUtil(user); UserInterface proxy = getProxyUtil.getProxy(); proxy.eat(); } } 执行结果： 开启事务 麻辣小龙虾 关闭事务 因为sping框架整合了cglib代理，所以在web项目中使用无需导包，在javaSE中使用则需要导入cglibjar包 动态代理是基于实现接口的形式进行代理的，如果没有接口就不能使用动态代理，而cglib是基于继承，如果目标对象被final修饰无法被cglib代理。spring混合使用了这两种代理形式，在没有接口的情况会使用cglib代理。 spring AOP执行过程 首先需要明白图中的几个名词： 连接点：即目标对象中的方法，目标对象指的是需要增加功能的方法所在的那个类 切入点：已经被代理对象增强了的方法 通知/增强：要添加的功能代码 目标对象：要增强的对象，即被代理对象 织入：将`通知/增强`应用到`切入点`的过程 代理：生成的代理对象 切面：方法被增强以后就形成切面 在目标对象的连接点通过动态代理的方式织入`通知后形成切入点，然后获得代理，这一过程就是AOP`思想的具体体现。通俗来讲就是：通过动态代理的方式将增强代码应用到被代理对象的方法中，拿到代理对象，然后执行代理对象达到增强原有功能的效果。 spring中的基本使用 1.编写目标类 创建接口和类: public interface OrderDao { public void save(); public void update(); public void delete(); public void find(); } public class OrderDaoImpl implements OrderDao { @Override public void save() { System.out.println(&quot;保存订单...&quot;); } @Override public void update() { System.out.println(&quot;修改订单...&quot;); } @Override public void delete() { System.out.println(&quot;删除订单...&quot;); } @Override public void find() { System.out.println(&quot;查询订单...&quot;); } } 将类通过配置注入到spring容器中 &lt;!-- 目标类================ --&gt; &lt;bean id=&quot;orderDao&quot; class=&quot;cn.itcast.spring.demo3.OrderDaoImpl&quot;&gt; &lt;/bean&gt; 2.编写一个切面类 切面类中包含了实现增强功能的代码，和切入点的位置，是在方法前还是后，共有五种类型，分别是： 前置通知（before） :在目标方法执行之前执行. 后置通知（after-returning） :在目标方法执行之后执行 环绕通知（around） :在目标方法执行前和执行后执行 异常抛出通知（after-throwing）:在目标方法执行出现 异常的时候 执行 最终通知（after） :无论目标方法是否出现异常 最终通知都会 执行. public class MyAspectXml { // 前置增强 public void before(){ System.out.println(&quot;前置增强===========&quot;); } } 3.在spring配置文件中添加配置 &lt;!-- 配置切面类 --&gt; &lt;bean id=&quot;myAspectXml&quot; class=&quot;cn.alibaba.spring.demo3.MyAspectXml&quot;&gt;&lt;/bean&gt; &lt;!-- 进行 aop 的配置 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式:哪些类的哪些方法需要进行增强 --&gt; &lt;aop:pointcut &lt;!-- 目标类的位置 --&gt; expression=&quot;execution(*cn.alibaba.spring.demo3.OrderDao.save(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;myAspectXml&quot;&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 目标类所处的位置通过表达式的方式来说明的： execution(表达式) 表达式: [方法访问修饰符] 方法返回值 包名.类名.方法名(方法的参数) 完整内容如下： public.void.cn.alibaba.spring.dao.UserDao.save(User user) 无论是否有返回值都进行增强： *.cn.alibaba.spring.dao.UserDao.save(User user) 目标类UserDao下的所有没有入参的方法都进行增强： *.cn.alibaba.spring.dao.UserDao.*() 目标类UserDao下的所有方法不管有没有入参的都进行增强： *.cn.alibaba.spring.dao.UserDao.*(..) 对dao包下的包有类及方法都进行增强 *.cn.alibaba.spring.dao.*.*(..) 对dao包及其子包下的包有类及方法都进行增强 * cn.itcast.spring.dao..*.*(..) 刚开始接触’AOP`面向切面编程的思想可能会很理解，这个需要结合动态代理的例子反复琢磨，一旦想明白就会觉得很简单，就像面向对象的思想一样。","categories":[{"name":"spring","slug":"spring","permalink":"https://www.chenende.top/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.chenende.top/tags/spring/"}]},{"title":"java范型使用总结","slug":"java","date":"2019-04-24T12:03:50.000Z","updated":"2019-05-09T20:58:56.220Z","comments":true,"path":"2019/04/24/java/","link":"","permalink":"https://www.chenende.top/2019/04/24/java/","excerpt":"前言范型只在编译时起作用，生成class的过程中会被擦除替换成具体的某个对象。范型常用于设计模式，为java开发提供遍历，使代码简洁提高开发效率。范型分为范型class和范型方法，本章我们来学习两者的使用和区别及范型的范围限定。 范型class通俗的讲将范型标识加在class的定义上，这种类型的范型被称为class范型，首先我们先来了解一下class范型的定义： public class Test&lt;T&gt; { private T data; public T getData() { return data; } public void setData(T data) { this.data = data; } }","text":"前言范型只在编译时起作用，生成class的过程中会被擦除替换成具体的某个对象。范型常用于设计模式，为java开发提供遍历，使代码简洁提高开发效率。范型分为范型class和范型方法，本章我们来学习两者的使用和区别及范型的范围限定。 范型class通俗的讲将范型标识加在class的定义上，这种类型的范型被称为class范型，首先我们先来了解一下class范型的定义： public class Test&lt;T&gt; { private T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } 在类名后面使用&lt;T&gt;标识类中使用了范型参数，在使用的时候直接用T代码对象类型即可，其中T可以是任意字符，且在类中声明定义以后使用的时候必须保持一致。 范型接口 在接口中声明范型，实现类未声明类型的情况下也要做范型声明： interface test&lt;T&gt;{ public void get(T abc); } class test2 &lt;T&gt; implements test&lt;T&gt;{ @Override public void get(T abc) { } } 声明实参的写法 class test2 implements test&lt;String&gt;{ @Override public void get(String abc) { } } 方法级别的范型范型的定义位置不在类的开头，而在方法中，这种形式的范型被称这为方法级别的范型 public class Test { public &lt;T&gt; T get(T data){ return data; } } 注意&lt;T&gt;代表定义范型，可以有多个即&lt;T,E,W&gt;,直接使用不能带&lt;&gt;,在入参中&lt;T&gt; data这种形式是错误的。 使用的时候无需声明类型，直接传参即可 public class Test { public static &lt;T&gt; T get(T data){ return data; } public static void main(String[] args) { String abc = get(&quot;abc&quot;); System.out.println(abc); } } 范型的通配符首先看一下面的代码 class Demo{ public void get(Test&lt;Integer&gt; test){ } 前面我们讲过方法中的入参中是不能带范型的，上面代码的入参中已经明确定义了Test中使用的范型类型是Integer,在使用的时候能不能用Integer的父类Number呢？即将入参替换成Test&lt;Number&gt; test?答案是不能。 在这种情况下我们就要用到范型通配符？,首先需要明确的是？并不代表未知类型，可以理解成所有对象的父类即Object,它是已知的定义。 所以只要我们将上述代码中的Test&lt;Integer&gt;替换成Test&lt;?&gt;即可，在使用的时候随便使用哪种类型都可以。 public static void main(String[] args) { Demo demo = new Demo(); Test&lt;String&gt; t = new Test(); demo.get(t); } 范型范围限定在使用通配符的情况下以继承关系为范围进行限定： &lt;? extends Number&gt;,意思是限定范围为Number及其子类 &lt;? super Integer&gt;,意思是限定范围为Integer及其父类 需要注意的是范围限定是在范型定义的位置加的，不可以在其它位置定义。更多内容请参考java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一","categories":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.chenende.top/tags/java/"}]},{"title":"springboot使用@Valid校验参数","slug":"springBoot05","date":"2019-04-21T01:25:55.000Z","updated":"2019-05-09T20:58:56.448Z","comments":true,"path":"2019/04/21/springBoot05/","link":"","permalink":"https://www.chenende.top/2019/04/21/springBoot05/","excerpt":"前言在controller层使用sprongboot自带的注解@Vaild或@Vaildated对接收到的对象进行参数校验，避免繁锁的代码开发，下面我们就一起来学习它们的使用吧。 校验规则注解 在使用@Vaild之前我们先来了解一下相关的校验规则注解都有哪些： 引用：首先@NotNull判定是否为空，然后@valid进行级联校验 数值：@NotNull判断是否为空， 使用@size/@Max/@Min进行大小的控制 日期：@NotNull校验是否为空 @DateTimeFormat结合jode可以固定日期的格式 对于日期的范围 注解解决不了 需要写方法判断了 日期类型输入纯文本数字也是可以通过的 值得注意 字符串：使用@NotBlank,而不是@NotNull、@NotEmpty，@NotBlan是2者的结合；使用@Length限制长度 对于其输入的具体内容的控制 目前没有好办法 @NotEmpty 用在集合类上面 不能为null，而且长度必须大于0 (&quot; &quot;,&quot; &quot;) @NotBlank 用在String上面 只能作用在String上，不能为null，而且调用trim()后，长度必须大于0 (&quot;test&quot;) 即：必须有实际字符 @NotNull 用在基本类型上 不能为null，但可以为empty (&quot;&quot;,&quot; &quot;,&quot; &quot;) 限制 说明 @Null 限制只能为null @NotNull 限制必须不为null @AssertFalse 限制必须为false @AssertTrue 限制必须为true @DecimalMax(value) 限制必须为一个不大于指定值的数字 @DecimalMin(value) 限制必须为一个不小于指定值的数字 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction @Future 限制必须是一个将来的日期 @Max(value) 限制必须为一个不大于指定值的数字 @Min(value) 限制必须为一个不小于指定值的数字 @Past 限制必须是一个过去的日期 @Pattern(value) 限制必须符合指定的正则表达式 @Size(max,min) 限制字符长度必须在min到max之间 @Past 验证注解的元素值（日期类型）比当前时间早 @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） @NotBlank 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格 @Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式","text":"前言在controller层使用sprongboot自带的注解@Vaild或@Vaildated对接收到的对象进行参数校验，避免繁锁的代码开发，下面我们就一起来学习它们的使用吧。 校验规则注解 在使用@Vaild之前我们先来了解一下相关的校验规则注解都有哪些： 引用：首先@NotNull判定是否为空，然后@valid进行级联校验 数值：@NotNull判断是否为空， 使用@size/@Max/@Min进行大小的控制 日期：@NotNull校验是否为空 @DateTimeFormat结合jode可以固定日期的格式 对于日期的范围 注解解决不了 需要写方法判断了 日期类型输入纯文本数字也是可以通过的 值得注意 字符串：使用@NotBlank,而不是@NotNull、@NotEmpty，@NotBlan是2者的结合；使用@Length限制长度 对于其输入的具体内容的控制 目前没有好办法 @NotEmpty 用在集合类上面 不能为null，而且长度必须大于0 (&quot; &quot;,&quot; &quot;) @NotBlank 用在String上面 只能作用在String上，不能为null，而且调用trim()后，长度必须大于0 (&quot;test&quot;) 即：必须有实际字符 @NotNull 用在基本类型上 不能为null，但可以为empty (&quot;&quot;,&quot; &quot;,&quot; &quot;) 限制 说明 @Null 限制只能为null @NotNull 限制必须不为null @AssertFalse 限制必须为false @AssertTrue 限制必须为true @DecimalMax(value) 限制必须为一个不大于指定值的数字 @DecimalMin(value) 限制必须为一个不小于指定值的数字 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction @Future 限制必须是一个将来的日期 @Max(value) 限制必须为一个不大于指定值的数字 @Min(value) 限制必须为一个不小于指定值的数字 @Past 限制必须是一个过去的日期 @Pattern(value) 限制必须符合指定的正则表达式 @Size(max,min) 限制字符长度必须在min到max之间 @Past 验证注解的元素值（日期类型）比当前时间早 @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） @NotBlank 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格 @Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 更多可参考：校验规则详解springboot 使用校验框架validation校验 校验规则注解的使用上面的规则注解需要加在实体类的成员字段上，例如： public class User implements Serializable { private Long id; @NotBlank(message = &quot;用户名不能为空&quot;) private String name; @NotNull(message = &quot;性别不能为空&quot;) private Integer sex; @NotNull(message = &quot;年龄不能为空&quot;) private Integer age; @NotBlank(message = &quot;地址不能为空&quot;) private String address; ... 然后在Controller的方法中加上@Vaild或@Vailted: @CrossOrigin @RequestMapping(&quot;/register&quot;) @ResponseBody public Result&lt;String&gt; register(@Validated User user , BindingResult results) { ... } 另外必须结合BindingResult results使用,使用results.hasErrors()可判断是否存在错误信息，该对象会获取到相关的错误信息（上一步在实体类中定义的）， 在代码中通过results.getFieldError().getDefaultMessage()从BindingResult中拿到错误信息可向前端返回，如果不使用该对象，@Vaild会将异常直接抛出，程序将 停止运行。 @CrossOrigin @RequestMapping(&quot;/register&quot;) @ResponseBody public Result&lt;String&gt; register(@Validated User user , BindingResult results) { //判断校验是否通过 if (results.hasErrors()) { //从BindingResult中获取错误信息 String errorMsg = results.getFieldError().getDefaultMessage(); return Result.isError(&quot;PARAM_ERROR&quot;,errorMsg); } System.out.print(user); return userService.addUser(user); } @Vaild和@Vaildated区别简单来说，如果不存在嵌套校验的话，即类中存在引用类型的成员变量，而那个引用类型中成员变量也需要校验。两者的作用是一样的，用哪一个都成，如上面给出的user类，就不存在嵌套关系。反之则需要使用@Vaild。 更多请参考：参数验证 @Validated 和 @Valid 的区别","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/tags/springboot/"}]},{"title":"springboot整合vue","slug":"springBoot04","date":"2019-04-20T16:22:48.000Z","updated":"2019-05-09T20:58:56.496Z","comments":true,"path":"2019/04/21/springBoot04/","link":"","permalink":"https://www.chenende.top/2019/04/21/springBoot04/","excerpt":"前言在前面章节vue跨域请求的基础上，本章我们将开发好的vue页面打包放在springboot项目中。 打包vue项目在项目根目录下使用npm run build执行打包操作，生成dist文件夹，里面有static静态资源和index.html文件。","text":"前言在前面章节vue跨域请求的基础上，本章我们将开发好的vue页面打包放在springboot项目中。 打包vue项目在项目根目录下使用npm run build执行打包操作，生成dist文件夹，里面有static静态资源和index.html文件。 index.html文件内容： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=utf-8&gt; &lt;meta name=viewport content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;upload&lt;/title&gt; &lt;link href=/static/css/app.81d32681a36d616005bc9cd5f8064bda.css rel=stylesheet&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=app&gt;&lt;/div&gt; &lt;script type=text/javascript src=/static/js/manifest.2ae2e69a05c33dfc65f8.js&gt;&lt;/script&gt; &lt;script type=text/javascript src=/static/js/vendor.e59b4e3e5cb42ff728b8.js&gt;&lt;/script&gt; &lt;script type=text/javascript src=/static/js/app.1a1aacd9317792b9d072.js&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 页面中的内容全部是通过js加载生成的，如果js加载失败的话就会出现空白页面的情况。 在springboot项目中添加vue页面将dist目录下的所有文件复制到springboot项目中resource/static文件夹下，注意只能有一个static文件夹，将vue中的静态资源（js,css,image,index.html）都统一放在static文件夹下。 完成上述操作后启动项目，会出现无法加载js,css文件，页面一片空白。 解决springboot无法加载静态资源的问题springboot已经默认设置了各种资源的加载路径，在springboot中约定大于配置，当然对静态资源也有默认的约定。 Spring Boot 默认将 /** 所有访问映射到以下目录： classpath:/static classpath:/public classpath:/resources classpath:/META-INF/resources 所以大家在访问静态资源时就不需要加/static,/public这些前缀了 打开vue项目的index.html页面： 去掉所有引用的静态资源路径中的/static即可，重新运行项目，页面正常显示。 修改vue配置，使用生成的文件引用路径中不包含/static 打开vue项目中config/index.js文件，修改build下的assetsSubDirectory,去掉后面的static即可。 重新打包项目生成的index.html的引用路径中就没有/static。 springboot跨域名请求 在需要开启跨域请求的controller方法上添加@CrossOrigin即可 @CrossOrigin @RequestMapping(&quot;/login&quot;) @ResponseBody public Result login(User user) { ... } 参考资料： springboot静态资源访问路径 IntelliJ IDEA+SpringBoot中静态资源访问路径陷阱：静态资源访问404 Spring Boot+Vue从零开始搭建系统（三）：项目前后端分离_实现简单登录demo","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/categories/springboot/"}],"tags":[{"name":"springboot整合vue","slug":"springboot整合vue","permalink":"https://www.chenende.top/tags/springboot整合vue/"}]},{"title":"springboot整合Mybatis","slug":"springBoot03","date":"2019-04-19T13:40:52.000Z","updated":"2019-05-09T20:58:56.280Z","comments":true,"path":"2019/04/19/springBoot03/","link":"","permalink":"https://www.chenende.top/2019/04/19/springBoot03/","excerpt":"前言springboot简化了springMVC+spring的配置，实现了「开箱即用」的效果。只需要核心配置文件application.properties中进行少量配置即可实现与其他框架的整合。 springboot整合MyBatis接着springboot分模块开发项目搭建问题总结的案例，在创建dao的时候我们已经选了mybatis和mysql的情况下springboot就已经将mybatis整合好了，我们只需在application.properties中配置一下数据库连接信息及mybatis的文件扫描位置即可。 1.添加配置信息 在application.properties中添加：","text":"前言springboot简化了springMVC+spring的配置，实现了「开箱即用」的效果。只需要核心配置文件application.properties中进行少量配置即可实现与其他框架的整合。 springboot整合MyBatis接着springboot分模块开发项目搭建问题总结的案例，在创建dao的时候我们已经选了mybatis和mysql的情况下springboot就已经将mybatis整合好了，我们只需在application.properties中配置一下数据库连接信息及mybatis的文件扫描位置即可。 1.添加配置信息 在application.properties中添加： spring: datasource: name: test url: jdbc:mysql://127.0.0.1:3306/test //改成你要连接的数据库名称 username: root password: root driver-class-name: com.mysql.jdbc.Driver filters: stat maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select &apos;x&apos; testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20 mybatis: mapperLocations: classpath:demo/demodao/mapper/*.xml //mapper.xml位置 typeAliasesPackage: demo.demodao.pojo //实体类的位置 #更多配置请参见：http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 其中mybatis的文件路径一定要正确，否则将找不到映射文件 2.在入口类中添加dao接口文件的位置 @SpringBootApplication @MapperScan(&quot;demo.demodao.mapper&quot;) //不配置的话service注入的mapper接口文件会找不到 public class DemoWebApplication { public static void main(String[] args) { SpringApplication.run(DemoWebApplication.class, args); } } 3.注意事项 在完成上述操作后，启动项目时会报错：找不到mapper接口文件对应的xml映射文件解决：项目中我们将mapper接口文件和对应的xml文件统一放在了src/java/main目录下，springboot在编译的时候默认是不会加载src目录下的xml文件的，所以需要指定xml文件的位置。 在dao项目的pom文件中添加： &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; 4.springBoot 加载自定义配置文件 通过@PropertySource+ @Value注解来加载 @Controller @RequestMapping(&quot;/demo&quot;) //告诉容器配置文件所在位置 @PropertySource(&quot;classpath:config/test.properties&quot;) public class UserController { @Resource private UserService userService; //使用@Vaule进行赋值 @Value(&quot;${errorCode}&quot;) private String errorCode; @Value(&quot;${errorMsg}&quot;) private String errorMsg; test.properties配置 errorCode=ID-IS-NULL errorMsg=id不能为空 配置application.properties读取test.properties文件，直接使用@Value注入 在application.properties中添加配置 spring: profiles: active: test 注意：必须修改配置文件名称为application-test.properties 在代码中直接使用@Value注入 @Controller @RequestMapping(&quot;/demo&quot;) //@PropertySource(&quot;classpath:config/application-test.properties&quot;) public class UserController { @Resource private UserService userService; @Value(&quot;${errorCode}&quot;) private String errorCode; @Value(&quot;${errorMsg}&quot;) private String errorMsg; ** 解决读取配置文件中文乱码问题： 如需了解更多可参考：Spring Boot加载配置文件 如有疑问可参考项目代码，也可在评论区留言。","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/categories/springboot/"}],"tags":[{"name":"springboot整合Mybatis","slug":"springboot整合Mybatis","permalink":"https://www.chenende.top/tags/springboot整合Mybatis/"}]},{"title":"springboot+Mybatis逆向工程","slug":"springBoot02","date":"2019-04-19T11:18:34.000Z","updated":"2019-04-23T03:16:56.629Z","comments":true,"path":"2019/04/19/springBoot02/","link":"","permalink":"https://www.chenende.top/2019/04/19/springBoot02/","excerpt":"前言Mybatis逆向工程是官方提供的用以简化开发的工具，在建好表的情况下只需简单配置就能自动生成pojo、mapper映射文件及dao接口文件 逆向工程配置1.在dao项目的resource目录下新那两个配置文件：generatorConfig.xml和config.properties generatorConfig.xml","text":"前言Mybatis逆向工程是官方提供的用以简化开发的工具，在建好表的情况下只需简单配置就能自动生成pojo、mapper映射文件及dao接口文件 逆向工程配置1.在dao项目的resource目录下新那两个配置文件：generatorConfig.xml和config.properties generatorConfig.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC “-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN” “http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!--添加数据库的连接jar包的位置，在项目的左边最下的external libraries中找到复制全路径--&gt; &lt;properties resource=&quot;config.properties&quot;/&gt; &lt;classPathEntry location=&quot;/home/chenende/.m2/repository/mysql/mysql-connector-java/8.0.15/mysql-connector-java-8.0.15.jar&quot;/&gt; &lt;context id=&quot;test&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;!--支持序列化--&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;&gt;&lt;/plugin&gt; &lt;!-- &lt;plugin type=&quot;${mapper.plugin}&quot;&gt; &lt;property name=&quot;mappers&quot; value=&quot;${mapper.Mapper}&quot;/&gt; &lt;property name=&quot;forceAnnotation&quot; value=&quot;${mapper.forceAnnotation}&quot; /&gt; &lt;/plugin&gt; --&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot; connectionURL=&quot;${jdbc.url}&quot; userId=&quot;${jdbc.user}&quot; password=&quot;${jdbc.password}&quot;&gt; &lt;!--MySQL 不支持 schema 或者 catalog 所以需要添加这个--&gt; &lt;!--参考 : http://www.mybatis.org/generator/usage/mysql.html--&gt; &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt; &lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=&quot;${targetModelPackage}&quot; targetProject=&quot;${targetJavaProject}&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=&quot;${targetXMLPackage}&quot; targetProject=&quot;${targetResourcesProject}&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator targetPackage=&quot;${targetMapperPackage}&quot; targetProject=&quot;${targetJavaProject}&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!--全部表参与逆向工程--&gt; &lt;!--以下example为false，表示不会生成example类，否则将自动生成example类--&gt; &lt;!--&lt;table schema=&quot;&quot; tableName=&quot;%&quot;--&gt; &lt;!--enableCountByExample=&quot;false&quot;--&gt; &lt;!--enableUpdateByExample=&quot;false&quot;--&gt; &lt;!--enableDeleteByExample=&quot;false&quot;--&gt; &lt;!--enableSelectByExample=&quot;false&quot;--&gt; &lt;!--selectByExampleQueryId=&quot;false&quot;&gt;--&gt; &lt;!--&lt;/table&gt;--&gt; &lt;!--指定某些表参与逆向工程--&gt; &lt;table schema=&quot;test&quot; tableName=&quot;user&quot; &gt;&lt;/table&gt; &lt;!--enableCountByExample=&quot;false&quot;--&gt; &lt;!--enableUpdateByExample=&quot;false&quot;--&gt; &lt;!--enableDeleteByExample=&quot;false&quot;--&gt; &lt;!--enableSelectByExample=&quot;false&quot;--&gt; &lt;!--selectByExampleQueryId=&quot;false&quot;&gt;--&gt; &lt;!--&lt;/table&gt;--&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; config.properties # 数据库配置 jdbc.driverClass=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test jdbc.user=root jdbc.password=root # 通用Mapper固定配置 mapper.plugin=tk.mybatis.mapper.generator.MapperPlugin mapper.Mapper=tk.mybatis.mapper.common.Mapper mapper.forceAnnotation=true # 生成文件保存位置 targetModelPackage=demo.demodao.pojo targetXMLPackage=demo.demodao.mapper targetMapperPackage=demo.demodao.mapper targetJavaProject=src/main/java targetResourcesProject=src/main/java 只需要修改config.properties中的配置信息即可，注意生成文件保存位置不能有误。另外，MySQL 不支持 schema 或者 catalog 所以需要添加：&lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;否则如果不同数据库有同名的表，生成结果可能并非你所指定数据库中的。MyBatis Generator 生成器把其他数据库的同名表生成下来的问题 文件保存位置无需手动创建目录，如果文件不存在会自动创建。 2.完成上述操作后,从maven插件中找到plugins中找到添加的mybatis工程，双击即可完成代码生成","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/categories/springboot/"}],"tags":[{"name":"Mybatis逆向工程","slug":"Mybatis逆向工程","permalink":"https://www.chenende.top/tags/Mybatis逆向工程/"}]},{"title":"springboot分模块开发项目搭建问题总结","slug":"springBoot01","date":"2019-04-19T09:35:07.000Z","updated":"2019-05-24T12:40:07.076Z","comments":true,"path":"2019/04/19/springBoot01/","link":"","permalink":"https://www.chenende.top/2019/04/19/springBoot01/","excerpt":"前言详情搭建过程本文不再赘述，可根据提示链接进行了解。主要针对搭建过程中遇到的问题进行总结，希望能帮到各位。 springboot分模块搭建请帮教搭建步骤详解 问题总结启动的时候提示找不到依赖的jar包例如：web依赖service，可能会遇到找不到service jar包的错误，这是因为没有对项目进行打包，项目在启动后从本地仓库中找不到所依赖的jar包。maver工程在本地启动之前必须将工程打包发布到本地仓库。","text":"前言详情搭建过程本文不再赘述，可根据提示链接进行了解。主要针对搭建过程中遇到的问题进行总结，希望能帮到各位。 springboot分模块搭建请帮教搭建步骤详解 问题总结启动的时候提示找不到依赖的jar包例如：web依赖service，可能会遇到找不到service jar包的错误，这是因为没有对项目进行打包，项目在启动后从本地仓库中找不到所依赖的jar包。maver工程在本地启动之前必须将工程打包发布到本地仓库。 在对项目打包的时候提示找不到入口mainspringboot项目中只能有一个main文件，即项目入口文件，在搭建过程文档中虽然删除了其它模块中的入口文件，但还需要在pom文件中配置一下，告诉容器项目使用的入口文件在什么位置。 因此需要在web工程的pom文件中添加： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定该Main Class为全局的唯一入口 --&gt; &lt;mainClass&gt;demo.DemoWebApplication&lt;/mainClass&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt;&lt;!--可以把依赖的包都打包到生成的Jar包中--&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 另外还需要在parent项目的pom文件中添加mave打包插件，不需要打包的工程无需添加 &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;${java.version}&lt;/source&gt; &lt;target&gt;${java.version}&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; //不进行单元测试 &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 依赖的parent项目路径异常在自动生成的pom文件中默认的parent坐标如下： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 修改成 &lt;parent&gt; &lt;groupId&gt;demo&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; 注意&lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;必须有，问题就出在这里。 springboot正常启动，但页面访问404绝大多数是访问路径的问题，需要注意的是如果Controller没有使用@RequestMapping(&quot;/demo&quot;)，访问时无需添加项目名称，即：http:localhost:8080 即可， 以上是我在搭建项目时遇到的问题，注意：重新找包时一定要使用clean命令清理一下，然后重新install，另外入口文件的位置一定要移动到上级目录下","categories":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://www.chenende.top/tags/springboot/"}]},{"title":"vue实战之（二十五） 路由传值","slug":"vue25","date":"2019-03-24T21:52:14.000Z","updated":"2019-04-23T22:13:09.247Z","comments":true,"path":"2019/03/25/vue25/","link":"","permalink":"https://www.chenende.top/2019/03/25/vue25/","excerpt":"","text":"前言假设有两个页面A和B，从A页面路由中转到B页面的时候我想把A页面中的用户信息带到B页面，该如何实现呢？这个就用到了今天我们要讲的知识点路由传值。 功能实现共有两种方式可实现路由传值 第一种传递参数 – this.$router.push({path: ‘ 路由 ‘, query: {key: value}}) 参数取值 – this.$route.query.key 使用这种方式，传递参数会拼接在路由后面，出现在地址栏 第二种传递参数 – this.$router.push({name: ‘ 路由的name ‘, params: {key: value}}) 参数取值 – this.$route.params.key 使用这种方式，参数不会拼接在路由后面，地址栏上看不到参数 由于动态路由也是传递params的，所以在 this.$router.push() 方法中 path不能和params一起使用，否则params将无效。需要用name来指定页面。 即通过路由配置中的name属性访问 需要注意的是取值的时候一定先做判空处理","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（二十四） 路由拦截","slug":"vue24","date":"2019-03-23T16:05:19.000Z","updated":"2019-05-09T20:58:56.120Z","comments":true,"path":"2019/03/24/vue24/","link":"","permalink":"https://www.chenende.top/2019/03/24/vue24/","excerpt":"前言在前后端分离的项目中，页面跳转是由前端来完成的，前端开发也会涉及权限校验，例如在后台管理系统中直接在地址栏中输入首页地址，在没有登录的情况下是不能进行路由跳转的。本章节我们就一起来学习一下如何实现路由拦截。 案例实现vue中的路由简单来说就是将页面跟访问路径绑定在一起，这样才能在地址栏中输入地址后显示相对应的页面。vue中路由的配置是在src/router目录下的index.js页面完成的。","text":"前言在前后端分离的项目中，页面跳转是由前端来完成的，前端开发也会涉及权限校验，例如在后台管理系统中直接在地址栏中输入首页地址，在没有登录的情况下是不能进行路由跳转的。本章节我们就一起来学习一下如何实现路由拦截。 案例实现vue中的路由简单来说就是将页面跟访问路径绑定在一起，这样才能在地址栏中输入地址后显示相对应的页面。vue中路由的配置是在src/router目录下的index.js页面完成的。 export default new Router({ routes: [ { path: &apos;/&apos;, // 访问路径 redirect: &apos;/login&apos; //中转到指定路径 }, { //嵌套路由 path: &apos;/index&apos;, name: &apos;BlogIndex&apos;, //路由名称 component: BlogIndex, //组件名称 meta: {title: &apos;主页&apos;, requireAuth: true}, children: [ { path: &apos;/index/userManage&apos;, component: resolve =&gt; require([&apos;../home/components/UserManage&apos;], resolve), meta: {title: &apos;用户管理&apos;, requireAuth: true} } ] }, { path: &apos;/manage&apos;, redirect: &apos;/login&apos; }, { path: &apos;/login&apos;, name: &apos;BlogLogin&apos;, component: BlogLogin }, { path: &apos;/register&apos;, name: BlogRegister, component: BlogRegister } ] }) 要实现路由拦截必须在要拦截的路径中添加参数：requireAuth: true 拦截逻辑 完成上面配置后剩下的就需要我们编写拦截逻辑了 我们的需求是只有在登录的情况下才能访问index页面及其它的操作页面。整个系统只有登录和注册页面是不需要拦截的。 在弄明白需求后，我们应该思考如何区分是否已登录。很显示登录这一操作是需要跟后台交互的，登录成功后我们手里是有用户名的，那么就可以以是否有用户名来区分。理清思路后我们就应该考虑该怎么保存用户名，答案是将其作为全局数据保存在store中。 如果访问路径是/login或/register的话就不需要拦截； 如果当前用户名为空，那么就需要拦截。 store知识点回顾 对vuex不太熟悉的同学可以翻阅我前面的笔记。我们来做一下简单的回顾： vuex可以看作是一个全局的存储公共数据的数据池。store中存储着当前的数据，还有actions和mutations芨其它一些状态，是用来管理改变中的数据状态的，可以在这些状态里定义加工数据，而store中存储的就是最终的结果。 下面是最基本的store配置 import Vue from &apos;vue&apos; import Vuex from &apos;vuex&apos; Vue.use(Vuex) try { if (localStorage.userName) { var defaultUserName = localStorage.userName } } catch (e) { } export default new Vuex.Store({ state: { username: defaultUserName || &apos;游客&apos; //username 就是存放在共享池里的一个数据 }, actions: { changeCity (ctx, userName) { ctx.commit(&apos;changeCity&apos;, userName) } }, mutations: { changeCity (state, userName) { state.username = userName try { localStorage.userName = userName } catch (e) { } } } }) 相关操作： 1. 往`store`中存数据 第一步：导包,; `import {mapMutations} from &apos;vuex&apos;` 第二步：添加数据; 12345method () &#123; this.changeCity('游客') //方法名可自定义&#125;//下面的代码写的方法外 ...mapMutations(['changeCity']) 2. 从`store`中取数据 第一步：导包; `import {mapState} from &apos;vuex&apos; ` 第二步：获取数据; `...mapState([&apos;username&apos;]) // 注意数据名称要跟store中的保持一致` 第三步：在`DOM`中使用获取的数据 `&lt;span&gt;{{this.username}}&lt;/span&gt; //注意是两层花括号` 路由拦截实现 接着我们就来编写拦截逻辑, 在登录后我们将用户名存储到store中，退出登录时再把store中的用户设为空。完成数据的存储后我们还需要在main.js中编写路由拦截逻辑： router.beforeEach((to, from, next) =&gt; { if (to.path === &apos;/login&apos; || to.path === &apos;/register&apos;) { next() } else { if (store.state.username === &apos;游客&apos;) { next({path: &apos;/login&apos;}) } else { next() } } }) 注意是单独作为一个代码块写在最后面的，不要放在已有代码{}内部 我们来了解一下其中涉及到的知识点： 路由验证： 路由验证用 router.beforeEach( (to, from, next) =&gt; { } 这里的to代表要去的路由指向，from是指从哪个路由跳转过来的，next是判断操作，如果为空，表示放行。 比如：下一跳的路由为‘/watchHouse’或者‘/AgentMsg’ ，如果没有登录的话，通过代码 next ({path: ‘/login’}) 跳转到登录的界面。代码如下： if (!store.state.user &amp;&amp; (to.path === &apos;/watchHouse&apos; || to.path === &apos;/AgentMsg&apos;)) { next({ path: &apos;/login&apos; }) } 比如：在路由‘/my’下，要跳往 ‘/ToolCompute’，如果没有登录的话，跳转到登录页面。代码如下： if (!store.state.user &amp;&amp; (from.path === &apos;/my&apos;) &amp;&amp; (to.path === &apos;/ToolCompute&apos;)) { next({ path: &apos;/login&apos; }) } 返回上一次路由： this.$router.back(-1) 想要了解更多请点这里","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（二十三）使用`axios`发送`get`和`post`请求","slug":"vue23","date":"2019-03-22T16:05:19.000Z","updated":"2019-04-23T03:05:30.973Z","comments":true,"path":"2019/03/23/vue23/","link":"","permalink":"https://www.chenende.top/2019/03/23/vue23/","excerpt":"前言发送ajax请求应该说是学习前端的基本功，今天我们就来总结一下vue框架中使用axios发送get和post请求。 get请求 基本格式123456789101112axios.get(&apos;/user&apos;, &#123; //params参数必写 , 如果没有参数传&#123;&#125;也可以 params: &#123; id: 12345， name: user &#125;&#125;).then(function (res) &#123; console.log(res);&#125;).catch(function (err) &#123; console.log(err);&#125;);","text":"前言发送ajax请求应该说是学习前端的基本功，今天我们就来总结一下vue框架中使用axios发送get和post请求。 get请求 基本格式123456789101112axios.get(&apos;/user&apos;, &#123; //params参数必写 , 如果没有参数传&#123;&#125;也可以 params: &#123; id: 12345， name: user &#125;&#125;).then(function (res) &#123; console.log(res);&#125;).catch(function (err) &#123; console.log(err);&#125;); 需要注意的是参数部分必须这么写{params: {key: value}},不需要传参的话：{}，也可以省略不写，否则无法传参 post请求var formData=new FormData(); formData.append(&apos;user&apos;,123456); formData.append(&apos;pass&apos;,12345678); axios.post(&quot;/notice&quot;,formData) .then((res) =&gt; {return res}) .catch((err) =&gt; {return err}) 需要注意的是：在使用data中定义的参数接收返回数据的时候，需要在方法中重新定义this指向,var _this = this否则会出现接收不到的情况。 data () { return { tableData: [], } } methods: { getData () { var _this = this// 这个非常重要，没有话接收不到参数 this.$axios.get(&apos;/getUsers&apos;) .then(function (response) { if (response.data.success) { _this.tableData = response.data.data console.log(_this.tableData) _this.$toast(&apos;数据加载完成&apos;, true, 3000) } var errorMsg = response.data.errorMes _this.$toast(errorMsg, true, 3000) }).catch(function (error) { _this.$toast(error, false, 3000) }) } } 更多可参考点击这里 全局引入axios在项目中安装axios,使用命令：npm install axios --save 在main.js中添加配置 var axios = require(&apos;axios&apos;) // 设置请求格式 axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos; // 全局请求路径 axios.defaults.baseURL = &apos;http://localhost:8088/demo&apos; // 将API方法绑定到全局 Vue.prototype.$axios = axios 在页面中直接使用this.$axios.get或this.$axios.post 局部引入axiosimport axios from &#39;axios&#39;; 在页面中直接使用axios.get或axios.post","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"$axios","slug":"axios","permalink":"https://www.chenende.top/tags/axios/"}]},{"title":"vue实战之（二十二） ElementUI组件","slug":"vue22","date":"2019-03-21T23:05:19.000Z","updated":"2019-04-23T03:05:30.853Z","comments":true,"path":"2019/03/22/vue22/","link":"","permalink":"https://www.chenende.top/2019/03/22/vue22/","excerpt":"前言ElementUI是由饿了么开发团队提供的基于vue2.0的前端组件，它对常用的html组件进行了封装，是目前使用最广泛的vue组件之一，为基于框架开的前端开发提供了便利。类似于easyUI、bootstrap。下面我们就来使用它开发一个常见的后台管理系统页面，结合案例一起来学习一下ElementUI的使用。 案例实现首先一起来看一下最终完成的页面效果","text":"前言ElementUI是由饿了么开发团队提供的基于vue2.0的前端组件，它对常用的html组件进行了封装，是目前使用最广泛的vue组件之一，为基于框架开的前端开发提供了便利。类似于easyUI、bootstrap。下面我们就来使用它开发一个常见的后台管理系统页面，结合案例一起来学习一下ElementUI的使用。 案例实现首先一起来看一下最终完成的页面效果 ElementUI的安装在项目根目录下使用命令npm i element-ui -S,也可局部安装指定组件。 安装完成后在main.js中全局引入 import ElementUI from &apos;element-ui&apos; import &apos;element-ui/lib/theme-chalk/index.css&apos; Vue.use(ElementUI) 相关组件代码的获取首先我们可以点击打开ElementUI官网教程，上面图文并茂给出了所有可用的示例，只可惜没有什么帮助说明，只是一些示例代码和API说明，对于一些前端基础不是很好的后端同学来说，一开始的使用是充满波折的。 今天我们以NavMenu这个组件为例带大家学习一下ElementUI的基本使用，在学习的过程中可以对照官方文档。 在每个示例图下方都有一个显示代码的文字，点击它就可打开对应的代码。复制全部代码后在项目中创建.vue文件，然后粘贴进去。需要注意的是官方提供的代码没有&lt;templent&gt;标签，export defult中也缺少name属性，需要我们手动添加。 使用起来就是这么简单，一般情况下立马就能看到效果，也不需要做其它设置，如果出现无法显示的情况，百度也找不到答案（几乎没有遇到），那就可以百分百确定是你自己写的代码的问题了。 在项目中的应用首先看一下引入到项目后的代码： &lt;template&gt; &lt;div&gt; &lt;el-radio-group v-model=&quot;isCollapse&quot; style=&quot;margin-bottom: 20px;margin-right: 0&quot;&gt; &lt;el-radio-button :label=&quot;false&quot;&gt;展开&lt;/el-radio-button&gt; &lt;el-radio-button :label=&quot;true&quot;&gt;收起&lt;/el-radio-button&gt; &lt;/el-radio-group&gt; &lt;el-menu :default-active=&quot;$route.path&quot; class=&quot;el-menu-vertical-demo&quot; background-color=&quot;#EDFCFF&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; :collapse=&quot;isCollapse&quot; router&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;基本操作&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;/index&quot;&gt;首页&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/index/userManage&quot;&gt;用户管理&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-submenu index=&quot;1-5&quot;&gt; &lt;span slot=&quot;title&quot;&gt;选项4&lt;/span&gt; &lt;el-menu-item index=&quot;1-4-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;el-menu-item index=&quot;2&quot;&gt; &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;导航二&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3&quot; disabled&gt; &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;导航三&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;4&quot;&gt; &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot;&gt;导航四&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .el-menu-vertical-demo:not(.el-menu--collapse) { width: 200px; min-height: 400px; } &lt;/style&gt; &lt;script&gt; export default { data () { return { isCollapse: false } }, methods: { handleOpen (key, keyPath) { console.log(key, keyPath) }, handleClose (key, keyPath) { console.log(key, keyPath) } } } &lt;/script&gt; 要想实现路由效果，必须在&lt;el-menu&gt;标签中加入router属性值，它赞同于router=true,是开启路由的意思。 另外需要修改:default-active=&quot;$route.path&quot;，在路由到指定页面后菜单栏会高亮显示对应的标签。 接着是修改&lt;el-menu-item&gt;标签，将其中的index改为对应的访问地址： &lt;el-menu-item index=&quot;/index&quot;&gt;首页&lt;/el-menu-item&gt; 官方文档中还有很多其它属性，可以按需添加。 小结掌握ElementUI可以大大提升前端的开发效率，还能使开出来的页面大气美观，小伙伴们快快动起手来学习吧！ 更多信息请参考ElementUI官网教程","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"ElementUI组件","slug":"ElementUI组件","permalink":"https://www.chenende.top/tags/ElementUI组件/"}]},{"title":"vue实战之（二十一） 自定义信息提示框","slug":"vue21","date":"2019-03-20T11:58:39.000Z","updated":"2019-04-23T03:05:30.805Z","comments":true,"path":"2019/03/20/vue21/","link":"","permalink":"https://www.chenende.top/2019/03/20/vue21/","excerpt":"前言信息提示框是前端开发中不可或缺的，今天我们就来一起创建vue信息提示框，来展示后台返回的错误信息。首先我们一起来看下最终开发好的样式：","text":"前言信息提示框是前端开发中不可或缺的，今天我们就来一起创建vue信息提示框，来展示后台返回的错误信息。首先我们一起来看下最终开发好的样式： 当返回的是错误信息时，信息框的颜色是红色的 当返回的是成功的信息时，信息框的颜色是绿色的 案例实现 1.首先在\\src目录下创建文件夹message，导入Message\\.vue文件，文件内容如下： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=&quot;wrap&quot; v-bind:class=&quot;isSuccess ? &apos;&apos; : &apos;fail&apos;&quot; v-if=&quot;showWrap&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;toast&apos; // mounted () &#123; // console.log(this.isSuccess) // &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt; .wrap position: fixed; left: 50%; top:50% transform: translate(-50%,-50%); color: #06b54d; background #efffee border-radius 5% line-height 50px text-align center opacity 0.8 padding 0 100px .fail color: #efffee; background: #ee4475&lt;/style&gt; 在&lt;\\div\\&gt;中用了三元表达式来动态添加\\class样式，以实现消息框根据返回的信息而展示不同颜色 vue 三元判断绑定class 1、数组形式 课程 注意：数组中的classify如果不加引号的话，代表的是data中的一项，并不是类名，将classify加上双引号，变成字符串就可以变成类名 2、字符串拼接 课程 注意：active前要加一个空格（必须有），字符串拼接时，两个字符串之间要有空格 3、绑定class的方式 v-bind:class=”index==searchIndex ? ‘typeselect’ : ‘’” 2.在src/message中导入\\index.\\js文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536import vue from 'vue'// 这里就是我们刚刚创建的那个静态组件import toastComponent from './Message.vue'// 返回一个 扩展实例构造器const ToastConstructor = vue.extend(toastComponent)// 定义弹出组件的函数 接收3个参数, 要显示的文本、请求是否成功 和 显示时间function showToast (text, isSuccess, duration = 2000) &#123; const toastDom = new ToastConstructor(&#123; el: document.createElement('div'), data () &#123; return &#123; isSuccess: isSuccess, text: text, showWrap: true, showContent: true &#125; &#125; &#125;) document.body.appendChild(toastDom.$el) // 提前 250ms 执行淡出动画(因为我们再css里面设置的隐藏动画持续是250ms) setTimeout(() =&gt; &#123; toastDom.showContent = false &#125;, duration - 1250) // 过了 duration 时间后隐藏整个组件 setTimeout(() =&gt; &#123; toastDom.showWrap = false &#125;, duration)&#125;// 注册为全局组件的函数function registryToast () &#123; // 将组件注册到 vue 的 原型链里去, // 这样就可以在所有 vue 的实例里面使用 this.$toast() vue.prototype.$toast = showToast&#125;export default registryToast 在上面文件中主要干了两件事，1.定义定义弹出组件的函数；2.将函数放进全局组件如需添加入参，只需要\\data\\中加入相同名称的参数，并将入参赋值给它即可。在Messages中使用的时候直接用\\this\\.+参数名称就能取到对应的值。 接着需要在主文件件\\main.\\js中全局加载我们自定义的插件只需添加以下代码： toastRegistry from './message/index'12// 这里也可以直接执行 toastRegistry()Vue.use(toastRegistry) 完成上面的配置后，在所有页面中都可以直接使用 this.$toast(text, isSuccess, duration) 来使用我们定义的消息提示框了。 this.$toast(&apos;注册成功！&apos;, true, 3000) 想要知道更多可以参考：vue全局提示框组件","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（二十）跨域ajax请求","slug":"vue20","date":"2019-03-19T12:58:39.000Z","updated":"2019-04-23T03:05:30.917Z","comments":true,"path":"2019/03/19/vue20/","link":"","permalink":"https://www.chenende.top/2019/03/19/vue20/","excerpt":"前言在前后端分离的情况下，前后端的访问地址是不一样的，这就涉及到了跨域请求，即域名一不样，端口不一样。这就需要在vue中进行相关配置来实现跨域请求。 功能实现1.全局导入axios此前我们在使用axiox的时候是直接在页面中导入的，如果其它页面也需要使用的话就需要重新再导入。全局导入的话就只需导入一次，所有页面就都可以使用了。 所谓全局导入就是在入口文件main.js中导入axios,其中用到了es6的require函数，它和import功能类似都有导入功能，requier是全局导入，运行时才执行，两者区别可参考点击查看 下面是具体配置：","text":"前言在前后端分离的情况下，前后端的访问地址是不一样的，这就涉及到了跨域请求，即域名一不样，端口不一样。这就需要在vue中进行相关配置来实现跨域请求。 功能实现1.全局导入axios此前我们在使用axiox的时候是直接在页面中导入的，如果其它页面也需要使用的话就需要重新再导入。全局导入的话就只需导入一次，所有页面就都可以使用了。 所谓全局导入就是在入口文件main.js中导入axios,其中用到了es6的require函数，它和import功能类似都有导入功能，requier是全局导入，运行时才执行，两者区别可参考点击查看 下面是具体配置： import Vue from &apos;vue&apos; import App from &apos;./App&apos; import router from &apos;./router&apos; import store from &apos;./store&apos; // 引用axios，并设置基础URL为后端服务api地址 var axios = require(&apos;axios&apos;) //为所有ajax请求绑定统一的访问地址 axios.defaults.baseURL = &apos;http://localhost:8080/demo&apos; // 将axios API方法绑定到全局 Vue.prototype.$axios = axios Vue.config.productionTip = false /* eslint-disable */ new Vue({ el: &apos;#app&apos;, router, store, components: { App }, template: &apos;&lt;App/&gt;&apos; }) 上面的配置其实就是将axios放进vue中,配置完成后，在页面中就可以直接使用this.$axios从vue中获取axios对象，使用其功能了。 2.通过配置开启跨域请求需要在config/index.js文件中进行配置： 即在proxyTable中添加以下内容： &apos;/demo&apos;: { target: &apos;http://localhost:8080&apos;, changeOrigin: true, pathRewrite: { &apos;^/demo&apos;: &apos;&apos; } } 其中/demo是上一步全局导入axios时设置的统一访问路径中的名称，一般为项目名称。可自定义。target表示要跨域请求的地址;changeOrigin:true表示是否开启跨域请求；pathRewrite中内容表示是否要替换以/demo开头的内容为指定的内容。 3.发送ajax请求在页面中编写click点击事件 &lt;template&gt; &lt;div&gt; &lt;blog-header&gt;&lt;/blog-header&gt; &lt;hr/&gt; &lt;div&gt; 用户名:&lt;input type=&quot;text&quot; v-model=&quot;loginInfoVo.username&quot; placeholder=&quot;请输入用户名&quot; /&gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; v-model=&quot;loginInfoVo.password&quot; placeholder=&quot;请输入密码&quot; /&gt; &lt;br/&gt; &lt;button v-on:click=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;br/&gt; 登录验证情况：&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot; v-model=&quot;responseResult&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;hr/&gt; &lt;blog-footer&gt;&lt;/blog-footer&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import blogHeader from &apos;@/components/common/BlogHeader.vue&apos; import blogFooter from &apos;@/components/common/BlogFooter.vue&apos; export default { name: &apos;BlogLogin&apos;, // blogHeader、blogFooter组件给申明到components里面然后在template里面使用 components: { blogHeader, blogFooter }, data () { return { loginInfoVo: { username: &apos;&apos;, password: &apos;&apos; }, responseResult: [] } }, methods: { login () { this.$axios .post(&apos;/login&apos;, //请求数据 { username: this.loginInfoVo.username, password: this.loginInfoVo.password }) .then(successResponse =&gt; { this.responseResult = JSON.stringify(successResponse.data) if (successResponse.data.code === 200) { this.$router.replace({path: &apos;/index&apos;}) } }) .catch(failResponse =&gt; {}) } } } &lt;/script&gt; 3.后端接收不到前端数据的问题在使用npm run dev开启项目，同时启动后端应用后，请求虽然成功，但会出现后端接收不到请求数据的情况，这是因为axios配置的问题。 1、在main.js里 设置配置，修改Content-Type 1axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 2.使用var params = new URLSearchParams();添加请求数据 123456789101112const url ='http://****你的接口****';var params = new URLSearchParams();params.append('key1', 'value1'); //你要传给后台的参数值 key/valueparams.append('key2', 'value2');params.append('key3', 'value3');this.$axios(&#123; method: 'post', url:url, data:params&#125;).then((res)=&gt;&#123; &#125;); 修改上面的ajax请求为： methods: { login () { var params = new URLSearchParams() params.append(&apos;name&apos;, this.user.name) params.append(&apos;address&apos;, this.user.address) this.$axios .post(&apos;/login&apos;, params) .then(successResponse =&gt; { this.responseResult = JSON.stringify(successResponse.data) if (successResponse.status === 200) { var userName = successResponse.data.data.name console.log(userName) // this.$store.dispatch(&apos;changeCity&apos;, userName) this.changeCity(userName) this.$router.replace({path: &apos;/index&apos;}) } }) .catch(failResponse =&gt; {}) }, ...mapMutations([&apos;changeCity&apos;]) } 详情可参参考：点击这里","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十九）使用localStorage暂存公用数据","slug":"vue19","date":"2019-03-18T01:47:55.000Z","updated":"2019-04-20T14:45:24.960Z","comments":true,"path":"2019/03/18/vue19/","link":"","permalink":"https://www.chenende.top/2019/03/18/vue19/","excerpt":"前言上一章节，我们完成了使用公用数据实现数据同步的功能，细心的朋友可能会发现当页面刷新后数据会恢复默认，选择后的城市数据无法持久显示，为解决这一问题需要在store中添加localStorage来对修改的数据进行暂存。 功能实现 首先需要理解localStorage的用途，它就相当于浏览器`cookie，能对数据进行一段时间的保存。 localStorage配置 在store目录下的index.js中的mutations添加以下内容：","text":"前言上一章节，我们完成了使用公用数据实现数据同步的功能，细心的朋友可能会发现当页面刷新后数据会恢复默认，选择后的城市数据无法持久显示，为解决这一问题需要在store中添加localStorage来对修改的数据进行暂存。 功能实现 首先需要理解localStorage的用途，它就相当于浏览器`cookie，能对数据进行一段时间的保存。 localStorage配置 在store目录下的index.js中的mutations添加以下内容： 123456789mutations: &#123; changeCity(state, city) &#123; state.city = city; try &#123; localStorage.city = city; &#125; catch (e) &#123; &#125; &#125;, &#125;, 在某些情况下localStorage无法使用，例如使用隐身模式开启窗口，所以凡是用到localStorage的地方都要try{}catch{}一下。 然后修改store的默认值为localStorage.userNaem 12345678910111213141516171819202122232425262728293031import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);try &#123; if (localStorage.city) &#123; const defaultCity = localStorage.city; &#125;&#125; catch (e) &#123;&#125;export default new Vuex.Store(&#123; state: &#123; city: defaultCity || '河南', &#125;, actions: &#123; changeCity(ctx, city) &#123; ctx.commit('changeCity', city); &#125;, &#125;, mutations: &#123; changeCity(state, city) &#123; state.city = city; try &#123; localStorage.city = city; &#125; catch (e) &#123; &#125; &#125;, &#125;,&#125;); 完成上述操作后，再刷新页面的时候修改的数据就不会丢失了。 此前在页面中引用公用数据的时候，我们是这样写的：{\\{this.$store.state.city}\\}，vue官方提供了可以简写的配置项。 需在页面script中导入{mapState}并配置computed计算属性。 1234第一步：import &#123;mapState&#125; from 'vuex'第二步： computed: &#123; ...mapState(['username']) &#125; 完成以上配置就可以在代码中直接使用{\\{this.city}\\}来获取数据了。 除mapState外还有mapMutations、mapActions,及mapGetters，其中mapMutations可以用来简化添加公用数据的代码 1234567methods: &#123; handleCityClick(city) &#123; this.changeCity(city); this.$router.push('/'); &#125;, ...mapMutations(['changeCity']) &#125;, 本章内容就到这里，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十八）使用vuex存储公用数据","slug":"vue18","date":"2019-03-17T15:12:34.000Z","updated":"2019-04-20T03:07:18.213Z","comments":true,"path":"2019/03/17/vue18/","link":"","permalink":"https://www.chenende.top/2019/03/17/vue18/","excerpt":"前言本章节我们来完成首页和城市列表页面的数据同步，在城市列表页面点击选择城市，页面中的当前城市和首页右上角显示的城市将同步更改为选择的城市。 要实现这一功能，需要用到vue中的数据操作模块vuex,将不同组件使用到的公共数据交给它来管理，使用的时候直接使用$从vue中获取即可。 案例实现1.安装vuex使用命令：npm install vuex --save 2.vuex的使用","text":"前言本章节我们来完成首页和城市列表页面的数据同步，在城市列表页面点击选择城市，页面中的当前城市和首页右上角显示的城市将同步更改为选择的城市。 要实现这一功能，需要用到vue中的数据操作模块vuex,将不同组件使用到的公共数据交给它来管理，使用的时候直接使用$从vue中获取即可。 案例实现1.安装vuex使用命令：npm install vuex --save 2.vuex的使用 如上图所示，公用的数据放在state中，如果想要更改state中的数据，需要选择使用dispatch方法调用Actions,然后再使用commit方法调用mutations执行数据修改（这一步是必须的），可以跳过Actions直接使用commit方法调用mutations。 更多内容可以参考vuex官方文档 首先在项目中的src目录下创建store文件夹，在文件夹中创建index.js文件，添加如下内容： 12345678910import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; city: '河南', &#125;&#125;); 接着在main.js中引入上一步创建的文件 1234567891011121314151617181920212223import 'styles/reset.css';import 'styles/border.css';import 'styles/iconfont.css';import fastClick from 'fastclick';import VueAwesomeSwiper from 'vue-awesome-swiper';import Vue from 'vue';import 'swiper/dist/css/swiper.css';import App from './App';import router from './router';import store from './store';fastClick.attach(document.body);Vue.config.productionTip = false;Vue.use(VueAwesomeSwiper);/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, //在vue实例中使用引入的store，所有的组件就都能够使用在store中定义的数据了 components: &#123; App &#125;, template: '&lt;App/&gt;',&#125;); 修改首页和城市列表页中的当前城市的取值，由起来的ajax获取，改为从store中获取 取值方式：this.$store.state.city 12345678&lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;当前城市&lt;/div&gt; &lt;div class=&quot;button-list&quot;&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;&#123;&#123;this.$store.state.city&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 为热门城市和字母列表中的城市添加点击事件，将城市名称作为入参传递到方法中 @click=&quot;handleCityClick(item.name) 创建handleCityCLick方法，修改store中的公共数据 12345678methods: &#123; handleCityClick(city) &#123; //调用名为`changeCity`的Action,传递参数`city` this.$store.dispatch(&apos;changeCity&apos;, city); //跳转到指定路径 this.$router.push(&apos;/&apos;); &#125;, &#125;, 在store中创建名为changeCity的Action,在mutations中接收changeCity执行数据修改操作。 1234567891011121314151617181920import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; city: &apos;河南&apos;, &#125;, actions: &#123; changeCity(ctx, city) &#123; ctx.commit(&apos;changeCity&apos;, city); &#125;, &#125;, mutations: &#123; changeCity(state, city) &#123; state.city = city; &#125;, &#125;,&#125;); 至此同步修改首页中的当前城市和城市列表中的当前城市的功能即已完成，同样我们也可以为城市列表和搜索结果中的每一个元素添加点击事件，只要把上面已经完成的方法复制粘贴到相应位置即可。","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十七）搜索功能实现","slug":"vue17","date":"2019-03-16T11:26:18.000Z","updated":"2019-04-20T03:07:17.961Z","comments":true,"path":"2019/03/16/vue17/","link":"","permalink":"https://www.chenende.top/2019/03/16/vue17/","excerpt":"前言本章节我们完成搜索功能的开发，在搜索框中输入城市显示搜索结果。","text":"前言本章节我们完成搜索功能的开发，在搜索框中输入城市显示搜索结果。 所涉及到的知识点前面章节都有运用，本章将对前面讲过的知识点来进行综合运用。 案例实现1.对输入框中的内容进行双向绑定在dom中使用v-model=&#39;keyword&#39;,对搜索框中输入的内容进行双向绑定，然后在data中定义变量keyword接收数据。 2.向search.vue组件传递城市列表数据在父组件city.vue中向子组件city-search.vue传值 1&lt;city-search :cityList=\"cityList\"&gt;&lt;/city-search&gt; 在子组件中接收数据 props: {cityList: Object,}, 3.使用侦听器监听输入框中内容的变化遍历城市列表，如果当前城市包含搜索框的内容就把它添加到空集合中，在data中定义变量list接收12345678910111213141516watch: &#123; keyword() &#123; const result = []; for (const i in this.cityList) &#123; if (&#123;&#125;.hasOwnProperty.call(this.cityList, i)) &#123; this.cityList[i].forEach((value) =&gt; &#123; if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123; result.push(value); &#125; &#125;); &#125; &#125; this.list = result; &#125;, &#125;, 在dom中遍历展示list中的内容 12345&lt;div class=\"search-content\" v-show=\"keyword\"&gt; &lt;ul&gt; &lt;li class=\"search-item\" v-for=\"item of list\" :key=\"item.id\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 4.功能优化 当没有搜索结果的时候给出提示 在dom中添加内容 123456&lt;div class=\"search-content\"&gt; &lt;ul&gt; &lt;li class=\"search-item\" v-for=\"item of list\" :key=\"item.id\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;li class=\"search-item\" &gt;没有符合条件的查询结果！&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 只有在list为空，即没有搜索结果的时候才展示，使用v-show来实现 &lt;li class=&quot;search-item&quot; v-show=&quot;hanNoDate&quot;&gt;没有符合条件的查询结果！&lt;/li&gt; 搜索结果页面的隐藏和展示 开发到这里，你或许会发现搜索结果页面一直存在，遮挡了列表页面的展示。什么时候该隐藏/显示结果页面呢？经过思考你应该发现只有在搜索框中有内容的时候才需要展示搜索结果页面，下面我们就会v-show来解决这一问题： 123456&lt;div class=\"search-content\" v-show=\"keyword\"&gt; &lt;ul&gt; &lt;li class=\"search-item\" v-for=\"item of list\" :key=\"item.id\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;li class=\"search-item\" v-show=\"hanNoDate\"&gt;没有符合条件的查询结果！&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 为侦听器中的代码添加定时器来优化性能 clearTimeout清除定时器setTimeout添加定时器 123456789101112131415161718192021watch: &#123; keyword() &#123; if (this.timer) &#123; clearTimeout(this.timer); &#125; this.timer = setTimeout(() =&gt; &#123; const result = []; for (const i in this.cityList) &#123; if (&#123;&#125;.hasOwnProperty.call(this.cityList, i)) &#123; this.cityList[i].forEach((value) =&gt; &#123; if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123; result.push(value); &#125; &#125;); &#125; &#125; this.list = result; &#125;, 100); &#125;,&#125;, 为搜索结果添加页面拖动效果 在搜索结果较多的时候，你或许会发现无法拖动页面查看列多内容，此时可以使用我们前面讲过的better-scroll来解决这一问题 1）.首先引入better-scroll import Bscroll from &#39;better-scroll&#39; 2）.然后使用vue中的mounted生命钩子创建better-scroll实例，而要在搜索结果页面的dom元素中添加ref=&#39;search&#39;,然后将引用的dom传递给Bscroll 123mounted() &#123; this.scroll = new Bscroll(this.$refs.search); &#125;, 至此，我们今天的内容就讲完了,如有不明白的地方可以在下访评论留言。知识在于点滴积累，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十六）性能优化","slug":"vue16","date":"2019-03-14T17:43:52.000Z","updated":"2019-04-20T03:07:18.425Z","comments":true,"path":"2019/03/15/vue16/","link":"","permalink":"https://www.chenende.top/2019/03/15/vue16/","excerpt":"前言本章节我们来对上一章中完成的案例进行性能优化： 将重复计算的数据提取出来 对handleTouchMove中的方法添加时间间隔，来减少函数执行次数","text":"前言本章节我们来对上一章中完成的案例进行性能优化： 将重复计算的数据提取出来 对handleTouchMove中的方法添加时间间隔，来减少函数执行次数 具体实现本次优化主要针对tag.vue字母列表，已开发好的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;template&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item\" v-for=\"item of letters\" :key=\"item\" :ref=\"item\" @touchstart=\"handleTouchStart\" @touchmove=\"handleTouchMove\" @touchend=\"handleTouchEnd\" @click=\"handleLetterClick\"&gt; &lt;b&gt;&#123;&#123;item&#125;&#125;&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'CityTag', props: &#123; cityList: Object, &#125;, computed: &#123; letters() &#123; const letters = []; for (const i in this.cityList) &#123; if (&#123;&#125;.hasOwnProperty.call(this.cityList, i)) &#123; letters.push(i); &#125; &#125; return letters; &#125;, &#125;, data() &#123; return &#123; touchStatus: false, &#125;; &#125;, methods: &#123; handleLetterClick(e) &#123; this.$emit('change', e.target.innerText); &#125;, handleTouchStart() &#123; this.touchStatus = true; &#125;, handleTouchMove(e) &#123; if (this.touchStatus) &#123; const startY = this.$refs[this.letters[0]][0].offsetTop; const touchY = e.touches[0].clientY; const index = Math.floor((touchY - startY) / 15); if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]); &#125; &#125; &#125;, handleTouchEnd() &#123; this.touchStatus = false; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import \"~styles/varibles.styl\" .list display flex flex-direction column justify-content center position absolute top 0rem right 0rem bottom 0 width .4rem cursor pointer .item text-align center line-height .3rem color $bgColor font-size .25rem&lt;/style&gt; 首先将handleTouchMove方法中的const startY = this.$refs[this.letters[0]][0].offsetTop;提取出来，在data中添加变量startY,默认值为’‘； 使用update(){}函数，在组件更新后为startY重新赋值： 123updated() &#123; this.startY = this.$refs[this.letters[0]][0].offsetTop; &#125;, 然后将代码中用到startY的地方替换成this.startY 2.为执行代码添加时间时隔 在data中定义变量timer,默认值为null 在handleTouchMove方法中添加条件判断，使用clearTimeout和setTimeout取消和设置定时器 123456789101112handleTouchMove(e) &#123; if (this.touchStatus) &#123; if (this.timer) &#123; clearTimeout(this.timer); &#125; const touchY = e.touches[0].clientY - 79; const index = Math.floor((touchY - this.startY) / 15); if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]); &#125; &#125; &#125;, 知识在于点滴积累，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十五）侧边栏导航条开发","slug":"vue15","date":"2019-03-11T13:45:18.000Z","updated":"2019-04-20T03:07:18.533Z","comments":true,"path":"2019/03/11/vue15/","link":"","permalink":"https://www.chenende.top/2019/03/11/vue15/","excerpt":"前言这一章节我们来完成城市列表页面中的右侧字母索引列表与城市列表联动，即点击字母自动切换展示对应的城市内容。","text":"前言这一章节我们来完成城市列表页面中的右侧字母索引列表与城市列表联动，即点击字母自动切换展示对应的城市内容。 需要掌握的重点： 兄弟组件之间的传值 vue-计算属性 移动端 js touch事件 axios的使用 案例实现1.首先使用axios替换上一章节中写死的数据 在static/mock目录下引入json文件city.json: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"ret\": true, \"data\":&#123; \"hotCities\": [&#123; \"id\": 1, \"spell\": \"beijing\", \"name\": \"北京\" &#125;, &#123; \"id\": 3, \"spell\": \"shanghai\", \"name\": \"上海\" &#125;, &#123; \"id\": 47, \"spell\": \"xian\", \"name\": \"西安\" &#125;, &#123; \"id\": 239, \"spell\": \"sanya\", \"name\": \"三亚\" &#125;, &#123; \"id\": 188, \"spell\": \"lijiang\", \"name\": \"丽江\" &#125;, &#123; \"id\": 125, \"spell\": \"guilin\", \"name\": \"桂林\" &#125;], \"cities\": &#123; \"A\": [&#123; \"id\": 56, \"spell\": \"aba\", \"name\": \"阿坝\" &#125;, &#123; \"id\": 57, \"spell\": \"akesu\", \"name\": \"阿克苏\" &#125;, &#123; \"id\": 115, \"spell\": \"fushun\", \"name\": \"抚顺\" &#125;] &#125; &#125;&#125; 在city.vue中引入axios,添加methods从json文件中接收参数： 123456789101112131415161718192021 methods: &#123; getCityInfo() &#123; axios.get('/api/city.json') .then(this.getCityInfoSucc); &#125;, getCityInfoSucc(res) &#123; const result = res.data; if (result.ret &amp;&amp; result.data) &#123; const data = result.data; this.hotCityList = data.hotCities; this.cityList = data.cities; &#125; &#125;, handleLetterChange(letter) &#123; this.letter = letter; &#125;, &#125;, mounted() &#123; this.getCityInfo(); &#125;,&#125;; 将接收到的参数传递到子组件中 123456&lt;div&gt; &lt;city-header&gt;&lt;/city-header&gt; &lt;city-search&gt;&lt;/city-search&gt; &lt;city-list :hotCityList=\"hotCityList\" :cityList=\"cityList\"&gt;&lt;/city-list&gt; &lt;city-tag :cityList=\"cityList\"&gt;&lt;/city-tag&gt; &lt;/div&gt; 在子组件中接收父组件传递的参数，使用v-for遍历，需要注意的是cityList是对象，遍历对象同遍历数组有所不同，需要遍历两次，且key值不再是item.id 12345678910111213141516遍历对象：&lt;div class=\"area\" v-for=\"(item, key) of cityList\" :key=\"key\" :ref=\"key\"&gt; &lt;div class=\"title\"&gt;&#123;&#123;key&#125;&#125;&lt;/div&gt; &lt;div class=\"item-list\" v-for=\"innerItem of item\" :key=\"innerItem.id\"&gt; &lt;div class=\"item\"&gt;&#123;&#123;innerItem.name&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;接收父组件传递的值： props: &#123; hotCityList: Array, cityList: Object, letter: String, &#125;, 2.兄弟组件传值 思路：将父组件作为媒介，先将值传给父组件，再由父组件传递给子组件。点击字母列表的时候，将点击的字母传递给父组件，再由父组件传递给list组件，在list组件中使用侦听器计算出要展示的区块，从而实现联动效果 要想得得字母所在的屏幕位置，且添加效果，当手指在字母列表中滑动的时候，list中的内容跟随手指的移动自动切换展示，需要用到移动端的Touch事件，该事件常用的三个方法TouchStart、‘TouchMove’、’TouchEnd’分别表示触屏事件开始的时候触发，移动的时候触发，结束的时候触发,利用这三个属性我们可以通过计算得到每个字母的位置坐标。 首先需要dom中绑定方法： 123456789101112&lt;template&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item\" v-for=\"item of letters\" :key=\"item\" :ref=\"item\" @touchstart=\"handleTouchStart\" @touchmove=\"handleTouchMove\" @touchend=\"handleTouchEnd\" @click=\"handleLetterClick\"&gt; &lt;b&gt;&#123;&#123;item&#125;&#125;&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 然后在methods中编写方法： 123456789101112131415161718192021methods: &#123; handleLetterClick(e) &#123; this.$emit('change', e.target.innerText); &#125;, handleTouchStart() &#123; this.touchStatus = true; &#125;, handleTouchMove(e) &#123; if (this.touchStatus) &#123; const startY = this.$refs[this.letters[0]][0].offsetTop; //获取字母A到页面顶部的距离， const touchY = e.touches[0].clientY; //获取手指停留位置到顶部的距离 const index = Math.floor((touchY - startY) / 15); //首先获取当前位置到字母A（第一个字母即起始位置），再除以每个字母的高度，得到选择字母的在数组中的下标 if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]); // 通过this.$emit将值传递给父组件 &#125; &#125; &#125;, handleTouchEnd() &#123; this.touchStatus = false; &#125;, &#125;, 在父组件city.vue中接收子组件传递的值，然后再将值传递给list组件 1234567891011&lt;div&gt; &lt;city-header&gt;&lt;/city-header&gt; &lt;city-search&gt;&lt;/city-search&gt; &lt;city-list :hotCityList=\"hotCityList\" :cityList=\"cityList\" :letter=\"letter\"&gt;&lt;/city-list&gt; &lt;city-tag :cityList=\"cityList\" @change=\"handleLetterChange\"&gt;&lt;/city-tag&gt; &lt;/div&gt; handleLetterChange(letter) &#123; this.letter = letter; &#125;, 在list组件中使用侦听器来监听值的变化，当值有改变的时候使用this.scroll.scrollToElement来切换内容展示： 12345678watch: &#123; letter() &#123; if (this.letter) &#123; const el = this.$refs[this.letter][0]; this.scroll.scrollToElement(el); &#125; &#125;, &#125;, 注意：dom元素中需要使用‘ref’来获取元素： 123456&lt;div class=\"area\" v-for=\"(item, key) of cityList\" :key=\"key\" :ref=\"key\"&gt; &lt;div class=\"title\"&gt;&#123;&#123;key&#125;&#125;&lt;/div&gt; &lt;div class=\"item-list\" v-for=\"innerItem of item\" :key=\"innerItem.id\"&gt; &lt;div class=\"item\"&gt;&#123;&#123;innerItem.name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 3.最终代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758父组件 `city.vue`&lt;template&gt; &lt;div&gt; &lt;city-header&gt;&lt;/city-header&gt; &lt;city-search&gt;&lt;/city-search&gt; &lt;city-list :hotCityList=\"hotCityList\" :cityList=\"cityList\" :letter=\"letter\"&gt;&lt;/city-list&gt; &lt;city-tag :cityList=\"cityList\" @change=\"handleLetterChange\"&gt;&lt;/city-tag&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios';import CityHeader from './components/Header';import CitySearch from './components/Search';import CityList from './components/list';import CityTag from './components/Tag';export default &#123; name: 'City', components: &#123; CityHeader, CitySearch, CityList, CityTag, &#125;, data() &#123; return &#123; hotCityList: [], cityList: &#123;&#125;, letter: '', &#125;; &#125;, methods: &#123; getCityInfo() &#123; axios.get('/api/city.json') .then(this.getCityInfoSucc); &#125;, getCityInfoSucc(res) &#123; const result = res.data; if (result.ret &amp;&amp; result.data) &#123; const data = result.data; this.hotCityList = data.hotCities; this.cityList = data.cities; &#125; &#125;, handleLetterChange(letter) &#123; this.letter = letter; &#125;, &#125;, mounted() &#123; this.getCityInfo(); &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687子组件 list.vue&lt;template&gt; &lt;div class=\"list\" ref=\"wrapper\"&gt; &lt;div&gt; &lt;div class=\"area\"&gt; &lt;div class=\"title\"&gt;当前城市&lt;/div&gt; &lt;div class=\"button-list\"&gt; &lt;div class=\"button-wrapper\"&gt; &lt;div class=\"button\"&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"area\"&gt; &lt;div class=\"title\"&gt;热门城市&lt;/div&gt; &lt;div class=\"button-list\"&gt; &lt;div class=\"button-wrapper\" v-for=\"item of hotCityList\" :key=\"item.id\"&gt; &lt;div class=\"button\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"area\" v-for=\"(item, key) of cityList\" :key=\"key\" :ref=\"key\"&gt; &lt;div class=\"title\"&gt;&#123;&#123;key&#125;&#125;&lt;/div&gt; &lt;div class=\"item-list\" v-for=\"innerItem of item\" :key=\"innerItem.id\"&gt; &lt;div class=\"item\"&gt;&#123;&#123;innerItem.name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bscroll from 'better-scroll';export default &#123; name: 'CityList', props: &#123; hotCityList: Array, cityList: Object, letter: String, &#125;, mounted() &#123; this.scroll = new Bscroll(this.$refs.wrapper); &#125;, watch: &#123; letter() &#123; if (this.letter) &#123; const el = this.$refs[this.letter][0]; this.scroll.scrollToElement(el); &#125; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; .list position absolute overflow hidden top 1.58rem left 0 bottom 0 right 0 .title line-height .6rem padding-left .2rem background #eee color #666 border-top solid 1px #cccccc .button-list overflow hidden padding .1rem .6rem .1rem .1rem .button-wrapper float left width 33.33% .button margin .1rem padding .1rem 0 text-align center border .02rem solid #cccccc border-radius .1rem .item-list .item line-height .4rem border-bottom 1px solid #cccccc padding .2rem&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879子组件 字母表 tag.vue&lt;template&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"item\" v-for=\"item of letters\" :key=\"item\" :ref=\"item\" @touchstart=\"handleTouchStart\" @touchmove=\"handleTouchMove\" @touchend=\"handleTouchEnd\" @click=\"handleLetterClick\"&gt; &lt;b&gt;&#123;&#123;item&#125;&#125;&lt;/b&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'CityTag', props: &#123; cityList: Object, &#125;, computed: &#123; letters() &#123; const letters = []; for (const i in this.cityList) &#123; // 参考资料：https://segmentfault.com/q/1010000016469493/a-1020000016469784 if (&#123;&#125;.hasOwnProperty.call(this.cityList, i)) &#123; letters.push(i); &#125; &#125; return letters; &#125;, &#125;, data() &#123; return &#123; touchStatus: false, &#125;; &#125;, methods: &#123; handleLetterClick(e) &#123; this.$emit('change', e.target.innerText); &#125;, handleTouchStart() &#123; this.touchStatus = true; &#125;, handleTouchMove(e) &#123; if (this.touchStatus) &#123; const startY = this.$refs[this.letters[0]][0].offsetTop - 79; const touchY = e.touches[0].clientY - 79; const index = Math.floor((touchY - startY) / 15); if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]); &#125; &#125; &#125;, handleTouchEnd() &#123; this.touchStatus = false; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import \"~styles/varibles.styl\" .list display flex flex-direction column justify-content center position absolute top 0rem right 0rem bottom 0 width .4rem cursor pointer .item text-align center line-height .3rem color $bgColor font-size .25rem&lt;/style&gt; 知识在于点滴的积累，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十四）使用better-scroll滚动展示页面内容","slug":"vue14","date":"2019-03-07T14:04:47.000Z","updated":"2019-04-20T03:07:17.549Z","comments":true,"path":"2019/03/07/vue14/","link":"","permalink":"https://www.chenende.top/2019/03/07/vue14/","excerpt":"前言本章我们来完成 [城市列表页面] 的开发","text":"前言本章我们来完成 [城市列表页面] 的开发学习重点在于右侧字母列表的展示和better-scroll插件的使用 案例实现首先是创建list组件，然后在city.vue中引入，此过程就不再赘述，有遗忘的地方可以参考前面章节中的内容。list中的内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;template&gt; &lt;div class=&quot;list&quot;&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;当前城市&lt;/div&gt; &lt;div class=&quot;button-list&quot;&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;热门城市&lt;/div&gt; &lt;div class=&quot;button-list&quot;&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;B&lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;C&lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;D&lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Bscroll from &apos;better-scroll&apos;;export default &#123; name: &apos;CityList&apos;,&#125;;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt; .list position absolute overflow hidden top 1.58rem left 0 bottom 0 right 0 .title line-height .6rem padding-left .2rem background #eee color #666 border-top solid 1px #cccccc .button-list overflow hidden padding .1rem .6rem .1rem .1rem .button-wrapper float left width 33.33% .button margin .1rem padding .1rem 0 text-align center border .02rem solid #cccccc border-radius .1rem .item-list .item line-height .4rem border-bottom 1px solid #cccccc padding .2rem&lt;/style&gt; 使用better-scroll组件实现滚动展示div中的内容 首先在项目中安装better-scrollnpm install better-scroll --save better-scroll插件的使用 在github中全局搜索better-scroll 排在第一位的就是我们要找的插件所在的仓库地址，点击进入可以看到插件的使用文档，使用该插件DOM结构必须符合下面的样式： 12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;content&quot;&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;!-- you can put some other DOMs here, it won&apos;t affect the scrolling --&gt;&lt;/div&gt; 即要求最外层须由两层div包裹，于是修改list组件中的dom元素为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;div class=&quot;list&quot; ref=&quot;wrapper&quot;&gt; &lt;div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;当前城市&lt;/div&gt; &lt;div class=&quot;button-list&quot;&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;热门城市&lt;/div&gt; &lt;div class=&quot;button-list&quot;&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;div class=&quot;button&quot;&gt;北京&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;A&lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;B&lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;C&lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;area&quot;&gt; &lt;div class=&quot;title&quot;&gt;D&lt;/div&gt; &lt;div class=&quot;item-list&quot;&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;阿拉尔&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 在最外层的div中添加ref=&quot;wrapper&quot;用于对dom元素的引用，然后在整个html加载完成之后调用better-scroll组件，将dom元素传递进去： 12345678910&lt;script&gt;import Bscroll from &apos;better-scroll&apos;;export default &#123; name: &apos;CityList&apos;, mounted() &#123; this.scroll = new Bscroll(this.$refs.wrapper); &#125;,&#125;;&lt;/script&gt; 完成上述操作之后启动项目即可实现滚动展示页面的效果。 ** 接下来我们来完成侧边栏目字母列表的展示： 创建tag组件，并在city.vue中引入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;item&quot;&gt;&lt;b&gt;A&lt;/b&gt;&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;&lt;b&gt;B&lt;/b&gt;&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;C&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;D&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;E&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;F&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;G&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;H&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;J&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;K&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;L&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;M&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;N&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;P&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;Q&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;R&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;S&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;T&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;V&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;W&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;X&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;Y&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;Z&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;CityTag&apos;,&#125;;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt; @import &quot;~styles/varibles.styl&quot; .list display flex flex-direction column justify-content center position absolute right 0rem bottom 0 width .4rem .item text-align center line-height .3rem color $bgColor font-size .25rem&lt;/style&gt; 该组件的css样式中主要运用了flex弹性盒子布局，对于弹性布局不太了解的朋友可以参考以下资料进行相关内容的补充，[浅谈CSS3中display属性的Flex布局] [flex详解] 知识点拓展 给div添加阴影css效果，可以使用box-shadow: 1px 2px 15px #00bcd4;来实现","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十三）搜索框","slug":"vue13","date":"2019-03-04T15:12:00.000Z","updated":"2019-04-20T03:07:18.289Z","comments":true,"path":"2019/03/04/vue13/","link":"","permalink":"https://www.chenende.top/2019/03/04/vue13/","excerpt":"前言本章我们来完成 [搜索框] 的开发","text":"前言本章我们来完成 [搜索框] 的开发通过前面对css的学习，本章案例应做到尽量独立完成，没必要非要跟我的代码一致，只要最终呈现的效果差不多即可。重在巩固练习。 案例实现 首先还是创建组件，在city下的components文件夹中创建search.vue,在&lt;template&gt;中添加&lt;input&gt;标签，输入内容请输入要查询的内容： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;search&quot;&gt; &lt;input class=&quot;search-img&quot; type=&quot;text&quot; placeholder=&quot;请输入要搜索的内容&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;CiytSearch&apos;,&#125;;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt; @import &quot;~styles/varibles.styl&quot; .search line-height 0.1rem background $bgColor padding 0 .1rem .1rem .search-img box-sizing border-box line-height .62rem width 100% border-radius .05rem text-align center color #666 padding 0 .1rem&lt;/style&gt; 然后在city.vue中引入serch组件，此处不再赘述。 最后给serch中的内容编写css样式 12345678910111213@import \"~styles/varibles.styl\" .search line-height 0.1rem background $bgColor padding 0 .1rem .1rem .search-img box-sizing border-box line-height .62rem width 100% border-radius .05rem text-align center color #666 padding 0 .1rem 至此，我们的案例就算完成了，赶快启动项目看看效果吧！ 只要将基础知识掌握牢靠，你会发现我们的开发会变得越来越简单！不积跬步无以至千里，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十二）城市选择","slug":"vue12","date":"2019-03-04T13:32:00.000Z","updated":"2019-04-20T03:07:17.605Z","comments":true,"path":"2019/03/04/vue12/","link":"","permalink":"https://www.chenende.top/2019/03/04/vue12/","excerpt":"前言本章我们来完成 [城市选择] 页面的开发","text":"前言本章我们来完成 [城市选择] 页面的开发 案例实现本章内容是对前面所学的一个综合练习，温故而知新，在实现案例的过程中查漏补缺，对前面的知识点做一下巩固。 创建City组件，添加跳转链接 首先，在pages文件夹下创建city文件夹，在文件夹中创建City.vue组件，内容如下： 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import CityHeader from &apos;./components/Header&apos;;export default &#123; name: &apos;City&apos;,&#125;;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;&lt;/style&gt; 为首页中的 [城市]添加跳转链接 编辑src/pages/home/components/Header.vue，在[城市]所在的div外围添加&lt;router-link&gt;标签，并使用to=&#39;/city&#39;指定跳转到的页面。 123456&lt;router-link to=&quot;/city&quot;&gt; &lt;div class=&quot;header-right&quot;&gt;&#123;&#123;this.city&#125;&#125; &lt;span class=&quot;iconfont arrow-icon&quot;&gt;&amp;#xe60e;&lt;/span&gt; &lt;/div&gt; &lt;/router-link&gt; 配置路由城市选择页面做为一个单独的页面，需要通过路由来为其配置一个访问链接。 123456789101112131415161718192021import Vue from 'vue';import Router from 'vue-router';import Home from '@/pages/home/Home';import City from '@/pages/city/City';Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: '/', name: 'Home', component: Home, &#125;, &#123; path: '/city', name: 'City', component: City, &#125;, ],&#125;); 在做下一步之前，启动一下项目看链接是否生效，添加链接后字体颜色会发生改变，只需要在对应的css样式中添加color=#fff即可。 创建子组件在city文件夹下创建components文件夹，在文件夹下创建Header.vue组件，然后将组件引入到City.vue中。 添加内容入css样式在&lt;template&gt;中添加内容城市选择和样式class=&#39;header&#39;,接下来在&lt;style&gt;中编辑css样式： 123456789101112131415161718@import \"~styles/varibles.styl\" .header position relative overflow hidden height 0.86rem line-height 0.86rem text-align center background $bgColor color #ffffff font-size .32rem .header-icon width .64rem text-align center font-size .7rem position absolute top 0 left 0 color #ffffff 至此，本章的案例已完成。 代码优化对于css中经常用到的值，我们可以把它单独拿出来放在一个文件中，然后通过import进行引用。 不积跬步难以至潜力，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十一）使用Axios发送ajax请求","slug":"vue11","date":"2019-03-03T10:02:44.000Z","updated":"2019-04-20T03:07:18.325Z","comments":true,"path":"2019/03/03/vue11/","link":"","permalink":"https://www.chenende.top/2019/03/03/vue11/","excerpt":"前言本章我们来学习使用Axios发送Ajax请求，将项目里用到的数据全部替换来Ajax请求获取。","text":"前言本章我们来学习使用Axios发送Ajax请求，将项目里用到的数据全部替换来Ajax请求获取。 安装Axios在项目根目录下使用命令npm install axios --save 引入axios项目中有多个组件需要使用ajax发送请求获取数据，如果分别发送请求的话会使影响性能，如果只发送一次请求去获取所有数据的话就能很好的解决这个问题。即：在加载首页的时候采用axios发送ajax请求，获取到所有数据后再通过vue父子组件传值的方式，将数据传递给子组件。 首先我们在首页Home.vue中引入axiosimport HomeWeekend from &#39;./components/Weekend&#39;; 接着使用axios发送请求获取数据在methods中创建方法getHomeInfo（），在data中定义数据city 123456789101112131415161718192021data() &#123; return &#123; city: '', &#125;;&#125;,methods: &#123; getHomeInfo() &#123; axios.get('/api/index.json') //从指定地址获取数据 .then(this.getHomeInfoSucc); //然后调用getHomeInfoSucc方法 &#125;, //使用该方法对获取到的数据进行解析,最后将对应的值赋给data中city，即传递给子组件的值 getHomeInfoSucc(res) &#123; const result = res.data; if (result.ret &amp;&amp; result.data) &#123; const data = result.data; this.city = data.city; &#125; &#125;,&#125;, 父子组件传值 父组件传值给子组件，在父组件template中为子组件绑定数据： &lt;home-header :city=&quot;city&quot;&gt;&lt;/home-header&gt; 子组件接收父组件传递的值： 在子组件的&lt;script&gt;标签中使用props接收传递的值： props: { city: String, //数据类型 }, 接收完数据后把子组件&lt;template&gt;中对应的数据替换成city即可。 创建json文件在static文件夹下创建mock文件夹，在该文件夹中添加index.json文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&#123; \"ret\": true, \"data\": &#123; \"city\": \"北京\", \"swiperList\": [&#123; \"id\": \"0001\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1801/1a/94428c6dea109402.jpg_640x200_2cf590d8.jpg\" &#125;,&#123; \"id\": \"0002\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1802/42/7c92b9a381e46402.jpg_640x200_1cdce2a4.jpg\" &#125;,&#123; \"id\": \"0003\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1802/51/e78f936a5b404102.jpg_640x200_c14f0b3a.jpg\" &#125;,&#123; \"id\": \"0004\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1712/91/a275569091681d02.jpg_640x200_0519ccb9.jpg\" &#125;], \"iconList\": [&#123; \"id\": \"0001\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1611/54/ace00878a52d9702.png\", \"desc\": \"景点门票\" &#125;, &#123; \"id\": \"0002\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1711/df/86cbcfc533330d02.png\", \"desc\": \"滑雪季\" &#125;, &#123; \"id\": \"0003\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1710/a6/83f636bd75ae6302.png\", \"desc\": \"泡温泉\" &#125;, &#123; \"id\": \"0004\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1611/35/2640cab202c41b02.png\", \"desc\": \"动植园\" &#125;, &#123; \"id\": \"0005\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1611/d0/e09575e66f4aa402.png\", \"desc\": \"游乐园\" &#125;, &#123; \"id\": \"0006\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1611/59/569d3c096e542502.png\", \"desc\": \"必游榜单\" &#125;, &#123; \"id\": \"0007\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1611/17/4bd370f3eb1acd02.png\", \"desc\": \"演出\" &#125;, &#123; \"id\": \"0008\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1611/7f/b1ea3c8c7fb6db02.png\", \"desc\": \"城市观光\" &#125;, &#123; \"id\": \"0009\", \"imgUrl\": \"http://img1.qunarzz.com/piao/fusion/1611/a9/ffc620dbda9b9c02.png\", \"desc\": \"一日游\" &#125;], \"recommendList\": [&#123; \"id\": \"0001\", \"imgUrl\": \"http://img1.qunarzz.com/sight/p0/1409/19/adca619faaab0898245dc4ec482b5722.jpg_140x140_80f63803.jpg\", \"title\": \"故宫\", \"desc\": \"东方宫殿建筑代表，世界宫殿建筑典范\" &#125;, &#123; \"id\": \"0002\", \"imgUrl\": \"http://img1.qunarzz.com/sight/p0/1511/d2/d2aec2dfc5aa771290.water.jpg_140x140_abb362a7.jpg\", \"title\": \"南山滑雪场\", \"desc\": \"北京专业级滑雪圣地\" &#125;, &#123; \"id\": \"0003\", \"imgUrl\": \"http://img1.qunarzz.com/sight/p0/1501/f4/f467729126949c3a.water.jpg_140x140_ef235b1c.jpg\", \"title\": \"天安门广场\", \"desc\": \"我爱北京天安门，天安门上太阳升\" &#125;, &#123; \"id\": \"0004\", \"imgUrl\": \"http://img1.qunarzz.com/sight/p0/1501/40/40b2b6c951b28fdd.water.jpg_140x140_1c863e5c.jpg\", \"title\": \"水立方\", \"desc\": \"中国的荣耀，阳光下的晶莹水滴\" &#125;, &#123; \"id\": \"0005\", \"imgUrl\": \"http://img1.qunarzz.com/sight/p0/201308/23/b283071686e64dfec8d65eac.jpg_140x140_8c5a7c49.jpg\", \"title\": \"温都水城养生馆\", \"desc\": \"各种亚热带植物掩映其间仿佛置身热带雨林\" &#125;], \"weekendList\": [&#123; \"id\": \"0001\", \"imgUrl\": \"http://img1.qunarzz.com/sight/source/1510/6e/1ea71e2f04e.jpg_r_640x214_aa6f091d.jpg\", \"title\": \"北京温泉排行榜\", \"desc\": \"细数北京温泉，温暖你的冬天\" &#125;, &#123; \"id\": \"0002\", \"imgUrl\": \"http://img1.qunarzz.com/sight/source/1505/aa/7baaf8a851d221.jpg_r_640x214_1431200f.jpg\", \"title\": \"北京必游TOP10\", \"desc\": \"来北京必去的景点非这些地方莫属\" &#125;, &#123; \"id\": \"0003\", \"imgUrl\": \"http://img1.qunarzz.com/sight/source/1505/9e/21df651e19af5d.jpg_r_640x214_3ea5bb38.jpg\", \"title\": \"寻找北京的皇城范儿\", \"desc\": \"数百年的宫廷庙宇，至今依旧威严霸气\" &#125;, &#123; \"id\": \"0004\", \"imgUrl\": \"http://img1.qunarzz.com/sight/source/1505/ce/bc89bc2f0e33ea.jpg_r_640x214_3e408453.jpg\", \"title\": \"学生最爱的博物馆\", \"desc\": \"周末干嘛？北京很多博物馆已经免费开放啦\" &#125;, &#123; \"id\": \"0005\", \"imgUrl\": \"http://img1.qunarzz.com/sight/source/1505/b2/fde1bfcd057a52.jpg_r_640x214_bbf3fa44.jpg\", \"title\": \"儿童剧场，孩子的乐园\", \"desc\": \"带宝贝观看演出，近距离体验艺术的无穷魅力\" &#125;] &#125;&#125; 启动项目，页面中的城市将会被替换成北京 依照上面的步骤替换其它组件中的数据，需要注意的是其它需要替换的数据类型皆为[]数组，子组件接收的数据类型为Array,数据类型定义错误的话会影响页面的展示。 Home.vue中最终的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div&gt; &lt;home-header :city=&quot;city&quot;&gt;&lt;/home-header&gt; &lt;home-swiper :list=&quot;swiperList&quot;&gt;&lt;/home-swiper&gt; &lt;home-icons :list=&quot;iconList&quot;&gt;&lt;/home-icons&gt; &lt;home-recommend :list=&quot;recommendList&quot;&gt;&lt;/home-recommend&gt; &lt;home-weekend :list=&quot;weekendList&quot;&gt;&lt;/home-weekend&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &apos;axios&apos;;import HomeHeader from &apos;./components/Header&apos;;import HomeSwiper from &apos;./components/Swiper&apos;;import HomeIcons from &apos;./components/Icons&apos;;import HomeRecommend from &apos;./components/Recommend&apos;;import HomeWeekend from &apos;./components/Weekend&apos;;export default &#123; name: &apos;Home&apos;, components: &#123; HomeHeader, HomeSwiper, HomeIcons, HomeRecommend, HomeWeekend, &#125;, data() &#123; return &#123; city: &apos;&apos;, swiperList: [], iconList: [], recommendList: [], weekendList: [], &#125;; &#125;, methods: &#123; getHomeInfo() &#123; axios.get(&apos;/api/index.json&apos;) .then(this.getHomeInfoSucc); &#125;, getHomeInfoSucc(res) &#123; const result = res.data; if (result.ret &amp;&amp; result.data) &#123; const data = result.data; this.city = data.city; this.swiperList = data.swiperList; this.iconList = data.iconList; this.recommendList = data.recommendList; this.weekendList = data.weekendList; &#125; &#125;, &#125;, mounted() &#123; //VUE生命周期函数，在html页面全部加载完成后启用 this.getHomeInfo(); &#125;,&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 代码优化 请求转发 1.由于开发环境和线上环境的不同，axios中的请求地址需要变更，直接变更代码中的地址不是一个很好的选择，webpack-dev-service为我们提供了一个很好的解决方案，在config/index.js文件中配置请求转发，当访问/api的时候自动转发到我们指定的某个文件; 1234567891011// PathsassetsSubDirectory: &apos;static&apos;,assetsPublicPath: &apos;/&apos;,proxyTable: &#123; &quot;/api&quot;: &#123; target: &apos;http://localhost:8086&apos;, pathRewrite: &#123; &quot;^/api&quot;: &apos;static/mock&apos; //将以`/api`开头的内容替换成‘static/mock` &#125; &#125;&#125;, 2.在完成所有数据的替换后，或许你会发现一些问题，首先是swiper中轮播图的展示，进入页面后显示的不是第一张而是最后一张，其次是Icon中的图标会自动轮播。第一个问题的解决方法是在&lt;template&gt;下的&lt;swiper&gt;标签中添加v-if=&quot;list.length&quot;进行条件判断; 如果父组件传递的list为空的话就不初始化swiper组件 同样在Icon组件中的&lt;swiper&gt;标签中也添加条件判断。 第二个问题的解决方法是在swiperOption中添加属性autoplay: false： 123456789data() &#123; return &#123; swiperOption: &#123; pagination: &apos;.swiper-pagination&apos;, loop: true, autoplay: false, //关闭自动轮播 &#125;, &#125;; &#125;, 3.配置.gitignore 项目中的index.json是不需要提交到远程仓库的，对于不需要提交的文件可以在.gitignore中进行配置，这样在提交代码的时候指定的文件会被自动过滤掉。只需要在.gitignore中添加static/mock即可，意思就是过滤掉该路径下的所有文件。 4.拓展内容 ESlint代码规范要求： 在methods中不能使用var定义变量，只能使用const 或let; 不能对方法中的入参进行重新赋值 不能在方法中使用console,如果必须使用的话需要在.eslintrc.js中进行配置，找到rules: {}在末尾加上&#39;no-console&#39;: &#39;off&#39;,即可。 正式开发中都是采用ajax的方式从服务器端获取数据的，所以对于ajax请求方式的使用是必须掌握的。想要了解更多关于axios的内容，可以点击这里获得更多帮助！知识在于点滴积累，大家加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（十）css样式练习","slug":"vue10","date":"2019-03-02T14:02:31.000Z","updated":"2019-04-21T04:43:01.134Z","comments":true,"path":"2019/03/02/vue10/","link":"","permalink":"https://www.chenende.top/2019/03/02/vue10/","excerpt":"前言本章针对前面案例中的css样式进行一次总结，根据案例中所使用的css样式来完成下面的案例： 整个页面总体分为两块内容，即绿色模块和带图片的三个&lt;div&gt;,free style被包含在模块中。主要运用了相对定位、绝对定位、float的特性。","text":"前言本章针对前面案例中的css样式进行一次总结，根据案例中所使用的css样式来完成下面的案例： 整个页面总体分为两块内容，即绿色模块和带图片的三个&lt;div&gt;,free style被包含在模块中。主要运用了相对定位、绝对定位、float的特性。 案例实现 初始化一个vue项目 1.使用命令vue init webpack demo 2.在components文件夹下创建组件demo.vue 3.配置router路由，使访问主页的时候展示demo组件中的内容 在项目中安装stylus第三方插件 1.安装stylus 使用命令`npm install stylus --save` 2.安装stylus-loader 使用命令`npm install stylus-loader --save` 在demo组件中添加html内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159&lt;template&gt; &lt;div class=\"w\"&gt; &lt;div class=\"back1\"&gt; &lt;img class=\"back-img\" :src=\"imgUrl\"/&gt; &lt;div class=\"font1\"&gt;free&lt;/div&gt; &lt;div class=\"font2\"&gt;style&lt;/div&gt; &lt;/div&gt; &lt;div class=\"count\"&gt; &lt;div class=\"a\"&gt; &lt;img class=\"im\" :src=\"url2\"/&gt; &lt;div&gt; &lt;p class=\"text\"&gt;&lt;b&gt;春&amp;emsp;意&lt;/b&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"c\"&gt; &lt;img class=\"im\" :src=\"url\"/&gt; &lt;div&gt; &lt;p class=\"text\"&gt;&lt;b&gt;清&amp;emsp;新&lt;/b&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"b\"&gt; &lt;img class=\"im\" :src=\"url3\"/&gt; &lt;div&gt; &lt;p class=\"text\"&gt;&lt;b&gt;秀&amp;emsp;丽&lt;/b&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'demo', data () &#123; return &#123; url: 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551367137903&amp;di=091efc06bc71ca473b479e815321bbba&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.article.pchome.net%2F00%2F24%2F45%2F49%2Fpic_lib%2Fs960x639%2F003%25281%2529s960x639.jpg', url2: 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551375406784&amp;di=515099c30bb3beb13507597dbb85c5a8&amp;imgtype=0&amp;src=http%3A%2F%2Fimgsrc.baidu.com%2Fimage%2Fc0%253Dshijue1%252C0%252C0%252C294%252C40%2Fsign%3D3314bdda771ed21b6dc426a6c507b7b1%2F0ff41bd5ad6eddc4e55a98d333dbb6fd5266335c.jpg', url3: 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551375485541&amp;di=e941c2e424d8f629df44b99aecaf5d3d&amp;imgtype=0&amp;src=http%3A%2F%2Fdingyue.ws.126.net%2FvIxWtTpVa8bD8ipnHTI%3DN%3DGhrfcAueEBETia2HHu7l7Ur1547191216681compressflag.jpg', imgUrl: 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1551377357772&amp;di=2705368863f402e8dca2b254a6531c76&amp;imgtype=0&amp;src=http%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_jpg%2FDcF3M8O2lUxmCicvXxgb65Cxcfd6AQ4IibUibzgoG5icMr6PAzjSicwRXh6icrJT6iczvCjCke3J0Mj8A0HL350ejP6Fw%2F640%3Fwx_fmt%3Djpeg' &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt;&lt;/style&gt;* 接下来定义css样式.w position:absolute width:100% height:100% top 0 left 0 right 0 margin 0 background-color #f5ffb5 .back1 height 500px margin 0 auto overflow hidden background greenyellow width audo border-bottom solid 15px #fff .back-img width 100% opacity 0.2 .font1 float left position absolute left 15% top 5% font-size 200px text-shadow:3px 3px #fff background: linear-gradient(to left, #d4ff84,#ff8ac6); -webkit-background-clip: text; color: transparent; .font2 float right position absolute right 15% top 5% font-size 200px text-shadow:3px 3px #fff background: linear-gradient(to right, #d4ff84,#ffea18); -webkit-background-clip: text; color: transparent; .count position absolute top 40px width 100% height 90% .a overflow hidden float left position absolute left 20px height 300px width 300px background #ff8ac6 border solid 3px #ff8ac6 border-radius 20% color #fff margin 350px 0 .im position: relative height 90% width 100% .text position: relative top 0px text-align center margin 0 .c overflow hidden float left height 300px width 300px background #35ff0c border solid 3px #35ff0c position:relative left 40% border-radius 20% color #fff margin 350px 0 0 0 .im position: relative height 90% width 100% .text position: relative top 0px text-align center margin 0 .b overflow hidden position absolute right 20px float right height 300px width 300px background #ffea18 border solid 3px #ffea18 border-radius 20% margin 350px 0 .im position: relative height 90% width 100% .text position: relative top 0px text-align center margin 0 color: #fff 1.字体颜色渐变 background: linear-gradient(to left, #d4ff84,#ff8ac6); -webkit-background-clip: text; color: transparent; 2.字体描边 text-shadow:3px 3px #fff 3.float居中 position:relative left 40% 4.背景图透明度 opacity 0.2 5.div边缘弧形过渡效果 border-radius 20% 6.绝对定位 position absolute 结合top、bottom、left、right使用 7.相对定位 position relative 结合top、bottom、left、right使用 对于相对定位和绝对定位的区别，可以参数这篇博文1.绝对定位是相对于使用了postion,且值非static的父级元素的，相对定位没有此限制2.相对定位位移后不会释放原来占有的位置，绝对定位会释放。 8.超出div内容的显示与隐藏 overflow hidden 隐藏 overflow display 显示 9.外边距与内边距 padding 外边距 margin 内边距 10.文章段落开头空格 text-indent .4rem 11.设置整个页面的背景色 position:absolute width:100% height:100% top 0 left 0 right 0 margin 0 background-color #f5ffb5 其中`top`、`left`、`right`、`margin`的设置是为了不让页面与浏览器间留有缝隙 12.设置如何处理元素内的空白 white-space ------------------------------ 值 描述 normal 默认。空白会被浏览器忽略。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 inherit 规定应该从父元素继承 white-space 属性的值。 在练习的过程中切勿意为的依葫芦画瓢，发现问题解决问题才能够得以成长。学习在于点滴的积累，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（九）v-for循环展示列表","slug":"vue09","date":"2019-03-02T12:46:31.000Z","updated":"2019-04-20T03:07:18.373Z","comments":true,"path":"2019/03/02/vue09/","link":"","permalink":"https://www.chenende.top/2019/03/02/vue09/","excerpt":"前言本章节我们来完成「热销推荐」和「周末去哪儿」两个版块的开发","text":"前言本章节我们来完成「热销推荐」和「周末去哪儿」两个版块的开发 本章重点是css样式，在学习当中对css样式进行进一步的了解和认识，下一章节我会对前面所学的css样式做一个总结，并结合案例进行。 案例实现创建组件 在src/pages/home/components目录下创建Recommend.vue 在home.vue中引入Recommend组件具体内容请参考之前的章节 页面布局 在Recommend组件的&lt;template&gt;中添加内容： 12345678910111213&lt;div&gt; &lt;div class=\"recommend-title\"&gt;热销推荐&lt;/div&gt; &lt;ul&gt; &lt;li class=\"item \"&gt; &lt;img class=\"item-img\" src=\"http://img1.qunarzz.com/sight/p0/1810/cc/cc47164357acbeb5a3.water.jpg_200x200_151f0405.jpg\"/&gt; &lt;div class=\"item-info\"&gt; &lt;p class=\"item-title\"&gt;杭州云曼温泉&lt;/p&gt; &lt;p class=\"item-desc\"&gt;云曼温泉能看秀的温泉，泡汤美食赏百秀&lt;/p&gt; &lt;button class=\"item-button\"&gt;查看详情&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 添加css样式编写css样式 123456789101112131415161718192021222324252627282930313233343536&lt;style lang=\"stylus\" scoped&gt; @import '~styles/mixins.styl' .recommend-title line-height .8rem text-indent .4rem background #eee .item overflow hidden display flex height 2rem border-bottom solid #eee; border-bottom-width 0.1px .item-img width 1.7rem height 1.7rem padding .15rem .15rem .item-info flex 1 padding .15rem min-width 0 .item-title line-height .55rem font-size .34rem ellipsis() .item-desc line-height .4rem color #ccc ellipsis() .item-button line-height .44rem margin-top .2rem background #ff9300 padding 0 .2rem border-radius .06rem color #fff&lt;/style&gt; 效果如下： 修改html代码，使用v-for循环来展示内容 在完成了「热销推荐」模块的开发之后，可以参考着开发「周末去哪儿」模块，两者的区别不大，在此不再赘述 最终代码「热销推荐」 Recommend.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;div&gt; &lt;div class=\"recommend-title\"&gt;热销推荐&lt;/div&gt; &lt;ul&gt; &lt;li class=\"item \" v-for=\"item of recommendList\" :key=\"item.id\"&gt; &lt;img class=\"item-img\" :src=\"item.img\"/&gt; &lt;div class=\"item-info\"&gt; &lt;p class=\"item-title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;p class=\"item-desc\"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt; &lt;button class=\"item-button\"&gt;查看详情&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeRecommend', data() &#123; return &#123; recommendList: [&#123; id: '001', img: 'http://img1.qunarzz.com/sight/p0/1810/cc/cc47164357acbeb5a3.water.jpg_200x200_151f0405.jpg', title: '杭州云曼温泉', desc: '云曼温泉能看秀的温泉，泡汤美食赏百秀', &#125;, &#123; id: '002', img: 'http://img1.qunarzz.com/sight/p0/1901/60/601b17dc97036e67a3.water.jpg_200x200_fc8a796c.jpg', title: '杭州烂苹果乐园', desc: '🔥好评如潮，小伙伴热推景点~', &#125;, &#123; id: '003', img: 'http://img1.qunarzz.com/sight/p0/201212/18/f195032e85740a4b93835fbb.jpg_200x200_77761d11.jpg', title: '临安大明山滑雪场', desc: '踩着雪橇，让我们一起寻找那个来自星星的你', &#125;, &#123; id: '004', img: 'http://img1.qunarzz.com/sight/p0/1812/8d/8dd20c66111af48ea3.img.jpg_200x200_9c16f863.jpg', title: '大明山', desc: '去不了大明湖，就去大明山', &#125;, &#123; id: '', img: 'http://img1.qunarzz.com/sight/p0/1505/93/93bc1aacad975843.water.jpg_200x200_27557f82.jpg', title: '山沟沟', desc: '🔥好评如潮，叫上小伙伴一起来山沟沟里躲猫猫', &#125;, &#123; id: '', img: 'http://img1.qunarzz.com/sight/p0/1411/dc/c100d494e06c0e035af4259d6c0b1fe1.water.jpg_200x200_e11fa6ec.jpg', title: '航空小镇温泉世界', desc: '年轻的朋友看过来', &#125;], &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import '~styles/mixins.styl' .recommend-title line-height .8rem text-indent .4rem background #eee .item overflow hidden display flex height 2rem border-bottom solid #eee; border-bottom-width 0.1px .item-img width 1.7rem height 1.7rem padding .15rem .15rem .item-info flex 1 padding .15rem min-width 0 .item-title line-height .55rem font-size .34rem ellipsis() .item-desc line-height .4rem color #ccc ellipsis() .item-button line-height .44rem margin-top .2rem background #ff9300 padding 0 .2rem border-radius .06rem color #fff&lt;/style&gt; 「周末去哪儿」模块 Weekend.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div&gt; &lt;div class=\"weekend-title\"&gt;周末去哪儿&lt;/div&gt; &lt;ul&gt; &lt;li class=\"item\"&gt; &lt;div class=\"img-wrapper\"&gt; &lt;img class=\"item-img\" src=\"http://img1.qunarzz.com/sight/source/1811/52/b6776b49d27025.jpg_r_640x214_35ae205c.jpg\"/&gt; &lt;/div&gt; &lt;div class=\"item-info\"&gt; &lt;p class=\"item-title\"&gt;美丽普陀山&lt;/p&gt; &lt;p class=\"item-desc\"&gt;人间仙境杭州，佛教圣地普陀山等你来玩！在这里静心接收佛家的洗礼，用心感受佛文化 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"item\"&gt; &lt;div class=\"img-wrapper\"&gt; &lt;img class=\"item-img\" src=\"http://img1.qunarzz.com/sight/source/1811/52/b6776b49d27025.jpg_r_640x214_35ae205c.jpg\"/&gt; &lt;/div&gt; &lt;div class=\"item-info\"&gt; &lt;p class=\"item-title\"&gt;美丽普陀山&lt;/p&gt; &lt;p class=\"item-desc\"&gt;人间仙境杭州，佛教圣地普陀山等你来玩！在这里静心接收佛家的洗礼，用心感受佛文化 &lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeWeekend',&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import '~styles/mixins.styl' .weekend-title line-height .8rem text-indent .4rem background #eee .img-wrapper overflow hidden height 36.6% padding 0 .item-img width 100% .item-info padding .15rem border-bottom solid 0.1rem #eee .item-title line-height .55rem font-size .34rem .item-desc line-height .4rem width 7rem color #ccc margin-bottom .2rem ellipsis()&lt;/style&gt; 学习总结：前端三剑客css、js、html是相依相辅必不可缺的，如果想掌握这门课程就必须做到查漏补缺，把这三部分不会的知识点及时补上。学习在于点滴的积累，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（八）使用swiper分屏展示图标列表","slug":"vue08","date":"2019-02-27T16:03:12.000Z","updated":"2019-04-20T03:07:18.461Z","comments":true,"path":"2019/02/28/vue08/","link":"","permalink":"https://www.chenende.top/2019/02/28/vue08/","excerpt":"前言接着前一章节的案例，我们今天完成图标区域多屏展示的开发","text":"前言接着前一章节的案例，我们今天完成图标区域多屏展示的开发本章重点是vue计算属性computed的应用。 案例实现引入轮播图组件打开Icons.vue组件，在上一章代码基础上添加swiper组件：&lt;swiper :options=&quot;swiperOption&quot;&gt;和&lt;swiper-slide&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;template&gt; &lt;div class=\"icons\"&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;swiper-slide&gt; &lt;div class=\"icon\" v-for=\"item in icons\" :key=\"item.id\"&gt; &lt;div class=\"icon-img\"&gt; &lt;img class=\"icon-img-content\" :src=\"item.url\"/&gt; &lt;/div&gt; &lt;p class=\"icon-font\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeIcons', data() &#123; return &#123; icons: [&#123; id: '001', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '景点门票', &#125;, &#123; id: '002', url: 'http://img1.qunarzz.com/piao/fusion/1803/95/f3dd6c383aeb3b02.png', text: '一日游', &#125;, &#123; id: '003', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '杭州必洲', &#125;, &#123; id: '004', url: 'http://img1.qunarzz.com/piao/fusion/1804/5a/13ceb38dcf262f02.png', text: '老和云起', &#125;, &#123; id: '005', url: 'http://img1.qunarzz.com/piao/fusion/1803/17/99402a22ce4af302.png', text: '景点赏花', &#125;, &#123; id: '006', url: 'http://img1.qunarzz.com/piao/fusion/1804/ff/fdf170ee89594b02.png', text: '断桥残雪', &#125;, &#123; id: '007', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '十里长亭', &#125;, &#123; id: '008', url: 'http://img1.qunarzz.com/piao/fusion/1803/fc/b10a6b2e4f0fe102.png', text: '古刹灵隐', &#125;], &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import \"~styles/varibles.styl\" .icons overflow: hidden height: 0 padding-bottom: 50% .icon position: relative overflow hidden float: left width: 25% height: 0 padding-bottom: 25% .icon-img position: absolute top: 0 left: 0 right: 0 bottom: .3rem box-sizing: border-box padding: .1rem .icon-img-content display: block margin: 0 auto height: 100% .icon-font position: absolute left: 0 right: 0 bottom: 0 line-height: .44rem height: .44rem color: $darkTextColor text-align: center&lt;/style&gt; 使用计算属性在export defult中添加计算属性，编写分布逻辑： 12345678910111213computed: &#123; pages() &#123; const pages = []; this.icons.forEach((item, index) =&gt; &#123; const page = Math.floor(index / 8); if (!pages[page]) &#123; pages[page] = []; &#125; pages[page].push(item); &#125;); return pages; &#125;, &#125;, 修改循环逻辑将列表循环逻辑改为先从pages二维数组中取数组，然后再遍历取出的数组： 123456789101112131415&lt;template&gt; &lt;div class=\"icons\"&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;swiper-slide v-for=\"(page, index) of pages\" :key=\"index\"&gt; &lt;div class=\"icon\" v-for=\"item of page\" :key=\"item.id\"&gt; &lt;div class=\"icon-img\"&gt; &lt;img class=\"icon-img-content\" :src=\"item.url\"/&gt; &lt;/div&gt; &lt;p class=\"icon-font\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;p class=\"icon-font\"&gt;&lt;/p&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt; 在iconslist中再添加一个元素，启动项目查看页面，拖动图标区域即可实现翻页功能： 添加翻页组件。。。引入swiper翻页下标组件&lt;div class=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;12345678910111213141516&lt;template&gt; &lt;div class=\"icons\"&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;swiper-slide v-for=\"(page, index) of pages\" :key=\"index\"&gt; &lt;div class=\"icon\" v-for=\"item of page\" :key=\"item.id\"&gt; &lt;div class=\"icon-img\"&gt; &lt;img class=\"icon-img-content\" :src=\"item.url\"/&gt; &lt;/div&gt; &lt;p class=\"icon-font\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;p class=\"icon-font\"&gt;&lt;/p&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt; 下标组件默认显示颜色为蓝色，改变颜色请参考上一章节中的内容，至此图标区域的多屏展示即已完成。 最终代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;template&gt; &lt;div class=\"icons\"&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;swiper-slide v-for=\"(page, index) of pages\" :key=\"index\"&gt; &lt;div class=\"icon\" v-for=\"item of page\" :key=\"item.id\"&gt; &lt;div class=\"icon-img\"&gt; &lt;img class=\"icon-img-content\" :src=\"item.url\"/&gt; &lt;/div&gt; &lt;p class=\"icon-font\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/swiper-slide&gt; &lt;p class=\"icon-font\"&gt;&lt;/p&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeIcons', data() &#123; return &#123; icons: [&#123; id: '001', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '景点门票asfdsdfsdadf', &#125;, &#123; id: '002', url: 'http://img1.qunarzz.com/piao/fusion/1803/95/f3dd6c383aeb3b02.png', text: '一日游', &#125;, &#123; id: '003', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '杭州必洲', &#125;, &#123; id: '004', url: 'http://img1.qunarzz.com/piao/fusion/1804/5a/13ceb38dcf262f02.png', text: '老和云起', &#125;, &#123; id: '005', url: 'http://img1.qunarzz.com/piao/fusion/1803/17/99402a22ce4af302.png', text: '景点赏花', &#125;, &#123; id: '006', url: 'http://img1.qunarzz.com/piao/fusion/1804/ff/fdf170ee89594b02.png', text: '断桥残雪', &#125;, &#123; id: '007', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '十里长亭', &#125;, &#123; id: '008', url: 'http://img1.qunarzz.com/piao/fusion/1803/fc/b10a6b2e4f0fe102.png', text: '古刹灵隐', &#125;, &#123; id: '009', url: 'http://img1.qunarzz.com/piao/fusion/1803/fc/b10a6b2e4f0fe102.png', text: '古刹灵隐', &#125;], swiperOption: &#123; pagination: '.swiper-pagination', &#125;, &#125;; &#125;, computed: &#123; pages() &#123; const pages = []; this.icons.forEach((item, index) =&gt; &#123; const page = Math.floor(index / 8); if (!pages[page]) &#123; pages[page] = []; &#125; pages[page].push(item); &#125;); return pages; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import \"~styles/varibles.styl\" @import \"~styles/mixins.styl\" @import '~styles/varibles.styl' .icons &gt;&gt;&gt; .swiper.container height: 0 padding-bottom 50% .icons &gt;&gt;&gt; .swiper-pagination-bullet-active background: $bgColor .icons &gt;&gt;&gt; .swiper-pagination position: relative margin-top: 0.3rem .icon position: relative overflow hidden float: left width: 25% height: 0 padding-bottom: 25% .icon-img position: absolute top: 0 left: 0 right: 0 bottom: .3rem padding: .2rem .icon-img-content display: block margin: 0 auto height: 100% .icon-font position: absolute left: 0 right: 0 bottom: 0 line-height: .44rem height: .44rem color: $darkTextColor padding-left .2rem text-align: center ellipsis()&lt;/style&gt; 在联系的过程中可以边做边观察页面变化，特别是在做css样式的时候，每添加一个属性可以看看页面展示效果，以便于理解。知识在于点滴的积累，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（七）图片列表展示","slug":"vue07","date":"2019-02-26T11:30:30.000Z","updated":"2019-04-20T03:07:17.321Z","comments":true,"path":"2019/02/26/vue07/","link":"","permalink":"https://www.chenende.top/2019/02/26/vue07/","excerpt":"前言接着昨天的案例，今天我们来完成首页图标的展示，案例展示如下：","text":"前言接着昨天的案例，今天我们来完成首页图标的展示，案例展示如下： 本章重点在于css样式的设置，使用css样式来完成图标的排列与展示。 案例实现 创建Icons.vue组件 在src/pages/home/components目录下创建文件Icons.vue 添加组件内容 1234567891011&lt;template&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeIcons',&#125;;&lt;/script&gt;&lt;style lang='stylus' scoped&gt;&lt;/style&gt; 在&lt;template&gt;中添加内容 1234&lt;div&gt; &lt;img class=\"icon-img-content\" src=\"http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png\"/&gt; &lt;p class=\"icon-font\"&gt;热门景点&lt;/p&gt;&lt;/div&gt; 在Home.vue中引入Icons组件 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;home-header&gt;&lt;/home-header&gt; &lt;home-swiper&gt;&lt;/home-swiper&gt; &lt;home-icons&gt;&lt;/home-icons&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HomeHeader from './components/Header';import HomeSwiper from './components/Swiper';import HomeIcons from './components/Icons';export default &#123; name: 'Home', components: &#123; HomeHeader, HomeSwiper, HomeIcons, &#125;,&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 页面效果如下： 为Icons组件添加css样式，调整图片展示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div class=\"icon\"&gt; &lt;div class=\"icon-img\"&gt; &lt;img class=\"icon-img-content\" src=\"http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png\"/&gt; &lt;/div&gt; &lt;p class=\"icon-font\"&gt;热门景点&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeIcons',&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import \"~styles/varibles.styl\" .icons overflow: hidden height: 0 padding-bottom: 50% .icon position: relative overflow hidden float: left width: 25% height: 0 padding-bottom: 25% .icon-img position: absolute top: 0 left: 0 right: 0 bottom: .3rem box-sizing: border-box padding: .1rem .icon-img-content display: block margin: 0 auto height: 100% .icon-font position: absolute left: 0 right: 0 bottom: 0 line-height: .44rem height: .44rem color: $darkTextColor text-align: center&lt;/style&gt; 使用v-for循环展示图标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;template&gt; &lt;div class=\"icons\"&gt; &lt;div class=\"icon\" v-for=\"item in icons\" :key=\"item.id\"&gt; &lt;div class=\"icon-img\"&gt; &lt;img class=\"icon-img-content\" :src=\"item.url\"/&gt; &lt;/div&gt; &lt;p class=\"icon-font\"&gt;&#123;&#123;item.text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeIcons', data() &#123; return &#123; icons: [&#123; id: '001', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '景点门票', &#125;, &#123; id: '002', url: 'http://img1.qunarzz.com/piao/fusion/1803/95/f3dd6c383aeb3b02.png', text: '一日游', &#125;, &#123; id: '003', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '杭州必洲', &#125;, &#123; id: '004', url: 'http://img1.qunarzz.com/piao/fusion/1804/5a/13ceb38dcf262f02.png', text: '老和云起', &#125;, &#123; id: '005', url: 'http://img1.qunarzz.com/piao/fusion/1803/17/99402a22ce4af302.png', text: '景点赏花', &#125;, &#123; id: '006', url: 'http://img1.qunarzz.com/piao/fusion/1804/ff/fdf170ee89594b02.png', text: '断桥残雪', &#125;, &#123; id: '007', url: 'http://img1.qunarzz.com/piao/fusion/1803/bd/9f7b9b2b60c1502.png', text: '十里长亭', &#125;, &#123; id: '008', url: 'http://img1.qunarzz.com/piao/fusion/1803/fc/b10a6b2e4f0fe102.png', text: '古刹灵隐', &#125;], &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import \"~styles/varibles.styl\" .icons overflow: hidden height: 0 padding-bottom: 50% .icon position: relative overflow hidden float: left width: 25% height: 0 padding-bottom: 25% .icon-img position: absolute top: 0 left: 0 right: 0 bottom: .3rem box-sizing: border-box padding: .1rem .icon-img-content display: block margin: 0 auto height: 100% .icon-font position: absolute left: 0 right: 0 bottom: 0 line-height: .44rem height: .44rem color: $darkTextColor text-align: center&lt;/style&gt; 对于css样式的设置如有不明白的地方可自行百度，也可进行删改然后启动项目查看效果，本章的内容较为简单，所用到的有关vue的知识也就是定制组件，引入组件和for循环遍历数组。知识在于点滴积累，大家加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（六）Swiper轮播图","slug":"vue06","date":"2019-02-25T14:35:10.000Z","updated":"2019-04-20T03:07:17.885Z","comments":true,"path":"2019/02/25/vue06/","link":"","permalink":"https://www.chenende.top/2019/02/25/vue06/","excerpt":"前言在前一章节的基础上，本章我们使用Swiper插件来完成页面轮播图的开发 案例实现 第一步：安装vue-awesome-swiper插件 该插件是托管在github上的，所以首先点击github进入github首页，在搜索栏里输入vue-awesome-swiper进行全局搜索。","text":"前言在前一章节的基础上，本章我们使用Swiper插件来完成页面轮播图的开发 案例实现 第一步：安装vue-awesome-swiper插件 该插件是托管在github上的，所以首先点击github进入github首页，在搜索栏里输入vue-awesome-swiper进行全局搜索。 搜索结果中的第一个就是我们要找的插件，点击打开Swiper插件所在的git仓库。在页面下访的README.md中对插件的使用作了详细的说明。 使用npm安装插件：npm install vue-awesome-swiper --save 安装完成之后，在入口文件中进行引用：123456import VueAwesomeSwiper from 'vue-awesome-swiper'// require stylesimport 'swiper/dist/css/swiper.css'Vue.use(VueAwesomeSwiper, /* &#123; default global options &#125; */) 创建轮播图组件 在src/pages/home/components目录下创建Swiper.vue组件，并添加内容：123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;!-- slides --&gt; &lt;swiper-slide&gt;I'm Slide 1&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 2&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 3&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 4&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 5&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 6&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 7&lt;/swiper-slide&gt; &lt;!-- Optional controls --&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-prev\" slot=\"button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\" slot=\"button-next\"&gt;&lt;/div&gt; &lt;div class=\"swiper-scrollbar\" slot=\"scrollbar\"&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeSwiper', data() &#123; return &#123; swiperOption: &#123;&#125;, &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt;&lt;/style&gt; 使用npm run start启动项目,页面效果如下： 拖动滚动条可以实现轮播的效果，这只是简单的引入，需要我们进一步改进。 优化Swiper组件 首先去掉多余的内容，左右箭头和滚动条： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;!-- slides --&gt; &lt;swiper-slide&gt;I'm Slide 1&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 2&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 3&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 4&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 5&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 6&lt;/swiper-slide&gt; &lt;swiper-slide&gt;I'm Slide 7&lt;/swiper-slide&gt; &lt;!-- Optional controls --&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeSwiper', data() &#123; return &#123; swiperOption: &#123;&#125;, &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt;&lt;/style&gt; 页面效果如下： 接下来替换文件插入图片： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;!-- slides --&gt; &lt;swiper-slide&gt; &lt;img src=\"http://img1.qunarzz.com/piao/fusion/1804/13/e1188b0d0f21b902.jpg_750x200_f85c782a.jpg\"/&gt; &lt;/swiper-slide&gt; &lt;swiper-slide&gt; &lt;img src=\"http://img1.qunarzz.com/piao/fusion/1712/51/36632b2cb850e902.jpg_750x200_fa4120db.jpg\"/&gt; &lt;/swiper-slide&gt; &lt;swiper-slide&gt; &lt;img src=\"http://img1.qunarzz.com/piao/fusion/1806/8b/2680212fadf30002.jpg_750x200_f85409ac.jpg\"/&gt; &lt;/swiper-slide&gt; &lt;!-- Optional controls --&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeSwiper', data() &#123; return &#123; swiperOption: &#123;&#125;, &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt;&lt;/style&gt; 修改后的页面如下 可以发现图片大小不成比例，需要我们添加css样式来进行调整 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;!-- slides --&gt; &lt;swiper-slide&gt; &lt;img class=\"swiper-img\" src=\"http://img1.qunarzz.com/piao/fusion/1804/13/e1188b0d0f21b902.jpg_750x200_f85c782a.jpg\"/&gt; &lt;/swiper-slide&gt; &lt;swiper-slide&gt; &lt;img class=\"swiper-img\" src=\"http://img1.qunarzz.com/piao/fusion/1712/51/36632b2cb850e902.jpg_750x200_fa4120db.jpg\"/&gt; &lt;/swiper-slide&gt; &lt;swiper-slide&gt; &lt;img class=\"swiper-img\" src=\"http://img1.qunarzz.com/piao/fusion/1806/8b/2680212fadf30002.jpg_750x200_f85409ac.jpg\"/&gt; &lt;/swiper-slide&gt; &lt;!-- Optional controls --&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeSwiper', data() &#123; return &#123; swiperOption: &#123;&#125;, &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; .wrapper overflow hidden width: 100% height: 0 padding-bottom: 26.7% background: #eee .swiper-img width: 100%&lt;/style&gt; 添加css样式后的页面： 代码优化 对于&lt;template&gt;中图片的展示，可以用v-for来进行优化，另外在data中添加pagination: &#39;.swiper-pagination&#39;属性为轮播图添加。。。样式，再添加loop:true,实现循环展示的效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;swiper :options=\"swiperOption\"&gt; &lt;!-- slides --&gt; &lt;swiper-slide v-for=\"item of swiperList\" :key=\"item.id\"&gt; &lt;img class=\"swiper-img\" :src=\"item.url\"/&gt; &lt;/swiper-slide&gt; &lt;div class=\"swiper-pagination\" slot=\"pagination\"&gt;&lt;/div&gt; &lt;/swiper&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeSwiper', data() &#123; return &#123; swiperOption: &#123; pagination: '.swiper-pagination', loop: true, &#125;, swiperList: [&#123; id: '001', url: 'http://img1.qunarzz.com/piao/fusion/1804/13/e1188b0d0f21b902.jpg_750x200_f85c782a.jpg', &#125;, &#123; id: '002', url: 'http://img1.qunarzz.com/piao/fusion/1712/51/36632b2cb850e902.jpg_750x200_fa4120db.jpg', &#125;, &#123; id: '003', url: 'http://img1.qunarzz.com/piao/fusion/1806/8b/2680212fadf30002.jpg_750x200_f85409ac.jpg', &#125;, &#123; id: '004', url: 'http://mp-piao-admincp.qunarzz.com/mp_piao_admin_mp_piao_admin/admin/20192/61c3b6dc2a3b1593e82667a5d92a6706.jpg_750x200_1ec098e6.jpg', &#125;], &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; .wrapper overflow hidden width: 100% height: 0 padding-bottom: 26.7% background: #eee .swiper-img width: 100%&lt;/style&gt; 效果如下： 接下来修改。。。的颜色为白色，在style中添加样式： 12345678910111213&lt;style lang=\"stylus\" scoped&gt; .wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background: #ffffff .wrapper overflow hidden width: 100% height: 0 padding-bottom: 26.7% background: #eee .swiper-img width: 100%&lt;/style&gt; 使用&gt;&gt;&gt;来修改Swiper中原本定义的样式，使作用于.wrapper下的所有使用了.swiper-pagination-bullet-active样式的子组件。 到此，轮播图案例就算完成了。 通过本章学习，对于如何引用第三方插件进行开发应该能有一个大致的了解，通过上一章节和本章节的练习应该能够明显感知到，前端开发大部分时间是在开发css样式，在对css样式不熟悉的情况下或许会感到有些吃力，但没关系通过项目联系可以查找资料一边学习。知识在于点滴积累，希望我们能够一起努力，共同进步，加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（五）styles及iconfont使用","slug":"vue05","date":"2019-02-24T13:44:58.000Z","updated":"2019-04-20T03:07:17.449Z","comments":true,"path":"2019/02/24/vue05/","link":"","permalink":"https://www.chenende.top/2019/02/24/vue05/","excerpt":"前言经过前面的练习，现在我们可以来做一个简单的案例,今天要完成的是常见的App Header模块，最终的效果如下： 案例实现在开始之前需要做一些准备工作","text":"前言经过前面的练习，现在我们可以来做一个简单的案例,今天要完成的是常见的App Header模块，最终的效果如下： 案例实现在开始之前需要做一些准备工作 准备工作 固定页面显示大小 禁止手机端用户通过手指触屏来放大首页展示，需要在项目根目录下的index.html中添加代码：minimum-scale=1.0,maxinum-scal=1.0,user-scalable=no 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!--minimum-scale=1.0,maxinum-scal=1.0,user-scalable=no使用移动端用户无法通过手指触屏操作放大首页，使用页面比例始终保持1：1,即原始大小--&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0, minimum-scale=1.0,maxinum-scal=1.0,user-scalable=no\"&gt; &lt;title&gt;travel&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 导入border.css文件用于解决不同分辨率下像素大小不一致的问题，可以百度了解一下一倍图、二倍图、三倍图，在src目录下的assets文件夹中新建styles文件夹，新建文件border.css,内容如下： 12345678910111213141516171819202122232425@charset \"utf-8\";html&#123;background-color:#fff;color:#000;font-size:12px&#125;body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp&#123;margin:0;padding:0&#125;body,input,textarea,button,select,pre,xmp,tt,code,kbd,samp&#123;line-height:1.5;font-family:tahoma,arial,\"Hiragino Sans GB\",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select&#123;font-size:100%&#125;h1,h2,h3,h4,h5,h6&#123;font-family:tahoma,arial,\"Hiragino Sans GB\",\"微软雅黑\",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,b,strong&#123;font-weight:normal&#125;address,cite,dfn,em,i,optgroup,var&#123;font-style:normal&#125;table&#123;border-collapse:collapse;border-spacing:0;text-align:left&#125;caption,th&#123;text-align:inherit&#125;ul,ol,menu&#123;list-style:none&#125;fieldset,img&#123;border:0&#125;img,object,input,textarea,button,select&#123;vertical-align:middle&#125;article,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu&#123;display:block&#125;audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:\"\\0020\"&#125;textarea&#123;overflow:auto;resize:vertical&#125;input,textarea,button,select,a&#123;outline:0 none;border: none;&#125;button::-moz-focus-inner,input::-moz-focus-inner&#123;padding:0;border:0&#125;mark&#123;background-color:transparent&#125;a,ins,s,u,del&#123;text-decoration:none&#125;sup,sub&#123;vertical-align:baseline&#125;html &#123;overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;&#125;body &#123;font-family: Arial, \"Microsoft Yahei\", \"Helvetica Neue\", Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;&#125;hr &#123;height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;&#125;a &#123;color: #25a4bb;text-decoration: none;&#125; 导入文件reset.css用于解决不同浏览器显示样式不一致的问题，同样在src/assets/styles目录下新建文件reset.css,内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * Eric Meyer's Reset CSS v2.0 (http://meyerweb.com/eric/tools/css/reset/) * http://cssreset.com */html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header,menu, nav, output, ruby, section, summary,time, mark, audio, video, input &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font-weight: normal; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125;/* custom */a &#123; color: #7e8c8d; text-decoration: none; -webkit-backface-visibility: hidden;&#125;li &#123; list-style: none;&#125;::-webkit-scrollbar &#123; width: 5px; height: 5px;&#125;::-webkit-scrollbar-track-piece &#123; background-color: rgba(0, 0, 0, 0.2); -webkit-border-radius: 6px;&#125;::-webkit-scrollbar-thumb:vertical &#123; height: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;&#125;::-webkit-scrollbar-thumb:horizontal &#123; width: 5px; background-color: rgba(125, 125, 125, 0.7); -webkit-border-radius: 6px;&#125;html, body &#123; width: 100%;&#125;body &#123; -webkit-text-size-adjust: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 在项目的入口文件main.js中引入boder.css和reset.css 12345678910111213141516import 'styles/reset.css';import 'styles/border.css';import 'styles/iconfont.css';import Vue from 'vue';import App from './App';import router from './router';Vue.config.productionTip = false;/* eslint-disable no-new */new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;',&#125;); 在项目中安装stylus stylus简化了css的书写，可以理解成封装了css的框架。 1.在项目根目录打开命令行，输入命令：npm install stylus --save安装stylus; 2.还需要安装stylus-loader,输入命令：npm install stylus-loader --save 安装完成后在根目录下的node_modules目录中可以看到stylus和stylus-loader文件夹： 安装fastclick解决移动端点击延迟问题，在项目根目录打开命令行，执行npm install fastclick --save在入口文件中引入fastclick,打开main.js，添加内容import fastClick from &#39;fastclick&#39;;,使用fastclick中的attach方法，将应用范围锁定在document.body. 123456789101112131415161718import 'styles/reset.css';import 'styles/border.css';import 'styles/iconfont.css';import fastClick from 'fastclick';import Vue from 'vue';import App from './App';import router from './router';fastClick.attach(document.body);Vue.config.productionTip = false;/* eslint-disable no-new */new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;',&#125;); 至此，准备就绪，下面开始案例开发。 创建Header.vue模板 在src目录下创建pages文件夹，在文件夹中home文件夹，在home文件夹下创建Home.vue模板，然后再创建components文件夹，在里面创建Header.vue模板，最终的目录结构如下： 定义Header.vue模板内容： 1234567891011121314&lt;template&gt; &lt;div &gt; &lt;div&gt;返回&lt;/div&gt; &lt;div&gt;输入城市/景点/游玩&lt;/div&gt; &lt;div&gt;城市&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeHeader',&#125;;&lt;/script&gt;&lt;style &gt;&lt;/style&gt; 在home.vue中引入Header模板内容： 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;home-header&gt;&lt;/home-header&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HomeHeader from './components/Header';export default &#123; name: 'Home', components: &#123; HomeHeader, &#125;,&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 修改路由中的内容： 123456789101112131415import Vue from 'vue';import Router from 'vue-router';import Home from '@/pages/home/Home';Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: '/', name: 'Home', component: Home, &#125;, ],&#125;); 根结点App.vue中的内容： 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App',&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 页面效果如下： 为页面添加样式 在Header.vue中添加样式： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div class=\"header\"&gt; &lt;div class=\"header-left\"&gt;返回&lt;/div&gt; &lt;div class=\"header-input\"&gt;输入城市/景点/游玩&lt;/div&gt; &lt;div class=\"header-right\"&gt;城市&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HomeHeader',&#125;;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt; @import \"~styles/varibles.styl\" .header display: flex line-height: .86rem background: $bgColor color: #fff .header-left width: .64rem float: left .back-icon text-align: center font-size: .7rem .header-input flex: 1 height: .64rem line-height: .64rem margin-top: .12rem margin-left: .2rem background: #ffffff border-radius: .5rem 0rem color: #cccT padding-left: .2rem .header-right width: 1.24rem float: right text-align: center .arrow-icon font-size: .4rem margin-left: -.08rem&lt;/style&gt; 最终的页面效果如下： 使用iconfont为页面添加图标 下面简单介绍一下如何从iconfont上获取图标： 点击iconfont,进入阿里巴巴失量图标库。 1.注册帐号并创建项目 2.在页面搜索框中查找要使用的图标，然后点击添加入库。 3.点击页面右上角购物车图标，打开的页面中会显示你入库的所有图标，然后点击添加进项目。 4.进入你的项目页面,点击下载至本地，会将你列表里的图标以压缩文件的形式全部保存至本地。 5.在项目src/assets/styles目录下新建iconfont文件夹，从下载的压缩包中自制以下几个文件到iconfont文件夹中： 将iconfont.css复制到styles文件夹下。 6.修改Header.vue模板文件中的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;header-left&quot;&gt; &lt;div class=&quot;iconfont back-icon&quot;&gt;&amp;#xe602;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;header-input&quot;&gt; &lt;span class=&quot;iconfont&quot;&gt;&amp;#xe601;&lt;/span&gt; 输入城市/景点/游玩&lt;/div&gt; &lt;div class=&quot;header-right&quot;&gt;城市 &lt;span class=&quot;iconfont arrow-icon&quot;&gt;&amp;#xe60e;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;HomeHeader&apos;,&#125;;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt; @import &quot;~styles/varibles.styl&quot; .header display: flex line-height: .86rem background: $bgColor color: #fff .header-left width: .64rem float: left .back-icon text-align: center font-size: .7rem .header-input flex: 1 height: .64rem line-height: .64rem margin-top: .12rem margin-left: .2rem background: #ffffff border-radius: .5rem 0rem color: #ccc padding-left: .2rem .header-right width: 1.24rem float: right text-align: center .arrow-icon font-size: .4rem margin-left: -.08rem&lt;/style&gt; &amp;#xe602;、&amp;#xe601;、&amp;#xe60e;是图标的字符编码，从iconfont获取，在项目列表中将鼠标放置图标上，点击自制代码即可； 至此，我们的案例已全部完成，快看看我们的成果吧！ 附 代码优化 给路径起别名 在vue中@符号即代表src目录，@便是src的别名，项目中经常会用到src/assets/sytles这个路径，同样可以起个别名来简化书写。打开文件build/webpack.base.conf.js,找到&#39;@&#39;: resolve(&#39;src&#39;),这行内容，在后面添加&#39;styles&#39;: resolve(&#39;src/assets/styles&#39;),即可。 添加全局变量 将网站的主题颜色作为一个全局变量进行存储，在代码中引用，以便能够灵活的修改网站主题颜色。 在src/assets/styles目录下新建文件varibles.styl,添加内容$bgColor=#00bcd4： 使用的时候通过@import &quot;~styles/varibles.styl&quot;引入，直接使用变量名即可： 12.header background: $bgColor 本章的重点在于模板的配置及引入，和第三方依赖的安装，还有styluscss样式的开发，另外还介绍了iconfont在项目中的应用，如对css样式的设置还有疑问的话可以百度进行学习，用得多了也就能得心应手了。学习在于点滴的积累，各位加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（四）router路由","slug":"vue04","date":"2019-02-24T07:54:39.000Z","updated":"2019-04-20T03:07:17.749Z","comments":true,"path":"2019/02/24/vue04/","link":"","permalink":"https://www.chenende.top/2019/02/24/vue04/","excerpt":"前言通过router可以将地址栏中的访问路径跟页面绑定，通过简单的配置实现页面的跳转。 router配置首先看一下router在目录中的位置","text":"前言通过router可以将地址栏中的访问路径跟页面绑定，通过简单的配置实现页面的跳转。 router配置首先看一下router在目录中的位置 router目录中只有一个index.js文件，路径的配置就是在这个文件中完成的。 123456789101112131415import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 初始配置中导入了components中的HelloWord组件，然后在export default new Router中配置了当访问/根路径的时候展示组件中的内容。路径的配置就是在这部分完成的。 123path:表示访问路径name:表示组件名称component：表示使用哪个组件 清空HelloWord组件中多余的内容，使其恢复vue原始模板，然后在里面&lt;templent&gt;添加内容&lt;div&gt;hello word&lt;/div&gt;: 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;div&gt;hello word&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld',&#125;&lt;/script&gt;&lt;style scoped&gt; &lt;/style&gt; 修改App.vue中的内容,清除多余的内容： 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; &lt;router-view/&gt;表示使用路由视图，展示是的路由中配置的路径为/的模板中的内容。启动项目：npm run start 可以看到展示的HelloWord模板中的内容。在这里App.vue作为整个项目的根结点，通过&lt;router-view/&gt;路由引用到了HelloWord组件。没有根结点的引用和路由的设置，模板中的内容是无法展示的，通过这个简单的案例要能领会到这点。 案例一在地址栏中输入localhost:8080/#/list路由到list页面 1.在src目录下创建list文件夹，然后创建List.vue文件。 2.在文件中输入内容：12345678910111213&lt;template&gt; &lt;div&gt;list&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'List'&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.配置路由在打开router下的index.js文件，导入List组件，并配置路由信息： 1234567891011121314151617181920212223import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import List from '@/list/List'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;, &#123; path: '/list', name: 'List', component: List &#125; ]&#125;)import 路径中的`@`符号代表`src`目录，在`sty`中使用路径时需要在前面加个`～`，即`～@` 4.重启项目：npm run start,在地址栏中输入http://localhost:8080/#/list，就可以看到成功路由到了list页面。 注意：如果使用了ESlint语法检测，一定要符合语法要求，不然在项目运行编译的过程会报错，导致项目启动失败。 案例二在主页添加list连接，点击后进行list页面 1.在上页面案例的基础上进行修改，首先打开HelloWord组件，在&lt;template&gt;中添加内容&lt;router-link to=&quot;/list&quot;&gt;访问list&lt;/router-link&gt;，完整代码如下： 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt;hello word&lt;/div&gt; &lt;router-link to=\"/list\"&gt;访问list&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld'&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; &lt;router-link to=&quot;/list&quot;&gt;访问list&lt;/router-link&gt;作用等同于&lt;a href=&quot;/list&quot;&gt;访问list&lt;/a&gt;，是vue中的书写方法。 打开浏览器页面显示为： 点击链接成功进入list页面。 通过本章练习，要求能够熟记体会到vue中路由的作用，能够熟练的进行配置。知识在于点滴的积累，各位加油!","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（三）组件化案例练习","slug":"vue03","date":"2019-02-21T14:32:34.000Z","updated":"2019-04-20T03:07:18.489Z","comments":true,"path":"2019/02/21/vue03/","link":"","permalink":"https://www.chenende.top/2019/02/21/vue03/","excerpt":"前言通过本章案例对vue的数据绑定、组件、事件、父子组件间传值可以进行初步的认识，对vue的语法格式要有初步的了解。 1.案例展示通过vue的数据绑定，简单实现数据在input框中的展示和提交，提交后在输入框下方展示。点击提交后展示的某条数据，进行删除操作。","text":"前言通过本章案例对vue的数据绑定、组件、事件、父子组件间传值可以进行初步的认识，对vue的语法格式要有初步的了解。 1.案例展示通过vue的数据绑定，简单实现数据在input框中的展示和提交，提交后在输入框下方展示。点击提交后展示的某条数据，进行删除操作。 2.案例实现 在编辑器中（推荐sublime或IDEA）打开项目，找到src目录下的App.vue，这是项目的根结点，页面最终展示的内容就是在这个文件中定义的。 清除文件中多余的内容，只留下代码结构，展示如下： 123456789101112131415&lt;template&gt; &lt;div&gt; //此处用来定义页面展示标签 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; //此处用来定义数据、方法、模块... &#125;&lt;/script&gt;&lt;style&gt; //用来定义显示样式&lt;/style&gt; 注意：&lt;template&gt;标签中的内容需要被包裹在&lt;div&gt;中，也就是说不能有两个&lt;div&gt;，只能由一个作为根结点。 接着在&lt;template&gt;标签中填充内容，定义一个input输入框和一个提交按钮。 12&lt;input type=&quot;text&quot;/&gt; &lt;button @click = &quot;handleSubmit&quot;&gt;提交&lt;/button&gt; 接下来介绍vue的第一个知识点：数据绑定v-model=&quot;自定义名称&quot;，下面我们就把这它用在标签上，用来替代使用dom操作获取指定标签的value的操作。 1.首先在&lt;input&gt;标签上添加v-model=&quot;自定义名称&quot;： &lt;input v-model = &quot;inputvalue&quot;/&gt;; 2.在&lt;script&gt;的export default中对绑定的元素进行初始化： 123456data () &#123; return &#123; inputvalue: '', list: [] &#125; &#125; 注意格式，绑定的数据必须写在return中，且是大括号。 知识点二：添加click事件，使用@click=&quot;方法名&quot; 1.首先在&lt;script&gt;的export default中定义方法handleSubmit: 12345678methods: &#123; handleSubmit () &#123; //往集合中添加数据 this.list.push(this.inputvalue) //清空input框中的数据 this.inputvalue = '' &#125; &#125; 2.在&lt;button&gt;标签中绑定方法： &lt;button @click = &quot;handleSubmit&quot;&gt;提交&lt;/button&gt; 使用npm run start启动项目，打开网址”http://localhost:8080&quot;,按F12打开开发者工具，如果没有错误信息，说明代码运行正常。测试代码功能是否正常，输入内容点击提交，如果内容能被清空，那就OK了。 知识点三：使用组件vue将页面拆分成多个组件，存储在src/components目录中。 1.初始化的项目中存在一个HelloWorld.vue的组件，清除多作内容，保留原始结构： 12345678910111213&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 使用上同父组件即App.vue是一样的。 2.在&lt;template&gt;中定义组件内容：&lt;li&gt;hello&lt;/li&gt; 3.在App.vue中导入子组件HelloWorld 在&lt;script&gt;中插入代码：import HelloWorld from &#39;./components/HelloWorld&#39; 在export default中对子组件的使用进行定义： 1234 components: &#123; 'todo-list': HelloWorld &#125;` 在&lt;template&gt;中使用定义的子标签： 123&lt;ul&gt; &lt;todo-list&gt;&lt;/todo-list&gt;&lt;/ul&gt; 打开浏览器，可以看到页面中显示了子组件中的内容hello 此时App.vue中的代码如下 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;template&gt; &lt;div&gt; &lt;input v-model = &quot;inputvalue&quot;/&gt; &lt;button @click = &quot;handleSubmit&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;todo-list&gt;&lt;/todo-list&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import HelloWorld from &apos;./components/HelloWorld&apos; export default &#123; components: &#123; &apos;todo-list&apos;: HelloWorld &#125;, data () &#123; return &#123; inputvalue: &apos;&apos;, list: [] &#125; &#125;, methods: &#123; handleSubmit () &#123; this.list.push(this.inputvalue) this.inputvalue = &apos;&apos; &#125; &#125; &#125; &lt;/script&gt; &lt;style&gt; &lt;/style&gt;子组件`HelloWorld`中的代码如下： &lt;template&gt; &lt;div&gt; &lt;li&gt;hello&lt;/li&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; &#125; &lt;/script&gt; &lt;/style&gt; 知识点四：遍历数组 使用子组件遍历展示list中的内容，需要在中添加v-for=&quot;(item,index) of list： &lt;todo-list v-for=&quot;(item,index) of list&quot;&gt;&lt;todo-list&gt; 然而子组件中的展示的内容是被我们写死的，要想动态展示提交的内容就需要用到下面的知识点。 父组件向子组件传值 1.在父组件的&lt;todo-list&gt;标签中向子组件传值：:content=&quot;item&quot;； 2.在子组件的export default中接收父组件传递的值： 123export default &#123; props: ['content','index'] &#125; 3.使用插值表达式，替换子组件中被写死的内容： 1&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt; 至此，案例已完成百分之七下，就剩下一个删除操作了。你可以打开浏览器小小的兴奋一下，回顾一下代码体会一每个知识点的写法及应用。 知识点五：子组件向父组件传值 1.向子组件传递list的索引值，告诉子组件你要删除哪条数据1234&lt;todo-list v-for=\"(item,index) of list\" :key=\"index\" :index=\"index\" &gt;&lt;/todo-list&gt; 注意：：key和：index的写法是固定的，：是关键符号即表示向子组件传值，item是自定义的名称，表示list中的元素， list即数组要跟数据绑定中定义的一致。 2.在子组件中接收父组件传递的值：props: [&#39;index&#39;],3.在父组件定义删除事件：12345678910methods: &#123; handleSubmit () &#123; this.list.push(this.inputvalue) this.inputvalue = '' &#125;, handleDelete (index) &#123; //splice删除数据组中的元素，参数一：索引值;参数二：删除的元素个数; this.list.splice(index, 1) &#125; &#125; 4.使用@delete监听子组件的删除操作，如果监听到就会启用handleDelete方法，从list删除中删除指定索引的数据12345&lt;todo-list v-for=\"(item,index) of list\" :key=\"index\" :index=\"index\" @delete=\"handleDelete\"&gt;&lt;/todo-list&gt; 5.在子组件的export default中定义handleDelete方法，用于触发父组件中的删除操作：12345methods:&#123; handleDelete () &#123; this.$emit('delete',this.index) &#125; &#125; 注意：this.$emit中第一个参数即方法名，必须跟父组件@监听的方法名称一致。 6.给子组件绑定click事件： 1&lt;li @click=\"handleDelete\"&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt; 以下是最终的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667App.vue: &lt;template&gt; &lt;div&gt; &lt;input v-model = &quot;inputvalue&quot;/&gt; &lt;button @click = &quot;handleSubmit&quot;&gt;提交&lt;/button&gt; &lt;ul&gt; &lt;todo-list v-for=&quot;(item,index) of list&quot; :key=&quot;index&quot; :content=&quot;item&quot; :index=&quot;index&quot; @delete=&quot;handleDelete&quot; &gt;&lt;/todo-list&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import HelloWorld from &apos;./components/HelloWorld&apos; export default &#123; components: &#123; &apos;todo-list&apos;: HelloWorld &#125;, data () &#123; return &#123; inputvalue: &apos;&apos;, list: [] &#125; &#125;, methods: &#123; handleSubmit () &#123; this.list.push(this.inputvalue) this.inputvalue = &apos;&apos; &#125;, handleDelete (index) &#123; this.list.splice(index, 1) &#125; &#125; &#125; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 子组件`HelloWorld`: &lt;template&gt; &lt;div&gt; &lt;li @click=&quot;handleDelete&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; props: [&apos;content&apos;,&apos;index&apos;], methods:&#123; handleDelete () &#123; this.$emit(&apos;delete&apos;,this.index) &#125; &#125; &#125; &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 至此，整个案例已全部完成。大家在练习的时候切勿想要一口气吃成胖子，需一个知识点一个知识点的练习和理解。知识在于积累和总结，希望我们能够共同成长，加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（二）在windows上的安装及部署","slug":"vue02","date":"2019-02-20T14:12:58.000Z","updated":"2019-04-20T03:07:18.089Z","comments":true,"path":"2019/02/20/vue02/","link":"","permalink":"https://www.chenende.top/2019/02/20/vue02/","excerpt":"前言vue在windows上的安装相比与ubuntu要稍麻烦一点，安装方式虽有不同，但方法是一致的。 安装nodejs(与ubuntu不同的是，windows在安装nodejs的时候会自动安装npm) 安装vue-cli 更新npm安装源 配置环境变量 创建新项目 1.安装nodejs1.进入nodejs官网选择windows版本进行下载。 2.下载完成后双击安装包，选择安装目录一路点击下一步直到完成安装即可。 3.使用nodejs -v 和npm -v 验证nodejs和npm是否安装成功。（能看到版本信息即表示成功）","text":"前言vue在windows上的安装相比与ubuntu要稍麻烦一点，安装方式虽有不同，但方法是一致的。 安装nodejs(与ubuntu不同的是，windows在安装nodejs的时候会自动安装npm) 安装vue-cli 更新npm安装源 配置环境变量 创建新项目 1.安装nodejs1.进入nodejs官网选择windows版本进行下载。 2.下载完成后双击安装包，选择安装目录一路点击下一步直到完成安装即可。 3.使用nodejs -v 和npm -v 验证nodejs和npm是否安装成功。（能看到版本信息即表示成功） 4.设置缓存和全局安装 * 首先在nodejs根目录下创建两个文件夹node_cache(用于nodejs系统缓存)另一个node_global(作为全局安装的存储位置) * 使用命令设置缓存文件夹：`npm config set cache &quot;D:\\vueProject\\nodejs\\node_cache&quot;` * 使用命令设置全局模块存放位置： npm config set prefix &quot;D:\\vueProject\\nodejs\\node_global&quot;。 2.更新npm安装源由于npm的安装源在国外，国内下载速度会很慢。因此需要下载cnpm，将其改为国内（阿里巴巴淘宝镜像服务器）。 1切换安装源： npm install -g cnpm --registry=https://registry.npm.taobao.org 3.设置环境变量12NODE_PATH = F:\\set-soft\\Node\\nodejs;PATH = %NODE_PATH%\\;%NODE_PATH%\\node_modules;%NODE_PATH%\\node_global; 设置完成后使用npm install XXX -g安装的模块就会被存放在指定位置。 4.安装vue 使用命令cnpm install vue -g 安装vue命令行工具，即vue-cli脚手架，cnpm install vue-cli -g 完成安装后在命令行输入vue -V验证安装是否成功 5.构造项目使用命令：vue init webpack 项目名称，回车后按提示执行下面构建步奏： 第一项：项目名称，即输入你定义的项目名称 第二项：项目描述，输入信息描述 第三项：如何构建项目，默认选择第一项即可 第四项：是否安装vue-route路由，不需要输入n即可 第五项：是否使用ESlint代码规范,输入y 第六项：是否使用自动化测试工具,输入n 第七项：项目里面包和依赖的安装采用npm还是yern进行安装，选择node 初始化完成之后会看到Project initialization finished!的提示，在指定路径下会生成项目文件夹，名称就是你定义的项目名称。 6.目录结构不管是在ubuntu还是windows,目录结构是一致的。 build :最终发布代码的存放位置 config :配置目录，包括端口号等，初学可以使用默认的。 node_modules :这是执行npm install后产生的，包含了Nodejs和npm依赖的文件以及后续安装的第三方组件或者第三方功能。 src :开发目录，用于存放页面相关的文件，基本上要做的事情都在这个目录里。其中还包含了以下几个目录入文件： assets :放置图片，如：logo等； components :存放组件文件； App.vue ：主文件，项目入口文件，可以直接将组件写在这里而不使用components目录； main.js :项目的核心文件； router :项目路由配置； static :存储静态资源，如图片、字体等; 7.启动项目cnpm run dev访问地址：http://localhost:8080. 注意：必须要在项目根目录执行 windows在安装和使用过程中容易出现各种问题，一般是由安装和配置错误所导致，在遇到问题的时候根据错误提示进行排查再结合安装文档应该可以找到问题原因。成长源于持续积累和总结，希望我们能共同成长，加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"vue实战之（一）在ubuntu中安装及项目构建","slug":"vue01","date":"2019-02-19T16:30:25.000Z","updated":"2019-04-20T01:46:56.372Z","comments":true,"path":"2019/02/20/vue01/","link":"","permalink":"https://www.chenende.top/2019/02/20/vue01/","excerpt":"前言开发环境是ubuntu，如果是windows需自行百度相关内容。 安装前的准备工作因为vue是基于node.js的，在安装vue之前需要先行安装node.js，最行版本因为不稳定，所以不建议安装。在构建项目时候还依赖npm,所以还需要安装npm. 1.安装node.js123456更新ubuntu软件源sudo apt-get update安装node.jssudo apt-get install nodejs安装npmsudo apt-get install npm 安装完成之后，使用命令nodejs -v和npm -v可以看到版本号即表示安装成功。","text":"前言开发环境是ubuntu，如果是windows需自行百度相关内容。 安装前的准备工作因为vue是基于node.js的，在安装vue之前需要先行安装node.js，最行版本因为不稳定，所以不建议安装。在构建项目时候还依赖npm,所以还需要安装npm. 1.安装node.js123456更新ubuntu软件源sudo apt-get update安装node.jssudo apt-get install nodejs安装npmsudo apt-get install npm 安装完成之后，使用命令nodejs -v和npm -v可以看到版本号即表示安装成功。 2.安装vuevue官方为方便用户使用，推出了vue-cli脚手架工具，用于构建项目模板，安装vue即安装vue-cli.此外项目的构建用到了webpack，需手动安装。 安装vue-cli 1npm install --global vue-cli 安装webpack 1npm install webpack -g 安装完成这后使用命令vue -V,可以看到安装的版本号。 注意:npm的版本需要在6.8.0及以上。可以使用npm install -g npm进行升级。 项目开发中用到的版本控制工具是git,此处不再赘述请自行百度。 3.项目构建在完成安装之后就可以开始构建项目了，在指定位置使用命令vue init webpack 你的项目名称 回车后会提示你进行项目配置： Project name (vuetest) 项目名称，可以自己指定，也可直接回车，按照括号中默认名字。 Project description (A Vue.js project) 项目描述，也可直接点击回车，使用默认名字。 Author 作者，可以自己指定，也可直接回车。 接下来会让用户选择 Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了 Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y/n) 是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y/n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，并不会影响整体的运行。 Setup unit tests with Karma + Mocha? (Y/n) 是否安装单元测试。ege Setup e2e tests with Nightwatch(Y/n)? 是否安装e2e测试。Should we run ‘npm install’ for you after the project has been created?按需，这里我选Yes, use NPM。如果选No，后续自己在目标 初始化完成之后会看到Project initialization finished!的提示，在指定路径下会生成项目文件夹，名称就是你定义的项目名称。 4.目录结构打开文件夹可以看到生成的目录结构： &emsp;&emsp;build下放的是配置文件 &emsp;&emsp;config:针对开发环境和线上环境的配置文件 &emsp;&emsp;node_modules:项目依赖 &emsp;&emsp;src:源代码 &emsp;&emsp;static:静态资源 &emsp;&emsp;/* 文件针对babelrc的编译、浏览器的配置及ESlint语法检测的说明 &emsp;&emsp;idex.html整个项目最外层的主页，里面有一个id=”app”的挂载点，用于挂载根实例。 &emsp;&emsp;src下的man.js文件是整个项目的入口文件 更多内容请关注VUE官方文档说明,成长在于点滴和积累和总结，希望我们能够共同成长，加油！","categories":[{"name":"vue入门","slug":"vue入门","permalink":"https://www.chenende.top/categories/vue入门/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.chenende.top/tags/vue/"}]},{"title":"git系列之初始化配置","slug":"git3","date":"2019-02-19T13:18:56.000Z","updated":"2019-05-27T19:50:31.280Z","comments":true,"path":"2019/02/19/git3/","link":"","permalink":"https://www.chenende.top/2019/02/19/git3/","excerpt":"前言在成功安装git后需要进行一些初始化设置，设置用户名和密码，设置ssh密钥跟服务器建立对应关系。完成这些配置后才能拉取和提交代码。 git初始化配置1.首先需要配置用户名和密码（即邮件地址），在提交代码的时候会用到。12git config --global user.name \"xxx\"git config --global user.email xxx@163.com 使用–global选项即设置了全局的用户名和密码，如果想要针对特定项目使用不同的用户名和密码，可以在那个项目目录下运行不带global选项的命令来配置。 2.检查配置信息123git config --list 列出所有git配置信息也可以通过 git config user.name(属性名) 检查git某一项配置","text":"前言在成功安装git后需要进行一些初始化设置，设置用户名和密码，设置ssh密钥跟服务器建立对应关系。完成这些配置后才能拉取和提交代码。 git初始化配置1.首先需要配置用户名和密码（即邮件地址），在提交代码的时候会用到。12git config --global user.name \"xxx\"git config --global user.email xxx@163.com 使用–global选项即设置了全局的用户名和密码，如果想要针对特定项目使用不同的用户名和密码，可以在那个项目目录下运行不带global选项的命令来配置。 2.检查配置信息123git config --list 列出所有git配置信息也可以通过 git config user.name(属性名) 检查git某一项配置 3.生成SSH公钥想要提交代码到git服务器，就需要生成SSH公钥并在服务器端进行配置。 首先确认是否已经生成过，默认情况下用户的SSH密钥存储在~/.ssh目录下。看一下是否存在名为id_dsa和id_rsa的文件，后缀为.pub的文件是公钥，另一个是私钥。 如果指定目录下不存在上述两个文件，则需要通过命令ssh-keygen来创建它们。 $ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/Users/schacon/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/schacon/.ssh/id_rsa. Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub. The key fingerprint is: 43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local 三处需要手动确认的地方：第一处要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。 公钥生成后，打开.pub文件复制全部内容，粘贴到服务器端中的SSH配置项中即可。 git远程仓库地址有两种形式，http和ssh;两者的区别在于ssh协议要比http安全性更高，如果开发环境是在公司局域网内，则无法使用ssh协议拉取和提交代码。使用http协议则可以。此外使用http协议每次拉取和提交代码都需要输入用户名和密码，使用ssh则不用。当然你可以进行配置，只需要在首次使用http协议拉取代码的时候输入用记名和密码，之后就可以不用输入。按照如下设置可只输入一次，具体操作如下： 1234567891011记住密码（默认15分钟）：git config --global credential.helper cache自己定义时间（一小时后失效）：git config credential.helper 'cache --timeout=3600'永久存储密码：git config --global credential.helper store 知识在于持续的积累和总结，各位加油！","categories":[{"name":"git","slug":"git","permalink":"https://www.chenende.top/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.chenende.top/tags/git/"}]},{"title":"git系列之命令进阶","slug":"git2","date":"2019-02-19T12:19:20.000Z","updated":"2019-04-19T14:40:51.847Z","comments":true,"path":"2019/02/19/git2/","link":"","permalink":"https://www.chenende.top/2019/02/19/git2/","excerpt":"前言在掌握了基本的git命令后，在工作中或许你还会遇到其它一些问题，比如取消使用add加入到暂存区的代码，或者是commit到本地仓库中的代码，又或者是取消对于文件的修改… git的进阶命令1. 创建git本地仓库1git init 2.取消暂存如何操作暂存区域与工作目录中已修改的文件， 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你：1234567$ git add *$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) renamed: README.md -&gt; README modified: CONTRIBUTING.md","text":"前言在掌握了基本的git命令后，在工作中或许你还会遇到其它一些问题，比如取消使用add加入到暂存区的代码，或者是commit到本地仓库中的代码，又或者是取消对于文件的修改… git的进阶命令1. 创建git本地仓库1git init 2.取消暂存如何操作暂存区域与工作目录中已修改的文件， 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你：1234567$ git add *$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) renamed: README.md -&gt; README modified: CONTRIBUTING.md 在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD … 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件：12345678910111213141516$ git reset HEAD CONTRIBUTING.mdUnstaged changes after reset:MCONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) renamed: README.md -&gt; READMEChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in workingdirectory) modified: CONTRIBUTING.md 2.1取消全部暂存内容 1git reset HEAD * 2.2 删除本地缓存1git rm -r --cached . 二者的区别在于，前者取消的是你本次暂存的内容，后者会将全部代码从缓存区中清除，包括已提交的，通常情况下使用前者，后者极少使用。 3.忽略指定文件提交一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore的文件，列出要忽略的文件模式。 来看一个实际的例子：123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好.gitignore 文件的习惯，以免将来误提交这类无用的文件。 文件 .gitignore 的格式规范如下：1234567 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 语法规范： 123456789101112# 忽略 .a 文件*.a# 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件!lib.a# 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO/TODO# 忽略 build/ 文件夹下的所有文件build/# 忽略 doc/notes.txt, 不包括 doc/server/arch.txtdoc/*.txt# 忽略所有的 .pdf 文件 在 doc/ directory 下的doc/**/*.pdf 在java IDEA中的配置 123456789101112# 忽略 指定扩展名的文件*.md*.cmd*.iml# 忽略 文件夹下的所有文件logs/target/.idea/.mvn# 忽略 指定名称的文件mvnw.gitignore 4.撤销修改12git checkout 文件名 / git checkout . 表示撤销所有修改执行命令后即可撤销对指定文件的修改 想要了解更多详细信息可以点击进入参数资料中进行查看。知识在于持续的积累和总结，各位加油！","categories":[{"name":"git","slug":"git","permalink":"https://www.chenende.top/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.chenende.top/tags/git/"}]},{"title":"git系列之常用命令","slug":"git","date":"2019-02-16T16:24:05.000Z","updated":"2019-03-06T13:54:07.495Z","comments":true,"path":"2019/02/17/git/","link":"","permalink":"https://www.chenende.top/2019/02/17/git/","excerpt":"前言首先明确一个概念：git由三个存储位置组成，缓存、本地仓库、远程仓库； 使用git add命令是将代码加入到缓存中。 使用git commit命令是将代码提交到本地仓库。 使用git push命令才是最终的提交，即提交到远程仓库。 这三个命令需依次执行，如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式git commit -a; 基本命令1.查看分支状态; 12通常用来检查代码冲突、是否有新的变更没有提交。git status 2.拉取代码 12git clone 后面跟git仓库地址需要注意的是：拉取代码后需要使用checkout检出你的分支，不然的话所处位置是master，代码会无法提交。","text":"前言首先明确一个概念：git由三个存储位置组成，缓存、本地仓库、远程仓库； 使用git add命令是将代码加入到缓存中。 使用git commit命令是将代码提交到本地仓库。 使用git push命令才是最终的提交，即提交到远程仓库。 这三个命令需依次执行，如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式git commit -a; 基本命令1.查看分支状态; 12通常用来检查代码冲突、是否有新的变更没有提交。git status 2.拉取代码 12git clone 后面跟git仓库地址需要注意的是：拉取代码后需要使用checkout检出你的分支，不然的话所处位置是master，代码会无法提交。 3.查看远程分支 1git branch -a 4.检出分支 12结合上面的命令从远程分支中复制你要拉取的分支，然后使用：git checkout 你复制的分支名称 5.查看本地分支 1git branch 6.切换分支 123456结合使用上面两条命令1. 首先查看本地有哪些分支 git branch2. 然后复制你要切换的分支名称，然后使用： git checkout 粘贴分支名称，回车即可3. 使用 git branch 即可看到你已经切换到了指定的分支（高亮显示的即为当前分支） 7.提交代码 1234561.首先将代码加入缓存(即暂存区)：git add -A 或 git add . (注意后面的.别丢了) 两者都表示提交所有修改过的文件到暂存区，区别在于，前者包含删除记录，就是说如果你删除了某个文件，在最终的提交完成后会同步删除远程仓库中的文件。而后者会忽略。 如果只想提交某个文件，则使用命令：git add 文件名2.再提交到本地仓库: git commit -m \"备注信息\" 注意：不管是在图形界面提交还是命令行，都需要填写备注信息。3.最后push到远程仓库: git push 进阶命令在进一步的使用中，你可能会有更多的需求，比如撤销和恢复提交，查看改动内容… 首先认识一个命令，查看提交记录： 1git log 执行后的内容显示如下： 123456789101112131415161718commit e4297946a21bf23cc61bb7ba0b77cf30def01152Author: chenende &lt;m17600201360@163.com&gt;Date: Fri Feb 8 02:55:49 2019 +0800 editcommit a1b9fd1e099fc2cf747e16d7f076e73b36778262 (origin/master, origin/HEAD, master)Author: chenende &lt;m17600201360@163.com&gt;Date: Fri Feb 8 02:46:27 2019 +0800 commitcommit 553e5b5dd8857e310dd6818be07e214f0781df97Author: chenende2019 &lt;47429337+chenende2019@users.noreply.github.com&gt;Date: Fri Feb 8 02:26:57 2019 +0800 Initial commit: 现在看到的是三条提交记录，当然往下翻的话可能还有更多，最先显示的是你最后提交的一次记录。其中commit 后面跟的是记录ID（执行撤销或恢复提交的时候会用到），Author后面是提交人，Date后面是提交日期，下面单独显示的是你提交时填写的备注信息。 9.回滚本地分支 12git reset --hard (commid id)注意：commid id 是你要恢复到的位置 10.回滚远程分支 123456 先回滚本地分支： git reset --hard (commit id) 然后再强推到远程分支： git push origin HEAD --force 注意：这一步很重要，如果不执行这一步的话分发生远程仓库的代码和本地不一致的情况。且查看日志记录是已经加滚了的。` 11.删除本地分支 1git branch -D (branchName) 12.删除远程分支 12git branch -r -D (branchName)需要修改强推到主干：git push origin HEAD --force 注意：git命令是区分大小写的。 13.合并分支 12345常用于解决冲突git merge 要合并的分支名称注意：合并分支的时候要确定发布顺序，如果被合并的分支尚在测试中，且晚于你的分支发布，最好不要合并，避免在发布的时候将他人未测试完成的分支也一同发布上去。引发线上问题。另，在合并后切勿修改被合并的分支代码，修改后别人分支中的代码也会跟随改变的。 14.查看代码改动 123456789git diff执行 git diff 来查看执行 git status 的结果的详细信息。git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 * 尚未缓存的改动：git diff * 查看已缓存的改动： git diff --cached * 查看已缓存的与未缓存的所有改动：git diff HEAD * 显示摘要而非整个 diff：git diff --stat 15 更新远程分支 12345678910111213141516chenende@chenende-CN15S:~/application/workScop/vue/Travel$ git remote update origin --prune正在获取 originchenende@chenende-CN15S:~/application/workScop/vue/Travel$ git branch -a index-icons index-swiper* master remotes/origin/HEAD -&gt; origin/master remotes/origin/index-icons remotes/origin/index-swiper remotes/origin/master或者使用`git pull` chenende@chenende-CN15S:~/application/workScop/vue/Travel$ git pull 已经是最新的。 掌握这些命令后，日常开发基本上也就无敌了，如果想要进一步深入了解的话，可以百度或谷歌了解一下git的底层原理。切勿死记硬背，敲得多了自然就熟记于心了。","categories":[{"name":"git","slug":"git","permalink":"https://www.chenende.top/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.chenende.top/tags/git/"}]},{"title":"linux中MySql中文乱码","slug":"linux-mysql","date":"2019-02-08T01:14:32.000Z","updated":"2019-05-28T01:14:04.716Z","comments":true,"path":"2019/02/08/linux-mysql/","link":"","permalink":"https://www.chenende.top/2019/02/08/linux-mysql/","excerpt":"前言在日常开发当中，在代码中使用sql语句向服务器端安装的数据库中插入中文字符串的时候，保存的内容全都成了??? Mysql安装目录 首先打开命令行界面登录MySql，输入命令：show variables like ‘char%’;查看数据库编码.如果 character_set_database 和 character_set_server 的值显示为latin1,就是数据库编码问题了。 123456789101112+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 此时需要修改数据库编码，与windows不一样的是，在linux中安装的程序文件是分散的，并不在同一个文件夹中。以MySql为例，了解一下其文件安装分布吧！","text":"前言在日常开发当中，在代码中使用sql语句向服务器端安装的数据库中插入中文字符串的时候，保存的内容全都成了??? Mysql安装目录 首先打开命令行界面登录MySql，输入命令：show variables like ‘char%’;查看数据库编码.如果 character_set_database 和 character_set_server 的值显示为latin1,就是数据库编码问题了。 123456789101112+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+ 此时需要修改数据库编码，与windows不一样的是，在linux中安装的程序文件是分散的，并不在同一个文件夹中。以MySql为例，了解一下其文件安装分布吧！1234567891011121314151617181920212223242526 安装 sudo apt-get install mysql-server mysql-client 查看安装端口情况 sudo netstat -tap | grep mysql 配置文件位置 sudo vim /etc/mysql/my.cnf 打开关闭服务 /etc/init.d/mysql start/stop​ ​ 其它文件默认位置​ /usr/bin 客户端程序和脚本 /usr/sbin mysqld 服务器 /var/lib/mysql 日志文件，数据库 ［重点要知道这个］ /usr/share/doc/packages 文档 /usr/include/mysql 包含( 头) 文件 /usr/lib/mysql 库 /usr/share/mysql 错误消息和字符集文件 /usr/share/sql-bench 基准程序 也可以使用:whereis mysql命令来找出mysql分布的位置。 解决乱码问题的方式有两种： 1.临时修改编码使用命令：12set character_set_database = utf8;set character_set_server = utf8; 关闭连接后，再次连接，查询发现，字符集又变成latin1 2.修改配置文件1.使用whereis mysql找到mysql存在于哪些目录下123chenende@chenende-CN15S:~$ whereis mysqlmysql: /usr/bin/mysql /usr/lib/mysql /etc/mysql /usr/share/mysql /usr/share/man/man1/mysql.1.gzchenende@chenende-CN15S:~$ cd /etc/mysql 2.打开etc下的mysql目录，可以看到my.cnf文件，由于我的MySql是使用系统命令apt安装的，该配置文件是由系统生成的，可以看到它软链接到了/etc/alternatives/my.cnf文件1234567891011chenende@chenende-CN15S:/etc/mysql$ ll总用量 40drwxr-xr-x 4 root root 4096 2月 7 05:11 ./drwxr-xr-x 139 root root 12288 2月 8 06:19 ../drwxr-xr-x 2 root root 4096 2月 7 22:36 conf.d/-rw------- 1 root root 317 2月 7 05:11 debian.cnf-rwxr-xr-x 1 root root 120 1月 22 02:25 debian-start*lrwxrwxrwx 1 root root 24 12月 28 18:18 my.cnf -&gt; /etc/alternatives/my.cnf-rw-r--r-- 1 root root 839 8月 3 2016 my.cnf.fallback-rw-r--r-- 1 root root 683 2月 7 22:31 mysql.cnfdrwxr-xr-x 2 root root 4096 2月 7 22:37 mysql.conf.d/ 3.查看my.cnf文件1234567891011121314151617181920# The MySQL database server configuration file.## You can copy this to one of:# - \"/etc/mysql/my.cnf\" to set global options,# - \"~/.my.cnf\" to set user-specific options.# # One can use all long options that the program supports.# Run program with --help to get a list of available options and with# --print-defaults to see which it would actually understand and use.## For explanations see# http://dev.mysql.com/doc/mysql/en/server-system-variables.html## * IMPORTANT: Additional settings that can override those from this file!# The files must end with '.cnf', otherwise they'll be ignored.#!includedir /etc/mysql/conf.d/!includedir /etc/mysql/mysql.conf.d/ 可以发现文件中并没有详细的配置内容，而是指向了/etc/mysql/conf.d/ 和/etc/mysql/mysql.conf.d/这两个目录，我们要修改的配置文件就在这两个目录当中。 首先进入/etc/mysql/conf.d/目录：1234567chenende@chenende-CN15S:/etc/mysql$ cd /etc/mysql/conf.d/chenende@chenende-CN15S:/etc/mysql/conf.d$ ll总用量 16drwxr-xr-x 2 root root 4096 2月 7 22:36 ./drwxr-xr-x 4 root root 4096 2月 7 05:11 ../-rw-r--r-- 1 root root 44 2月 7 22:36 mysql.cnf-rw-r--r-- 1 root root 55 8月 3 2016 mysqldump.cnf 修改mysql.cnf文件：添加12[client] default-character-set=utf8 然后进入/etc/mysql/mysql.conf.d/文件夹：12345678chenende@chenende-CN15S:/etc/mysql/conf.d$ cd /etc/mysql/mysql.conf.d/chenende@chenende-CN15S:/etc/mysql/mysql.conf.d$ ll总用量 16drwxr-xr-x 2 root root 4096 2月 7 22:37 ./drwxr-xr-x 4 root root 4096 2月 7 05:11 ../-rw-r--r-- 1 root root 3107 2月 7 22:37 mysqld.cnf-rw-r--r-- 1 root root 21 1月 12 2018 mysqld_safe_syslog.cnfchenende@chenende-CN15S:/etc/mysql/mysql.conf.d$ 修改mysqld.cnf文件：在[mysqld]选项下的skip-external-locking下添加：12345678910111213141516171819202122 character-set-server=utf8 init_connect= SET NAMES utf8所有修改完成之后重启MySql服务：sudo service mysql restart;在终端登录MySql,再次使用`show variables like'char%'`查看数据库编码： +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+character_set_server和character_set_database 都已显示为utf8即表示正常。 3.日常开发注意事项：在创建数据库及表的时候要声明编码：12345678910111213141516171819声明数据库编码： GBK: create database test2 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; UTF8: CREATE DATABASE test2 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;声明表编码： use dbtest; drop table if exists tbtest; create table tbtest( id int(10) auto_increment, user_name varchar(60) CHARACTER SET GBK COLLATE gbk_chinese_ci, email varchar(60), PRIMARY key(id) )CHARACTER SET utf8 COLLATE utf8_general_ci; 此外开发工具的字符集也要和数据库保持一致，才能很大程序的乱码问题的困扰。","categories":[{"name":"MySql","slug":"MySql","permalink":"https://www.chenende.top/categories/MySql/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://www.chenende.top/tags/MySql/"},{"name":"linux","slug":"linux","permalink":"https://www.chenende.top/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.chenende.top/tags/ubuntu/"}]},{"title":"ubuntu中sublimeText3中文输入","slug":"ubuntu-sublime-text3","date":"2019-02-07T17:29:55.000Z","updated":"2019-02-24T19:18:39.788Z","comments":true,"path":"2019/02/08/ubuntu-sublime-text3/","link":"","permalink":"https://www.chenende.top/2019/02/08/ubuntu-sublime-text3/","excerpt":"前言sublimeText虽说可以跨平台使用，但是在linux下缺少对中文的支持。 解决sublimeText3不支持中文输入1.从github下载sublime-text-imfix程序，添加中文支持 git clone https://github.com/lyfeyaj/sublime-text-imfix.git 2.将subl移动到/usr/bin/，并且将sublime-imfix.so移动到/opt/sublime_text/（sublime的安装目录） 终端输入： cd ~/sublime-text-imfix sudo cp ./lib/libsublime-imfix.so /opt/sublime_text/ sudo cp ./src/subl /usr/bin/","text":"前言sublimeText虽说可以跨平台使用，但是在linux下缺少对中文的支持。 解决sublimeText3不支持中文输入1.从github下载sublime-text-imfix程序，添加中文支持 git clone https://github.com/lyfeyaj/sublime-text-imfix.git 2.将subl移动到/usr/bin/，并且将sublime-imfix.so移动到/opt/sublime_text/（sublime的安装目录） 终端输入： cd ~/sublime-text-imfix sudo cp ./lib/libsublime-imfix.so /opt/sublime_text/ sudo cp ./src/subl /usr/bin/ 3.用subl命令试试能不能启动sublime，首先查看一下subl文件中的sublimeTest安装路径是否正确： chenende@chenende-CN15S:/usr/bin$ cat subl #!/bin/sh export LD_PRELOAD=/home/chenende/application/sublime_text_3/libsublime-imfix.so exec /home/chenende/application/sublime_text_3/sublime_text &quot;$@&quot; 如果成功启动的话，就可以输入中文了。 终端输入： LD_PRELOAD=./libsublime-imfix.so subl 4.但是这样子只能用上述命令行启动才能输入中文，我们需要更简单的办法，我选择新建一个shell脚本，很简单，就一句话。sublime新建文件输入： #!/bin/bash LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so subl 然后将文件另存为sublime（注意：没有后缀），并且放到～（即/home/username当前用户的文件夹）文件夹。 5.至此，所有工作完成了。想要启动，直接终端输入： bash ~/sublime 就可以启动sublime，并且能够输入中文。 参考资料 @简书www.jianshu.com/p/bf05fb3a4709","categories":[{"name":"sublimeText","slug":"sublimeText","permalink":"https://www.chenende.top/categories/sublimeText/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://www.chenende.top/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.chenende.top/tags/ubuntu/"},{"name":"sublimeText","slug":"sublimeText","permalink":"https://www.chenende.top/tags/sublimeText/"}]}]}